/*!
 * PixiJS - v8.10.1
 * Compiled Wed, 18 Jun 2025 16:40:00 UTC
 * most rewrite by Zaun
 */
var PIXI = (function (exports) {
  "use strict";
  const { ColorSystem, PoolSystem, LogSystem } = Zaun.Core;
  const { getPoolObject, returnPoolObject, createPool, Pool, PoolCache } = PoolSystem;
  const { Color } = ColorSystem;
  const { Logger } = LogSystem;
  var __defProp$19 = Object.defineProperty;
  var __defProps$r = Object.defineProperties;
  var __getOwnPropDescs$r = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$19 = Object.getOwnPropertySymbols;
  var __hasOwnProp$19 = Object.prototype.hasOwnProperty;
  var __propIsEnum$19 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$19 = (obj, key, value) => key in obj ? __defProp$19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$19 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$19.call(b, prop))
        __defNormalProp$19(a, prop, b[prop]);
    if (__getOwnPropSymbols$19)
      for (var prop of __getOwnPropSymbols$19(b)) {
        if (__propIsEnum$19.call(b, prop))
          __defNormalProp$19(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$r = (a, b) => __defProps$r(a, __getOwnPropDescs$r(b));
  var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
    ExtensionType2["Application"] = "application";
    ExtensionType2["WebGLPipes"] = "webgl-pipes";
    ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
    ExtensionType2["WebGLSystem"] = "webgl-system";
    ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
    ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
    ExtensionType2["WebGPUSystem"] = "webgpu-system";
    ExtensionType2["CanvasSystem"] = "canvas-system";
    ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
    ExtensionType2["CanvasPipes"] = "canvas-pipes";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    ExtensionType2["MaskEffect"] = "mask-effect";
    ExtensionType2["BlendMode"] = "blend-mode";
    ExtensionType2["TextureSource"] = "texture-source";
    ExtensionType2["Environment"] = "environment";
    ExtensionType2["ShapeBuilder"] = "shape-builder";
    ExtensionType2["Batcher"] = "batcher";
    return ExtensionType2;
  })(ExtensionType || {});
  const normalizeExtension = (ext) => {
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
      if (!ext.extension) {
        throw new Error("Extension class must have an extension object");
      }
      const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
      ext = __spreadProps$r(__spreadValues$19({}, metadata), { ref: ext });
    }
    if (typeof ext === "object") {
      ext = __spreadValues$19({}, ext);
    } else {
      throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
      ext.type = [ext.type];
    }
    return ext;
  };
  const normalizeExtensionPriority = (ext, defaultPriority) => {
    var _a;
    return (_a = normalizeExtension(ext).priority) != null ? _a : defaultPriority;
  };
  const extensions = {
    /** @ignore */
    _addHandlers: {},
    /** @ignore */
    _removeHandlers: {},
    /** @ignore */
    _queue: {},
    /**
     * Remove extensions from PixiJS.
     * @param extensions - Extensions to be removed.
     * @returns {extensions} For chaining.
     */
    remove(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => {
          var _a, _b;
          return (_b = (_a = this._removeHandlers)[type]) == null ? void 0 : _b.call(_a, ext);
        });
      });
      return this;
    },
    /**
     * Register new extensions with PixiJS.
     * @param extensions - The spread of extensions to add to PixiJS.
     * @returns {extensions} For chaining.
     */
    add(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => {
          var _a, _b;
          const handlers = this._addHandlers;
          const queue = this._queue;
          if (!handlers[type]) {
            queue[type] = queue[type] || [];
            (_a = queue[type]) == null ? void 0 : _a.push(ext);
          } else {
            (_b = handlers[type]) == null ? void 0 : _b.call(handlers, ext);
          }
        });
      });
      return this;
    },
    /**
     * Internal method to handle extensions by name.
     * @param type - The extension type.
     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
     * @returns {extensions} For chaining.
     */
    handle(type, onAdd, onRemove) {
      var _a;
      const addHandlers = this._addHandlers;
      const removeHandlers = this._removeHandlers;
      if (addHandlers[type] || removeHandlers[type]) {
        throw new Error(`Extension type ${type} already has a handler`);
      }
      addHandlers[type] = onAdd;
      removeHandlers[type] = onRemove;
      const queue = this._queue;
      if (queue[type]) {
        (_a = queue[type]) == null ? void 0 : _a.forEach((ext) => onAdd(ext));
        delete queue[type];
      }
      return this;
    },
    /**
     * Handle a type, but using a map by `name` property.
     * @param type - Type of extension to handle.
     * @param map - The object map of named extensions.
     * @returns {extensions} For chaining.
     */
    handleByMap(type, map) {
      return this.handle(
        type,
        (extension) => {
          if (extension.name) {
            map[extension.name] = extension.ref;
          }
        },
        (extension) => {
          if (extension.name) {
            delete map[extension.name];
          }
        }
      );
    },
    /**
     * Handle a type, but using a list of extensions with a `name` property.
     * @param type - Type of extension to handle.
     * @param map - The array of named extensions.
     * @param defaultPriority - Fallback priority if none is defined.
     * @returns {extensions} For chaining.
     */
    handleByNamedList(type, map, defaultPriority = -1) {
      return this.handle(
        type,
        (extension) => {
          const index = map.findIndex((item) => item.name === extension.name);
          if (index >= 0)
            return;
          map.push({ name: extension.name, value: extension.ref });
          map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
        },
        (extension) => {
          const index = map.findIndex((item) => item.name === extension.name);
          if (index !== -1) {
            map.splice(index, 1);
          }
        }
      );
    },
    /**
     * Handle a type, but using a list of extensions.
     * @param type - Type of extension to handle.
     * @param list - The list of extensions.
     * @param defaultPriority - The default priority to use if none is specified.
     * @returns {extensions} For chaining.
     */
    handleByList(type, list, defaultPriority = -1) {
      return this.handle(
        type,
        (extension) => {
          if (list.includes(extension.ref)) {
            return;
          }
          list.push(extension.ref);
          list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
        },
        (extension) => {
          const index = list.indexOf(extension.ref);
          if (index !== -1) {
            list.splice(index, 1);
          }
        }
      );
    }
  };

  class EventListener {
    constructor() {
      this.reset();
    }
    set(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
      this.funcName = fn.name;
    }
    reset() {
      this.fn = null;
      this.context = null;
      this.once = false;
      this.funcName = String.empty;
    }
  }

  class List extends Array {
    reset() {
      this.length = 0;
    }
  }
  const ListenerPool = createPool("ListenerPool", EventListener);

  class EventEmitter {
    static EventList = createPool("ArrayPool", List);
    constructor() {
      this.listeners = Object.create(null);
      this.eventsCount = 0;
    }
    emit(eventName, a1, a2, a3) {
      const listeners = this.listeners;
      const listener = listeners[eventName];
      if (listener === void 0) return this;
      if (listener.fn) {
        const fn = listener.fn;
        const context = listener.context;
        const funcName = listener.funcName;
        context[funcName](a1, a2, a3);
        if (listener.once) {
          this.removeListener(eventName, fn, context);
        }
      } else {
        for (let i = 0; i < listener.length; i++) {
          const event = listener[i];
          const fn = event.fn;
          const context = event.context;
          const funcName = event.funcName;
          context[funcName](a1, a2, a3);
          if (event.once) {
            this.removeListener(eventName, fn, context);
            i -= 1;
          }
        }
      }
      return this;
    }
    addListener(eventName, fn, context, once) {
      const listener = ListenerPool.get();
      listener.set(fn, context, once);
      const listeners = this.listeners;
      const target = listeners[eventName];
      if (target === void 0) {
        listeners[eventName] = listener;
        this.eventsCount++;
      } else if (target.fn === void 0) {
        target[target.length] = listener;
      } else {
        const list = EventEmitter.EventList.get();
        list[0] = target;
        list[1] = listener;
        listeners[eventName] = list;
      }
      return this;
    }
    removeListener(eventName, fn, context) {
      const listener = this.listeners[eventName];
      if (listener === void 0) return this;
      if (listener.fn) {
        if (listener.fn === fn && listener.context === context) {
          this.clearListener(eventName);
        }
      } else {
        for (let i = listener.length - 1; i > -1; i--) {
          const event = listener[i];
          if (event.fn === fn && event.context === context) {
            listener.remove(event, i);
          }
        }
        if (listener.length === 0) this.clearListener(eventName);
      }
      return this;
    }
    removeAllListeners() {
      const listeners = this.listeners;
      for (const key in listeners) {
        const listener = listeners[key];
        if (listener === void 0) continue;
        if (Array.isArray(listener)) {
          for (let i = 0; i < listener.length; i++) {
            ListenerPool.return(listener[i]);
          }
          EventEmitter.EventList.return(listener);
        } else {
          ListenerPool.return(listener);
        }
      }
      this.listeners = Object.create(null);
      this.eventsCount = 0;
      return this;
    }
    on(eventName, fn, context, once) {
      return this.addListener(eventName, fn, context, once);
    }
    off(eventName, fn, context) {
      return this.removeListener(eventName, fn, context);
    }
    once(eventName, fn, context) {
      return this.addListener(eventName, fn, context, true);
    }
    clearListener(eventName) {
      const listener = this.listeners[eventName];
      if (listener === void 0) return this;
      if (Array.isArray(listener)) {
        for (let i = listener.length - 1; i > -1; i--) {
          ListenerPool.return(listener[i]);
        }
        EventEmitter.EventList.return(listener);
      } else {
        ListenerPool.return(listener);
      }
      this.listeners[eventName] = void 0;
      this.eventsCount -= 1;
      return this;
    }
  }

  "use strict";
  const PI_2 = Math.PI * 2;
  const RAD_TO_DEG = 180 / Math.PI;
  const DEG_TO_RAD = Math.PI / 180;

  "use strict";
  class Point {
    /**
     * Creates a new `Point`
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    constructor(x = 0, y = 0) {
      /** Position of the point on the x axis */
      this.x = 0;
      /** Position of the point on the y axis */
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    /**
     * Creates a clone of this point
     * @returns A clone of this point
     */
    clone() {
      return new Point(this.x, this.y);
    }
    /**
     * Copies `x` and `y` from the given point into this point
     * @param p - The point to copy from
     * @returns The point instance itself
     */
    copyFrom(p) {
      this.set(p.x, p.y);
      return this;
    }
    /**
     * Copies this point's x and y into the given point (`p`).
     * @param p - The point to copy to. Can be any of type that is or extends `PointData`
     * @returns The point (`p`) with values updated
     */
    copyTo(p) {
      p.set(this.x, this.y);
      return p;
    }
    /**
     * Accepts another point (`p`) and returns `true` if the given point is equal to this point
     * @param p - The point to check
     * @returns Returns `true` if both `x` and `y` are equal
     */
    equals(p) {
      return p.x === this.x && p.y === this.y;
    }
    /**
     * Sets the point to a new `x` and `y` position.
     * If `y` is omitted, both `x` and `y` will be set to `x`.
     * @param {number} [x=0] - position of the point on the `x` axis
     * @param {number} [y=x] - position of the point on the `y` axis
     * @returns The point instance itself
     */
    set(x = 0, y = x) {
      this.x = x;
      this.y = y;
      return this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
  }
  Point.empty = new Point(0, 0);

  "use strict";
  class Matrix {
    /**
     * @param a - x scale
     * @param b - y skew
     * @param c - x skew
     * @param d - y scale
     * @param tx - x translation
     * @param ty - y translation
     */
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
      /** An array of the current matrix. Only populated when `toArray` is called */
      this.array = null;
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     * @param array - The array that the matrix will be populated from.
     */
    fromArray(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    }
    /**
     * Sets the matrix properties.
     * @param a - Matrix component
     * @param b - Matrix component
     * @param c - Matrix component
     * @param d - Matrix component
     * @param tx - Matrix component
     * @param ty - Matrix component
     * @returns This matrix. Good for chaining method calls.
     */
    set(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
      return this;
    }
    /**
     * Creates an array from the current Matrix object.
     * @param transpose - Whether we need to transpose the matrix or not
     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @returns The newly created array which contains the matrix
     */
    toArray(_transpose = false, _out) {
      let array = this.array;
      if (array === null) {
        array = this.array = new Float32Array(9);
      }
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
      return array;
    }
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     * @param pos - The origin
     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @returns {Point} The new point, transformed through this matrix
     */
    apply(pos, newPos) {
      newPos = newPos || new Point();
      const x = pos.x;
      const y = pos.y;
      newPos.x = this.a * x + this.c * y + this.tx;
      newPos.y = this.b * x + this.d * y + this.ty;
      return newPos;
    }
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     * @param pos - The origin
     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @returns {Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(pos, newPos) {
      newPos = newPos || new Point();
      const a = this.a;
      const b = this.b;
      const c = this.c;
      const d = this.d;
      const tx = this.tx;
      const ty = this.ty;
      const id = 1 / (a * d + c * -b);
      const x = pos.x;
      const y = pos.y;
      newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
      newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
      return newPos;
    }
    /**
     * Translates the matrix on the x and y.
     * @param x - How much to translate x by
     * @param y - How much to translate y by
     * @returns This matrix. Good for chaining method calls.
     */
    translate(x, y) {
      this.tx += x;
      this.ty += y;
      return this;
    }
    /**
     * Applies a scale transformation to the matrix.
     * @param x - The amount to scale horizontally
     * @param y - The amount to scale vertically
     * @returns This matrix. Good for chaining method calls.
     */
    scale(x, y) {
      this.a *= x;
      this.d *= y;
      this.c *= x;
      this.b *= y;
      this.tx *= x;
      this.ty *= y;
      return this;
    }
    /**
     * Applies a rotation transformation to the matrix.
     * @param angle - The angle in radians.
     * @returns This matrix. Good for chaining method calls.
     */
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const a1 = this.a;
      const c1 = this.c;
      const tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    }
    /**
     * Appends the given Matrix to this Matrix.
     * @param matrix - The matrix to append.
     * @returns This matrix. Good for chaining method calls.
     */
    append(matrix) {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    }
    /**
     * Appends two matrix's and sets the result to this matrix. AB = A * B
     * @param a - The matrix to append.
     * @param b - The matrix to append.
     * @returns This matrix. Good for chaining method calls.
     */
    appendFrom(a, b) {
      const a1 = a.a;
      const b1 = a.b;
      const c1 = a.c;
      const d1 = a.d;
      const tx = a.tx;
      const ty = a.ty;
      const a2 = b.a;
      const b2 = b.b;
      const c2 = b.c;
      const d2 = b.d;
      this.a = a1 * a2 + b1 * c2;
      this.b = a1 * b2 + b1 * d2;
      this.c = c1 * a2 + d1 * c2;
      this.d = c1 * b2 + d1 * d2;
      this.tx = tx * a2 + ty * c2 + b.tx;
      this.ty = tx * b2 + ty * d2 + b.ty;
      return this;
    }
    /**
     * Sets the matrix based on all the available properties
     * @param x - Position on the x axis
     * @param y - Position on the y axis
     * @param pivotX - Pivot on the x axis
     * @param pivotY - Pivot on the y axis
     * @param scaleX - Scale on the x axis
     * @param scaleY - Scale on the y axis
     * @param rotation - Rotation in radians
     * @param skewX - Skew on the x axis
     * @param skewY - Skew on the y axis
     * @returns This matrix. Good for chaining method calls.
     */
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x - (pivotX * this.a + pivotY * this.c);
      this.ty = y - (pivotX * this.b + pivotY * this.d);
      return this;
    }
    /**
     * Prepends the given Matrix to this Matrix.
     * @param matrix - The matrix to prepend
     * @returns This matrix. Good for chaining method calls.
     */
    prepend(matrix) {
      const tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        const a1 = this.a;
        const c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    }
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     * @param transform - The transform to apply the properties to.
     * @returns The transform with the newly applied properties
     */
    decompose(transform) {
      const a = this.a;
      const b = this.b;
      const c = this.c;
      const d = this.d;
      const pivot = transform.pivot;
      const skewX = -Math.atan2(-c, d);
      const skewY = Math.atan2(b, a);
      const delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.set(0, 0);
      } else {
        transform.rotation = 0;
        transform.skew.set(skewX, skewY);
      }
      transform.scale.set(Math.sqrt(a * a + b * b), Math.sqrt(c * c + d * d));
      transform.position.set(this.tx + (pivot.x * a + pivot.y * c), this.ty + (pivot.x * b + pivot.y * d));
      return transform;
    }
    /**
     * Inverts this matrix
     * @returns This matrix. Good for chaining method calls.
     */
    invert() {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      const tx1 = this.tx;
      const n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    }
    /** Checks if this matrix is an identity matrix */
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    /**
     * Resets this Matrix to an identity (default) matrix.
     * @returns This matrix. Good for chaining method calls.
     */
    identity() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    }
    /**
     * Creates a new Matrix object with the same values as this one.
     * @returns A copy of this matrix. Good for chaining method calls.
     */
    clone() {
      const matrix = new Matrix();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     * @param matrix - The matrix to copy to.
     * @returns The matrix given in parameter with its values updated.
     */
    copyTo(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     * @param matrix - The matrix to copy from.
     * @returns this
     */
    copyFrom(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    }
    /**
     * check to see if two matrices are the same
     * @param matrix - The matrix to compare to.
     */
    equals(matrix) {
      return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    /**
     * A default (identity) matrix.
     *
     * This is a shared object, if you want to modify it consider creating a new `Matrix`
     * @readonly
     */
    static get IDENTITY() {
      return identityMatrix$1.identity();
    }
    /**
     * A static Matrix that can be used to avoid creating new objects.
     * Will always ensure the matrix is reset to identity when requested.
     * Use this object for fast but temporary calculations, as it may be mutated later on.
     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
     * @readonly
     */
    static get shared() {
      return tempMatrix$5.identity();
    }
  }
  const tempMatrix$5 = new Matrix();
  const identityMatrix$1 = new Matrix();

  "use strict";
  class ObservablePoint {
    /**
     * Creates a new `ObservablePoint`
     * @param observer - Observer to pass to listen for change events.
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    constructor(observer, x, y) {
      this._x = x || 0;
      this._y = y || 0;
      this._observer = observer;
    }
    /**
     * Creates a clone of this point.
     * @param observer - Optional observer to pass to the new observable point.
     * @returns a copy of this observable point
     */
    clone(observer) {
      return new ObservablePoint(observer != null ? observer : this._observer, this._x, this._y);
    }
    /**
     * Sets the point to a new `x` and `y` position.
     * If `y` is omitted, both `x` and `y` will be set to `x`.
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns The observable point instance itself
     */
    set(x = 0, y = x) {
      if (this._x !== x || this._y !== y) {
        this._x = x;
        this._y = y;
        this._observer._onUpdate(this);
      }
      return this;
    }
    /**
     * Copies x and y from the given point (`p`)
     * @param p - The point to copy from. Can be any of type that is or extends `PointData`
     * @returns The observable point instance itself
     */
    copyFrom(p) {
      if (this._x !== p.x || this._y !== p.y) {
        this._x = p.x;
        this._y = p.y;
        this._observer._onUpdate(this);
      }
      return this;
    }
    /**
     * Copies this point's x and y into that of the given point (`p`)
     * @param p - The point to copy to. Can be any of type that is or extends `PointData`
     * @returns The point (`p`) with values updated
     */
    copyTo(p) {
      p.set(this._x, this._y);
      return p;
    }
    /**
     * Accepts another point (`p`) and returns `true` if the given point is equal to this point
     * @param p - The point to check
     * @returns Returns `true` if both `x` and `y` are equal
     */
    equals(p) {
      return p.x === this._x && p.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
    }
    /** Position of the observable point on the x axis. */
    get x() {
      return this._x;
    }
    set x(value) {
      if (this._x !== value) {
        this._x = value;
        this._observer._onUpdate(this);
      }
    }
    /** Position of the observable point on the y axis. */
    get y() {
      return this._y;
    }
    set y(value) {
      if (this._y !== value) {
        this._y = value;
        this._observer._onUpdate(this);
      }
    }
  }

  "use strict";
  const uidCache = {
    default: -1
  };
  function uid$1(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  function resetUids() {
    for (const key in uidCache) {
      delete uidCache[key];
    }
  }

  "use strict";
  const warnings = {};
  const v8_0_0 = "8.0.0";
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      Logger.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      Logger.group(
        `${message} Deprecated since v${version}`,
        true
      );
      Logger.warn(stack);
      Logger.groupEnd();
    }
    warnings[message] = true;
  }

  "use strict";
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i = startIdx; i < len; ++i) {
      arr[i] = arr[i + removeCount];
    }
    arr.length = len;
  }

  "use strict";
  const childrenHelperMixin = {
    allowChildren: true,
    /**
     * Removes all children from this container that are within the begin and end indexes.
     * @param beginIndex - The beginning position.
     * @param endIndex - The ending position. Default value is size of the container.
     * @returns - List of removed children
     * @memberof scene.Container#
     */
    removeChildren(beginIndex = 0, endIndex) {
      const end = endIndex != null ? endIndex : this.children.length;
      const range = end - beginIndex;
      const removed = [];
      if (range > 0 && range <= end) {
        for (let i = end - 1; i >= beginIndex; i--) {
          const child = this.children[i];
          if (!child) continue;
          removed.push(child);
          child.parent = null;
        }
        removeItems(this.children, beginIndex, end);
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.removeChildren(removed);
        }
        return removed;
      } else if (range === 0 && this.children.length === 0) {
        return removed;
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    /**
     * Removes a child from the specified index position.
     * @param index - The index to get the child from
     * @returns The child that was removed.
     * @memberof scene.Container#
     */
    removeChildAt(index) {
      const child = this.getChildAt(index);
      return this.removeChild(child);
    },
    /**
     * Returns the child at the specified index
     * @param index - The index to get the child at
     * @returns - The child at the given index, if any.
     * @memberof scene.Container#
     */
    getChildAt(index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`getChildAt: Index (${index}) does not exist.`);
      }
      return this.children[index];
    },
    /**
     * Changes the position of an existing child in the container container
     * @param child - The child Container instance for which you want to change the index number
     * @param index - The resulting index number for the child container
     * @memberof scene.Container#
     */
    setChildIndex(child, index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
      }
      this.getChildIndex(child);
      this.addChildAt(child, index);
    },
    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
     * If the child is already in this container, it will be moved to the specified index.
     * @param {Container} child - The child to add.
     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
     * @returns {Container} The child that was added.
     * @memberof scene.Container#
     */
    addChildAt(child, index) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      }
      const { children } = this;
      if (index < 0 || index > children.length) {
        throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
      }
      if (child.parent) {
        const currentIndex = child.parent.children.indexOf(child);
        if (child.parent === this && currentIndex === index) {
          return child;
        }
        if (currentIndex !== -1) {
          child.parent.children.splice(currentIndex, 1);
        }
      }
      if (index === children.length) {
        children.push(child);
      } else {
        children.splice(index, 0, child);
      }
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      if (this.sortableChildren)
        this.sortDirty = true;
      return child;
    },
    /**
     * Swaps the position of 2 Containers within this container.
     * @param child - First container to swap
     * @param child2 - Second container to swap
     * @memberof scene.Container#
     */
    swapChildren(child, child2) {
      if (child === child2) {
        return;
      }
      const children = this.children;
      const index1 = children.indexOf(child)
      const index2 = children.indexOf(child2)
      children[index1] = child2;
      children[index2] = child;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      this._didContainerChangeTick++;
    },
    replaceChild(replacer, target) {
      if (replacer === target) return;
      if (replacer.parent === this) {
        return;
      }
      replacer.removeFromParent();
      const children = this.children;
      const index = children.indexOf(target);
      if (index === -1) {
        throw new Error("target doesn't exist in container");
      }
      children[index] = replacer;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.replaceChild(replacer, target);
      }
      target.parent = null;
      replacer.parent = this;
      this._didContainerChangeTick++;
    },
    /**
     * Remove the Container from its parent Container. If the Container has no parent, do nothing.
     * @memberof scene.Container#
     */
    removeFromParent() {
      var _a;
      (_a = this.parent) == null ? void 0 : _a.removeChild(this);
    },
    /**
     * Reparent the child to this container, keeping the same worldTransform.
     * @param child - The child to reparent
     * @returns The first child that was reparented.
     * @memberof scene.Container#
     */
    reparentChild(...child) {
      if (child.length === 1) {
        return this.reparentChildAt(child[0], this.children.length);
      }
      child.forEach((c) => this.reparentChildAt(c, this.children.length));
      return child[0];
    }
  };

  const collectRenderablesMixin = {
    /**
     * Main method to collect renderables from the container and its children.
     * It checks the container's properties to decide whether to use a simple or advanced collection method.
     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
     * @param {Renderer} renderer - The renderer responsible for rendering the scene.
     * @memberof scene.Container#
     */
    collectRenderables(instructionSet, renderer) {
      if (this.globalDisplayStatus < 7 || !this.includeInBuild) return;
      // Choose the appropriate method for collecting renderables based on the container's properties.
      if (this.isSimple) {
        this.collectRenderablesSimple(instructionSet, renderer);
      } else if (this.renderGroup) {
        renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
      } else {
        this.collectRenderablesWithEffects(instructionSet, renderer);
      }
    },

    /**
     * Simple method for collecting renderables from the container's children.
     * This method is efficient and used when the container is marked as simple.
     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
     * @param {Renderer} renderer - The renderer responsible for rendering the scene.
     * @memberof scene.Container#
     */
    collectRenderablesSimple(instructionSet, renderer) {
      const children = this.children;
      const length = children.length;
      if (length === 0) return;
      // Iterate over each child and collect their renderables.
      for (let i = 0; i < length; i++) {
        children[i].collectRenderables(instructionSet, renderer);
      }
    },

    /**
     * Advanced method for collecting renderables, which handles additional effects.
     * This method is used when the container has complex processing needs.
     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
     * @param {Renderer} renderer - The renderer responsible for rendering the scene.
     * @memberof scene.Container#
     */
    collectRenderablesWithEffects(instructionSet, renderer) {
      const renderPipes = renderer.renderPipes;
      // Apply each effect to the renderables before collecting them.
      const effects = this.effects;
      const size = effects.length;
      const hasEffects = size > 0;
      if (hasEffects) {
        for (let i = 0; i < size; i++) {
          const effect = effects[i];
          const pipe = renderPipes[effect.pipe];
          pipe.push(effect, this, instructionSet);
        }
      }
      // Collect renderables using the simple method after applying effects.
      this.collectRenderablesSimple(instructionSet, renderer);
      // Remove effects from the renderables after collection, processing in reverse order.
      if (hasEffects) {
        for (let i = size - 1; i >= 0; i--) {
          const effect = effects[i];
          const pipe = renderPipes[effect.pipe];
          pipe.pop(effect, this, instructionSet);
        }
      }
    }
  }

  const getFastGlobalBoundsMixin = {
    /**
     * Computes the global bounds for the container, considering its children and optionally
     * factoring in render layers. It starts by clearing the provided bounds object, then
     * recursively calculates the bounds, and finally applies the world transformation.
     * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.
     * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.
     * @returns {Bounds} The computed bounds.
     * @memberof scene.Container#
     */
    getFastGlobalBounds(factorRenderLayers, bounds) {
      bounds ||= new Bounds();
      // Initialize the bounds for fresh calculations.
      bounds.clear();
      // Calculate bounds recursively, starting from the current container.
      this._getGlobalBoundsRecursive(factorRenderLayers, bounds);
      // Validate the calculated bounds, resetting if invalid.
      if (!bounds.isValid) {
        bounds.set(0, 0, 0, 0);
      }
      // Apply the world transformation to the bounds.
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      bounds.applyMatrix(renderGroup.worldTransform);
      return bounds;
    },

    /**
     * Recursively calculates the global bounds for the container and its children.
     * It considers visibility, measurability, and effects, and applies transformations
     * as necessary to compute the bounds accurately.
     * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.
     * @param {Bounds} bounds - The bounds object to update with the calculated values.
     * @memberof scene.Container#
     */
    _getGlobalBoundsRecursive(factorRenderLayers, bounds) {
      let localBounds = bounds;
      // Skip if the container is not in the current render layer when factoring render layers.
      if (factorRenderLayers) return;
      // Skip if the container is not fully visible or not measurable.
      if (this.localDisplayStatus !== 7 || (!this.measurable)) {
        return;
      }
      // Determine if effects need to be managed, requiring separate bounds handling.
      const manageEffects = !!this.effects.length;
      // Use a temporary bounds object if the container is a render group or has effects.
      if (this.renderGroup || manageEffects) {
        localBounds = boundsPool.get().clear();
      }
      // Add the container's own bounds area to the bounds if it exists.
      if (this.boundsArea) {
        bounds.addRect(this.boundsArea, this.worldTransform);
      }
      else {
        // If the container is renderable, add its bounds to the local bounds.
        if (this.renderPipeId) {
          const viewBounds = this.bounds;
          localBounds.addFrame(
            viewBounds.minX,
            viewBounds.minY,
            viewBounds.maxX,
            viewBounds.maxY,
            this.groupTransform
          );
        }
        // Recursively process each child to include their bounds.
        const children = this.children;
        for (let i = 0; i < children.length; i++) {
          children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds);
        }
      }
      // If effects are managed, apply them to the bounds.
      if (manageEffects) {
        let advanced = false;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        // Apply each effect that modifies bounds.
        const effects = this.effects;
        for (let i = 0; i < effects.length; i++) {
          const effect = effects[i];
          if (effect.addBounds) {
            if (!advanced) {
              advanced = true;
              localBounds.applyMatrix(renderGroup.worldTransform);
            }
            effect.addBounds(localBounds, true);
          }
        }
        // Adjust bounds back to the local coordinate space if advanced bounds were calculated.
        if (advanced) {
          localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());
          bounds.addBounds(localBounds, this.relativeGroupTransform);
        }
        // Add the local bounds to the final bounds and return the temporary bounds object.
        bounds.addBounds(localBounds);
        boundsPool.return(localBounds);
      }
      else if (this.renderGroup) {
        // If the container is a render group, add its local bounds to the final bounds.
        bounds.addBounds(localBounds, this.relativeGroupTransform);
        boundsPool.return(localBounds);
      }
    }
  }

  "use strict";
  class FilterEffect {
    constructor() {
      this.filters = [];
      /** the pipe that knows how to handle this effect */
      this.pipe = "filter";
      /** the priority of this effect */
      this.priority = 1;
      this.filterArea = null;
    }
    reset() {
      this.filterArea = null;
    }
  }

  const FilterEffectPool = createPool("FilterEffectPool", FilterEffect);

  "use strict";
  class MaskEffectManagerClass {
    constructor() {
      /**
       * @private
       */
      this._effectClasses = [];
      this._tests = [];
      this._effectCount = 0;
      this._initialized = false;
    }
    init() {
      if (this._initialized) return;
      this._initialized = true;
      this._effectClasses.forEach((test) => {
        this.add({
          test: test.test,
          maskClass: test
        });
      });
    }
    add(test) {
      this._tests[this._effectCount++] = test;
    }
    getMaskEffect(item) {
      if (!this._initialized) this.init();
      const tests = this._tests;
      for (let i = 0; i < tests.length; i++) {
        const test = tests[i];
        if (test.test(item)) {
          return getPoolObject(test.maskClass, item);
        }
      }
      return item;
    }
    returnMaskEffect(effect) {
      returnPoolObject(effect);
    }
  }
  const MaskEffectManager = new MaskEffectManagerClass();
  extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);

  "use strict";
  var __defProp$17 = Object.defineProperty;
  var __getOwnPropSymbols$17 = Object.getOwnPropertySymbols;
  var __hasOwnProp$17 = Object.prototype.hasOwnProperty;
  var __propIsEnum$17 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$17 = (obj, key, value) => key in obj ? __defProp$17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$17 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$17.call(b, prop))
        __defNormalProp$17(a, prop, b[prop]);
    if (__getOwnPropSymbols$17)
      for (var prop of __getOwnPropSymbols$17(b)) {
        if (__propIsEnum$17.call(b, prop))
          __defNormalProp$17(a, prop, b[prop]);
      }
    return a;
  };
  const effectsMixin = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    /**
     * @todo Needs docs.
     * @memberof scene.Container#
     * @type {Array<Effect>}
     */
    effects: [],
    /**
     * @todo Needs docs.
     * @param effect - The effect to add.
     * @memberof scene.Container#
     * @ignore
     */
    addEffect(effect) {
      if (this.effects.add(effect)) {
        this.onEffectChanged();
        this._updateIsSimple();
      };
    },
    onEffectChanged() {
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
    },
    /**
     * @todo Needs docs.
     * @param effect - The effect to remove.
     * @memberof scene.Container#
     * @ignore
     */
    removeEffect(effect) {
      if (this.effects.remove(effect)) {
        this.onEffectChanged();
        this._updateIsSimple();
      };
    },
    set mask(value) {
      const effect = this._maskEffect;
      if ((effect == null ? void 0 : effect.mask) === value)
        return;
      if (effect) {
        this.removeEffect(effect);
        MaskEffectManager.returnMaskEffect(effect);
        this._maskEffect = null;
      }
      if (value === null || value === void 0)
        return;
      this._maskEffect = MaskEffectManager.getMaskEffect(value);
      this.addEffect(this._maskEffect);
    },
    /**
     * Used to set mask and control mask options.
     * @param options
     * @example
     * import { Graphics, Sprite } from 'pixi.js';
     *
     * const graphics = new Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new Sprite(texture);
     * sprite.setMask({
     *     mask: graphics,
     *     inverse: true,
     * });
     * @memberof scene.Container#
     */
    setMask(options) {
      this._maskOptions = __spreadValues$17(__spreadValues$17({}, this._maskOptions), options);
      if (options.mask) {
        this.mask = options.mask;
      }
    },
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
     * To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * import { Graphics, Sprite } from 'pixi.js';
     *
     * const graphics = new Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new Sprite(texture);
     * sprite.mask = graphics;
     * @memberof scene.Container#
     */
    get mask() {
      var _a;
      return (_a = this._maskEffect) == null ? void 0 : _a.mask;
    }
  };

  "use strict";
  const tempPoints = [new Point(), new Point(), new Point(), new Point()];
  class Rectangle {
    /**
     * @param x - The X coordinate of the upper-left corner of the rectangle
     * @param y - The Y coordinate of the upper-left corner of the rectangle
     * @param width - The overall width of the rectangle
     * @param height - The overall height of the rectangle
     */
    constructor(x = 0, y = 0, width = 0, height = 0) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'rectangle'
       */
      this.type = "rectangle";
      this.x = Number(x);
      this.y = Number(y);
      this.width = Number(width);
      this.height = Number(height);
    }
    reset() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      return this;
    }
    set(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    }
    /** Returns the left edge of the rectangle. */
    get left() {
      return this.x;
    }
    /** Returns the right edge of the rectangle. */
    get right() {
      return this.x + this.width;
    }
    /** Returns the top edge of the rectangle. */
    get top() {
      return this.y;
    }
    /** Returns the bottom edge of the rectangle. */
    get bottom() {
      return this.y + this.height;
    }
    /** Determines whether the Rectangle is empty. */
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    /** A constant empty rectangle. This is a new object every time the property is accessed */
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    /**
     * Creates a clone of this Rectangle
     * @returns a copy of the rectangle
     */
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    /**
     * Converts a Bounds object to a Rectangle object.
     * @param bounds - The bounds to copy and convert to a rectangle.
     * @returns Returns itself.
     */
    copyFromBounds(bounds) {
      this.x = bounds.minX;
      this.y = bounds.minY;
      this.width = bounds.maxX - bounds.minX;
      this.height = bounds.maxY - bounds.minY;
      return this;
    }
    /**
     * Copies another rectangle to this one.
     * @param rectangle - The rectangle to copy from.
     * @returns Returns itself.
     */
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    /**
     * Copies this rectangle to another one.
     * @param rectangle - The rectangle to copy to.
     * @returns Returns given parameter.
     */
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @returns Whether the x/y coordinates are within this Rectangle
     */
    contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x < this.x + this.width) {
        if (y >= this.y && y < this.y + this.height) {
          return true;
        }
      }
      return false;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @param strokeWidth - The width of the line to check
     * @returns Whether the x/y coordinates are within this rectangle
     */
    strokeContains(x, y, strokeWidth) {
      const { width, height } = this;
      if (width <= 0 || height <= 0)
        return false;
      const _x = this.x;
      const _y = this.y;
      const outerLeft = _x - strokeWidth / 2;
      const outerRight = _x + width + strokeWidth / 2;
      const outerTop = _y - strokeWidth / 2;
      const outerBottom = _y + height + strokeWidth / 2;
      const innerLeft = _x + strokeWidth / 2;
      const innerRight = _x + width - strokeWidth / 2;
      const innerTop = _y + strokeWidth / 2;
      const innerBottom = _y + height - strokeWidth / 2;
      return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);
    }
    /**
     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
     * Returns true only if the area of the intersection is >0, this means that Rectangles
     * sharing a side are not overlapping. Another side effect is that an arealess rectangle
     * (width or height equal to zero) can't intersect any other rectangle.
     * @param {Rectangle} other - The Rectangle to intersect with `this`.
     * @param {Matrix} transform - The transformation matrix of `other`.
     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
     */
    intersects(other, transform) {
      if (!transform) {
        const x02 = this.x < other.x ? other.x : this.x;
        const x12 = this.right > other.right ? other.right : this.right;
        if (x12 <= x02) {
          return false;
        }
        const y02 = this.y < other.y ? other.y : this.y;
        const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y12 > y02;
      }
      const x0 = this.left;
      const x1 = this.right;
      const y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      const lt = tempPoints[0].set(other.left, other.top);
      const lb = tempPoints[1].set(other.left, other.bottom);
      const rt = tempPoints[2].set(other.right, other.top);
      const rb = tempPoints[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return false;
      }
      const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (s === 0) {
        return false;
      }
      transform.apply(lt, lt);
      transform.apply(lb, lb);
      transform.apply(rt, rt);
      transform.apply(rb, rb);
      if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
        return false;
      }
      const nx = s * (lb.y - lt.y);
      const ny = s * (lt.x - lb.x);
      const n00 = nx * x0 + ny * y0;
      const n10 = nx * x1 + ny * y0;
      const n01 = nx * x0 + ny * y1;
      const n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
        return false;
      }
      const mx = s * (lt.y - rt.y);
      const my = s * (rt.x - lt.x);
      const m00 = mx * x0 + my * y0;
      const m10 = mx * x1 + my * y0;
      const m01 = mx * x0 + my * y1;
      const m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
        return false;
      }
      return true;
    }
    /**
     * Pads the rectangle making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     * @param paddingX - The horizontal padding amount.
     * @param paddingY - The vertical padding amount.
     * @returns Returns itself.
     */
    pad(paddingX = 0, paddingY = paddingX) {
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    }
    /**
     * Fits this rectangle around the passed one.
     * @param rectangle - The rectangle to fit.
     * @returns Returns itself.
     */
    fit(rectangle) {
      const x = this.x;
      const y = this.y;
      const width = this.width;
      const height = this.height;
      const targerX = rectangle.x;
      const targerY = rectangle.y;
      const targerWidth = rectangle.width;
      const targerHeight = rectangle.height;
      const x1 = Math.max(x, targerX);
      const x2 = Math.min(x + width, targerX + targerWidth);
      const y1 = Math.max(y, targerY);
      const y2 = Math.min(y + height, targerY + targerHeight);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    }
    /**
     * Enlarges rectangle that way its corners lie on grid
     * @param resolution - resolution
     * @param eps - precision
     * @returns Returns itself.
     */
    ceil(resolution = 1, eps = 1e-3) {
      const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    }
    /**
     * Enlarges this rectangle to include the passed rectangle.
     * @param rectangle - The rectangle to include.
     * @returns Returns itself.
     */
    enlarge(rectangle) {
      const x = this.x;
      const y = this.y;
      const width = this.width;
      const height = this.height;
      const targerX = rectangle.x;
      const targerY = rectangle.y;
      const targerWidth = rectangle.width;
      const targerHeight = rectangle.height;
      const x1 = Math.min(x, targerX);
      const x2 = Math.max(x + width, targerX + targerWidth);
      const y1 = Math.min(y, targerY);
      const y2 = Math.max(y + height, targerY + targerHeight);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    }
    /**
     * Returns the framing rectangle of the rectangle as a Rectangle object
     * @param out - optional rectangle to store the result
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      out.copyFrom(this);
      return out;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  }
  Rectangle.empty = new Rectangle();

  "use strict";
  const defaultMatrix = new Matrix();
  class Bounds {
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
      /** @default Infinity */
      this.minX = Infinity;
      /** @default Infinity */
      this.minY = Infinity;
      /** @default -Infinity */
      this.maxX = -Infinity;
      /** @default -Infinity */
      this.maxY = -Infinity;
      this.matrix = defaultMatrix;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    /**
     * Checks if bounds are empty.
     * @returns - True if empty.
     */
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    /** The bounding rectangle of the bounds. */
    get rectangle() {
      if (!this._rectangle) {
        this._rectangle = new Rectangle();
      }
      const rectangle = this._rectangle;
      if (this.minX > this.maxX || this.minY > this.maxY) {
        rectangle.x = 0;
        rectangle.y = 0;
        rectangle.width = 0;
        rectangle.height = 0;
      } else {
        rectangle.copyFromBounds(this);
      }
      return rectangle;
    }
    /** Clears the bounds and resets. */
    clear() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.matrix = defaultMatrix;
      return this;
    }
    /**
     * Sets the bounds.
     * @param x0 - left X of frame
     * @param y0 - top Y of frame
     * @param x1 - right X of frame
     * @param y1 - bottom Y of frame
     */
    set(x0, y0, x1, y1) {
      this.minX = x0;
      this.minY = y0;
      this.maxX = x1;
      this.maxY = y1;
    }
    /**
     * Adds sprite frame
     * @param x0 - left X of frame
     * @param y0 - top Y of frame
     * @param x1 - right X of frame
     * @param y1 - bottom Y of frame
     * @param matrix
     */
    addFrame(x0, y0, x1, y1, matrix) {
      matrix || (matrix = this.matrix);
      const a = matrix.a;
      const b = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x = a * x0 + c * y0 + tx;
      let y = b * x0 + d * y0 + ty;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      x = a * x1 + c * y0 + tx;
      y = b * x1 + d * y0 + ty;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      x = a * x0 + c * y1 + tx;
      y = b * x0 + d * y1 + ty;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      x = a * x1 + c * y1 + tx;
      y = b * x1 + d * y1 + ty;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    /**
     * Adds a rectangle to the bounds.
     * @param rect - The rectangle to be added.
     * @param matrix - The matrix to apply to the bounds.
     */
    addRect(rect, matrix) {
      this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
    }
    /**
     * Adds other {@link Bounds}.
     * @param bounds - The Bounds to be added
     * @param matrix
     */
    addBounds(bounds, matrix) {
      this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
    }
    /**
     * Adds other Bounds, masked with Bounds.
     * @param mask - The Bounds to be added.
     */
    addBoundsMask(mask) {
      this.minX = this.minX > mask.minX ? this.minX : mask.minX;
      this.minY = this.minY > mask.minY ? this.minY : mask.minY;
      this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
      this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
    }
    /**
     * Adds other Bounds, multiplied with matrix.
     * @param matrix - The matrix to apply to the bounds.
     */
    applyMatrix(matrix) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      const a = matrix.a;
      const b = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let x = a * minX + c * minY + tx;
      let y = b * minX + d * minY + ty;
      this.minX = x;
      this.minY = y;
      this.maxX = x;
      this.maxY = y;
      x = a * maxX + c * minY + tx;
      y = b * maxX + d * minY + ty;
      this.minX = x < this.minX ? x : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = x > this.maxX ? x : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
      x = a * minX + c * maxY + tx;
      y = b * minX + d * maxY + ty;
      this.minX = x < this.minX ? x : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = x > this.maxX ? x : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
      x = a * maxX + c * maxY + tx;
      y = b * maxX + d * maxY + ty;
      this.minX = x < this.minX ? x : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = x > this.maxX ? x : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
    }
    /**
     * Resizes the bounds object to include the given rectangle.
     * @param rect - The rectangle to be included.
     */
    fit(rect) {
      if (this.minX < rect.left)
        this.minX = rect.left;
      if (this.maxX > rect.right)
        this.maxX = rect.right;
      if (this.minY < rect.top)
        this.minY = rect.top;
      if (this.maxY > rect.bottom)
        this.maxY = rect.bottom;
      return this;
    }
    /**
     * Resizes the bounds object to include the given bounds.
     * @param left - The left value of the bounds.
     * @param right - The right value of the bounds.
     * @param top - The top value of the bounds.
     * @param bottom - The bottom value of the bounds.
     */
    fitBounds(left, right, top, bottom) {
      if (this.minX < left)
        this.minX = left;
      if (this.maxX > right)
        this.maxX = right;
      if (this.minY < top)
        this.minY = top;
      if (this.maxY > bottom)
        this.maxY = bottom;
      return this;
    }
    /**
     * Pads bounds object, making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     * @param paddingX - The horizontal padding amount.
     * @param paddingY - The vertical padding amount.
     */
    pad(paddingX, paddingY = paddingX) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
      return this;
    }
    /** Ceils the bounds. */
    ceil() {
      this.minX = Math.floor(this.minX);
      this.minY = Math.floor(this.minY);
      this.maxX = Math.ceil(this.maxX);
      this.maxY = Math.ceil(this.maxY);
      return this;
    }
    /** Clones the bounds. */
    clone() {
      return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
    }
    /**
     * Scales the bounds by the given values
     * @param x - The X value to scale by.
     * @param y - The Y value to scale by.
     */
    scale(x, y = x) {
      this.minX *= x;
      this.minY *= y;
      this.maxX *= x;
      this.maxY *= y;
      return this;
    }
    /** the x value of the bounds. */
    get x() {
      return this.minX;
    }
    set x(value) {
      const width = this.maxX - this.minX;
      this.minX = value;
      this.maxX = value + width;
    }
    /** the y value of the bounds. */
    get y() {
      return this.minY;
    }
    set y(value) {
      const height = this.maxY - this.minY;
      this.minY = value;
      this.maxY = value + height;
    }
    /** the width value of the bounds. */
    get width() {
      return this.maxX - this.minX;
    }
    set width(value) {
      this.maxX = this.minX + value;
    }
    /** the height value of the bounds. */
    get height() {
      return this.maxY - this.minY;
    }
    set height(value) {
      this.maxY = this.minY + value;
    }
    /** the left value of the bounds. */
    get left() {
      return this.minX;
    }
    /** the right value of the bounds. */
    get right() {
      return this.maxX;
    }
    /** the top value of the bounds. */
    get top() {
      return this.minY;
    }
    /** the bottom value of the bounds. */
    get bottom() {
      return this.maxY;
    }
    /** Is the bounds positive. */
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== Infinity;
    }
    /**
     * Adds screen vertices from array
     * @param vertexData - calculated vertices
     * @param beginOffset - begin offset
     * @param endOffset - end offset, excluded
     * @param matrix
     */
    addVertexData(vertexData, beginOffset, endOffset, matrix) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      matrix || (matrix = this.matrix);
      const a = matrix.a;
      const b = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      for (let i = beginOffset; i < endOffset; i += 2) {
        const localX = vertexData[i];
        const localY = vertexData[i + 1];
        const x = a * localX + c * localY + tx;
        const y = b * localX + d * localY + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    /**
     * Checks if the point is contained within the bounds.
     * @param x - x coordinate
     * @param y - y coordinate
     */
    containsPoint(x, y) {
      if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {
        return true;
      }
      return false;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
  }

  "use strict";
  const matrixPool = createPool("MatrixPool", Matrix);
  const boundsPool = createPool("BoundsPool", Bounds);

  "use strict";
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        const parent = target.parent;
        parent.checkWorldTransform();
        parent.updateWorldTransform();
        parentTransform = parent._worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    var _a, _b;
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      if (target.addBounds) {
        bounds.matrix = worldTransform;
        target.addBounds(bounds);
      }
      for (let i = 0; i < target.children.length; i++) {
        _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i = 0; i < target.effects.length; i++) {
        (_b = (_a = target.effects[i]).addBounds) == null ? void 0 : _b.call(_a, bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }

  "use strict";
  let warnCount = 0;
  const maxWarnings = 500;
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      Logger.info("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      Logger.warn("PixiJS Warning: ", ...args);
    }
  }

  "use strict";
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    var _a, _b;
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        target.addBounds(bounds);
      }
      const children = target.children;
      for (let i = 0; i < children.length; i++) {
        _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i = 0; i < target.effects.length; i++) {
        (_b = (_a = target.effects[i]).addLocalBounds) == null ? void 0 : _b.call(_a, bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }

  "use strict";
  function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const uid = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index = previousData.index;
      if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {
        previousData.data[previousData.index] = uid;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }

  "use strict";
  const tempMatrix$4 = new Matrix();
  const measureMixin = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(value, localWidth) {
      const sign = Math.sign(this.scale.x) || 1;
      if (localWidth !== 0) {
        this.scale.x = value / localWidth * sign;
      } else {
        this.scale.x = sign;
      }
    },
    _setHeight(value, localHeight) {
      const sign = Math.sign(this.scale.y) || 1;
      if (localHeight !== 0) {
        this.scale.y = value / localHeight * sign;
      } else {
        this.scale.y = sign;
      }
    },
    /**
     * Retrieves the local bounds of the container as a Bounds object.
     * @returns - The bounding area.
     * @memberof scene.Container#
     */
    getLocalBounds() {
      if (!this._localBoundsCacheData) {
        this._localBoundsCacheData = {
          data: [],
          index: 1,
          didChange: false,
          localBounds: new Bounds()
        };
      }
      const localBoundsCacheData = this._localBoundsCacheData;
      localBoundsCacheData.index = 1;
      localBoundsCacheData.didChange = false;
      if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
        localBoundsCacheData.didChange = true;
        localBoundsCacheData.data[0] = this._didViewChangeTick;
      }
      checkChildrenDidChange(this, localBoundsCacheData);
      if (localBoundsCacheData.didChange) {
        getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix$4);
      }
      return localBoundsCacheData.localBounds;
    },
    /**
     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param bounds - Optional bounds to store the result of the bounds calculation.
     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
     * @memberof scene.Container#
     */
    getBounds(skipUpdate, bounds) {
      return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
    }
  };

  function bgr2rgb(color) {
    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);
  }
  const getGlobalMixin = {
    /**
     * Returns the global (compound) alpha of the container within the scene.
     * @param skipUpdate - Performance optimization flag:
     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy
     *   - If true: Uses cached worldAlpha from the last render pass for better performance
     * @returns The resulting alpha value (between 0 and 1)
     * @example
     * // Accurate but slower - recalculates entire alpha chain
     * const preciseAlpha = container.getGlobalAlpha();
     *
     * // Faster but may be outdated - uses cached alpha
     * const cachedAlpha = container.getGlobalAlpha(true);
     */
    getGlobalAlpha(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return this.renderGroup.worldAlpha;
        }
        if (this.parentRenderGroup) {
          return this.parentRenderGroup.worldAlpha * this.alpha;
        }
        return this.alpha;
      }
      let alpha = this.alpha;
      let current = this.parent;
      while (current !== null) {
        alpha *= current.alpha;
        current = current.parent;
      }
      return alpha;
    },

    /**
     * Returns the global transform matrix of the container within the scene.
     * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.
     * @param skipUpdate - Performance optimization flag:
     *   - If false (default): Recalculates the entire transform chain for accuracy
     *   - If true: Uses cached worldTransform from the last render pass for better performance
     * @returns The resulting transformation matrix (either the input matrix or a new one)
     * @example
     * // Accurate but slower - recalculates entire transform chain
     * const preciseTransform = container.getGlobalTransform();
     *
     * // Faster but may be outdated - uses cached transform
     * const cachedTransform = container.getGlobalTransform(undefined, true);
     *
     * // Reuse existing matrix
     * const existingMatrix = new Matrix();
     * container.getGlobalTransform(existingMatrix);
     */
    getGlobalTransform(matrix, skipUpdate) {
      if (skipUpdate) {
        this.checkWorldTransform();
        this.updateWorldTransform();
        return matrix.copyFrom(this._worldTransform);
      }
      this.updateLocalTransform();
      const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
      matrix.appendFrom(this.localTransform, parentTransform);
      matrixPool.return(parentTransform);
      return matrix;
    },

    /**
     * Returns the global (compound) tint color of the container within the scene.
     * @param skipUpdate - Performance optimization flag:
     *   - If false (default): Recalculates the entire tint chain through parents for accuracy
     *   - If true: Uses cached worldColor from the last render pass for better performance
     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)
     * @example
     * // Accurate but slower - recalculates entire tint chain
     * const preciseTint = container.getGlobalTint();
     *
     * // Faster but may be outdated - uses cached tint
     * const cachedTint = container.getGlobalTint(true);
     */
    getGlobalTint(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return bgr2rgb(this.renderGroup.worldColor);
        }
        if (this.parentRenderGroup) {
          return bgr2rgb(
            multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
          );
        }
        return this.tint;
      }
      let color = this.localColor;
      let parent = this.parent;
      while (parent) {
        color = multiplyColors(color, parent.localColor);
        parent = parent.parent;
      }
      return bgr2rgb(color);
    }
  }
  "use strict";
  const toLocalGlobalMixin = {
    /**
     * Returns the global position of the container.
     * @param point - The optional point to write the global value to.
     * @param skipUpdate - Should we skip the update transform.
     * @returns - The updated point.
     * @memberof scene.Container#
     */
    getGlobalPosition(point = new Point(), skipUpdate = false) {
      if (this.parent) {
        this.parent.toGlobal(this._position, point, skipUpdate);
      } else {
        point.x = this._position.x;
        point.y = this._position.y;
      }
      return point;
    },
    /**
     * Calculates the global position of the container.
     * @param position - The world origin to calculate from.
     * @param point - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param skipUpdate - Should we skip the update transform.
     * @returns - A point object representing the position of this object.
     * @memberof scene.Container#
     */
    toGlobal(position, point, skipUpdate = false) {
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.apply(position, point);
      matrixPool.return(globalMatrix);
      return point;
    },
    /**
     * Calculates the local position of the container relative to another point.
     * @param position - The world origin to calculate from.
     * @param from - The Container to calculate the global position from.
     * @param point - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param skipUpdate - Should we skip the update transform
     * @returns - A point object representing the position of this object
     * @memberof scene.Container#
     */
    toLocal(position, from, point, skipUpdate) {
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.applyInverse(position, point);
      matrixPool.return(globalMatrix);
      return point;
    }
  };

  "use strict";
  class InstructionSet {
    constructor() {
      /** a unique id for this instruction set used through the renderer */
      this.uid = uid$1("instructionSet");
      /** the array of instructions */
      this.instructions = [];
      /** the actual size of the array (any instructions passed this should be ignored) */
      this.instructionSize = 0;
      this.renderables = [];
    }
    /** reset the instruction set so it can be reused set size back to 0 */
    reset() {
      this.instructionSize = 0;
    }
    /**
     * Add an instruction to the set
     * @param instruction - add an instruction to the set
     */
    add(instruction) {
      const instructions = this.instructions;
      const current = instructions[this.instructionSize];
      if (current) {
        const pool = filterSetHash[current.renderPipeId];
        if (pool !== void 0) pool.return(current);
      }
      instructions[this.instructionSize++] = instruction;
    }
    /**
     * Log the instructions to the console (for debugging)
     * @internal
     * @ignore
     */
    log() {
      this.instructions.length = this.instructionSize;
      Logger.table(this.instructions, ["type", "action"]);
    }
  }

  class UpdateList {
    constructor() {
      this.list = [];
      this.index = 0;
    }
    add(child) {
      this.list[this.index++] = child;
    }
    updateTransformAndChildren(updateTick, updateFlag) {
      const list = this.list;
      const index = this.index;
      if (index === 0) return;
      for (let i = 0; i < index; i++) {
        const child = list[i];
        if (child.parentRenderGroup === null) continue;
        updateTransformAndChildren(child, updateTick, updateFlag);
      }
      this.index = 0;
    }
    updateRenderable(renderGroup) {
      const list = this.list;
      const length = this.index;
      if (length === 0) return;
      for (let i = 0; i < length; i++) {
        const child = list[i];
        if (!child.didViewUpdate) continue;
        renderGroup.updateRenderable(child);
      }
      this.index = 0;
    }
    validateRenderables(renderGroup, renderPipes) {
      const list = this.list;
      const length = this.index;
      if (length === 0) return false;
      let needRebuild = false;
      for (let i = 0; i < length; i++) {
        const child = list[i];
        const pipe = renderPipes[child.renderPipeId];
        needRebuild = pipe.validateRenderable(child);
        if (needRebuild) break;
      }
      renderGroup.structureDidChange = needRebuild;
      return needRebuild;
    }
    reset() {
      this.index = 0;
    }
  }

  class DepthUpdateList {
    constructor() {
      /**
       * @type {UpdateList[]}
       */
      this.lists = [];
    }
    add(child) {
      const depth = child.groupDepth;
      const lists = this.lists;
      let list = lists[depth];
      if (list === void 0) {
        list = lists[depth] = new UpdateList();
        this.checkListsValid(lists);
      }
      list.add(child);
    }
    /**
     * @param {UpdateList[]} lists 
     */
    checkListsValid(lists) {
      for (let i = 0; i < lists.length; i++) {
        const list = lists[i];
        if (list === void 0) lists[i] = new UpdateList();
      }
    }
    updateTransformAndChildren(updateTick, updateFlag) {
      const lists = this.lists;
      for (let i = 0; i < lists.length; i++) {
        lists[i].updateTransformAndChildren(updateTick, updateFlag);
      }
    }
    reset() {
      //nothing 
    }
  }

  "use strict";
  class RenderGroup {
    constructor() {
      this.renderPipeId = "renderGroup";
      /**
       * @type {Container}
       */
      this.root = null;
      this.canBundle = false;
      /**
       * @type {RenderGroup}
       */
      this.renderGroupParent = null;
      /**
       * @type {Matrix}
       */
      this.worldTransform = new Matrix();
      this.worldColorAlpha = 4294967295;
      this.worldColor = 16777215;
      this.worldAlpha = 1;
      this.childrenToUpdate = new DepthUpdateList();
      this.updateTick = 0;
      this.childrenRenderablesToUpdate = new UpdateList();
      this.structureDidChange = true;
      this.onRenderSize = 0;
      this.instructionSet = new InstructionSet();
      this._onRenderContainers = [];
    }
    /**
     * @param {Container} root 
     */
    init(root) {
      this.root = root;
      root.isRoot = true;
      this.addOnRender(root);
      if (root.allowChildren === false) return;
      const children = root.children;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        child._updateFlags = 0b1111;
        this.addChild(child);
      }
    }
    reset() {
      this.childrenToUpdate.reset();
      this.childrenRenderablesToUpdate.reset();
      this.root = null;
      this.updateTick = 0;
      this.structureDidChange = true;
      this._onRenderContainers.length = 0;
      this.renderGroupParent = null;
      this.onRenderSize = 0;
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addChild(child) {
      this.structureDidChange = true;
      child.parentRenderGroup = this;
      child.updateTick = -1;
      child.didChange = true;
      child.transformTick = -1;
      const parent = child.parent;
      child.groupDepth = parent === this.root ? 1 : parent.groupDepth + 1;
      this.onChildUpdate(child);
      if (child._enableUpdate) this.addOnRender(child);
      if (!child.allowChildren) return;
      const children = child.children;
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    }
    replaceChild(replacer, target) {
      this.structureDidChange = true;
      replacer.parentRenderGroup = this;
      replacer.didChange = true;
      replacer.updateTick = -1;
      replacer.transformTick = -1;
      replacer.groupDepth = target.groupDepth;
      this.onChildUpdate(replacer);
      target.parentRenderGroup = null;
      if (target._enableUpdate) this.removeOnRender(target);
      if (target.allowChildren) {
        const children = target.children;
        for (let i = 0; i < children.length; i++) {
          this.removeChild(children[i]);
        }
      }
      if (replacer._enableUpdate) this.addOnRender(replacer);
      if (!replacer.allowChildren) return;
      const children = replacer.children;
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    }
    removeChild(child) {
      this.structureDidChange = true;
      if (child.renderGroup === null) {
        this.removeOnRender(child);
      }
      child.parentRenderGroup = null;
      if (!child.allowChildren) return;
      const children = child.children;
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    }
    removeChildren(children) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    }
    onChildUpdate(child) {
      this.childrenToUpdate.add(child)
    }
    updateRenderable(renderable) {
      if (renderable.globalDisplayStatus < 7) return;
      this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
      renderable.didViewUpdate = false;
    }
    onChildViewUpdate(child) {
      this.childrenRenderablesToUpdate.add(child);
    }
    validateGroupRenderables(renderPipes) {
      this.childrenRenderablesToUpdate.validateRenderables(this, renderPipes);
    }
    updateGroupRenderables() {
      this.childrenRenderablesToUpdate.updateRenderable(this);
    }
    updateGroupTransforms() {
      this.childrenToUpdate.updateTransformAndChildren(this.updateTick++, 0);
    }
    onPostRenderer() {
      this.childrenRenderablesToUpdate.index = 0;
    }
    isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    /**
     * adding a container to the onRender list will make sure the user function
     * passed in to the user defined 'onRender` callBack
     * @param container - the container to add to the onRender list
     */
    addOnRender(container) {
      this._onRenderContainers[this.onRenderSize++] = container;
    }
    removeOnRender(container) {
      if (this._onRenderContainers.remove(container)) this.onRenderSize--;
    }
    runOnRender() {
      const containers = this._onRenderContainers;
      for (let i = 0; i < this.onRenderSize; i++) {
        const container = containers[i];
        if (container === void 0) continue;
        container.update();
      }
    }
    destroy() {
      this.renderGroupParent = null;
      this.root = null;
      this.childrenRenderablesToUpdate = null;
      this.childrenToUpdate = null;
      this._onRenderContainers = null;
      this.instructionSet = null;
    }
  }
  const RenderGroupPool = createPool("RenderGroupPool", RenderGroup);

  "use strict";
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }

  "use strict";
  const defaultSkew = new ObservablePoint(null);
  const defaultPivot = new ObservablePoint(null);
  const defaultScale = new ObservablePoint(null, 1, 1);
  const UPDATE_COLOR = 1;
  const UPDATE_BLEND = 2;
  const UPDATE_VISIBLE = 4;
  const UPDATE_TRANSFORM = 8;
  class Container extends EventEmitter {
    constructor() {
      super();
      this.uid = uid$1("renderable");
      /** @private */
      this._updateFlags = 15;
      this._visible = true;
      // the render group this container owns
      /**
       * @type {RenderGroup | null}
       */
      this.renderGroup = null;
      // the render group this container belongs to
      /** @private */
      this.hitArea = null;
      this._worldTransform = null;
      /**
       * @type {RenderGroup | null}
       */
      this.parentRenderGroup = null;
      this.parentRenderGroupIndex = 0;
      this._width = 0;
      this._height = 0;
      this._filterArea = null;
      this.didChange = false;
      this._opacity = -1;
      this.transformTick = -1;
      // same as above, but for the renderable
      /** @private */
      this.didViewUpdate = false;
      /** The display object container that contains this display object. */
      this.parent = null;
      // used internally for changing up the render order.. mainly for masks and filters
      // TODO setting this should cause a rebuild??
      /** @private */
      this.includeInBuild = true;
      /** @private */
      this.measurable = true;
      /** @private */
      this.isSimple = true;
      this.updateTick = -1;
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      this.localTransform = new Matrix();
      /**
       * The relative group transform is a transform relative to the render group it belongs too. It will include all parent
       * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).
       * If this container is is self a render group matrix will be relative to its parent render group
       * @readonly
       */
      this.relativeGroupTransform = new Matrix();
      /**
       * The group transform is a transform relative to the render group it belongs too.
       * If this container is render group then this will be an identity matrix. other wise it
       * will be the same as the relativeGroupTransform.
       * Use this value when actually rendering things to the screen
       * @readonly
       */
      this.groupTransform = this.relativeGroupTransform;
      /** If the object has been destroyed via destroy(). If true, it should not be used. */
      this.destroyed = false;
      // transform data..
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @internal
       * @ignore
       */
      this._position = new ObservablePoint(this, 0, 0);
      /**
       * The scale factor of the object.
       * @internal
       * @ignore
       */
      this._scale = defaultScale;
      /**
       * The pivot point of the container that it rotates around.
       * @internal
       * @ignore
       */
      this._pivot = defaultPivot;
      /**
       * The skew amount, on the x and y axis.
       * @internal
       * @ignore
       */
      this._skew = defaultSkew;
      /**
       * The X-coordinate value of the normalized local X axis,
       * the first column of the local transformation matrix without a scale.
       * @internal
       * @ignore
       */
      this._cx = 1;
      /**
       * The Y-coordinate value of the normalized local X axis,
       * the first column of the local transformation matrix without a scale.
       * @internal
       * @ignore
       */
      this._sx = 0;
      /**
       * The X-coordinate value of the normalized local Y axis,
       * the second column of the local transformation matrix without a scale.
       * @internal
       * @ignore
       */
      this._cy = 0;
      this._sy = 1;
      this._rotation = 0;
      this.groupDepth = 0;
      // / COLOR related props //////////////
      // color stored as ABGR
      this.localColor = 16777215;
      this.localAlpha = 1;
      this.groupAlpha = 1;
      this.groupColor = 16777215;
      this.groupColorAlpha = 4294967295;
      this.localBlendMode = "inherit";
      /**
       * @internal
       * @ignore
       */
      this.groupBlendMode = "normal";
      this.localDisplayStatus = 7;
      this.globalDisplayStatus = 7;
      this._didViewChangeTick = 0;
      this.needUpdateLocalTransform = false;
      this.effects = [];
      this._enableUpdate = false;
      this.isRoot = false;
      this.createChildren();
    }
    get opacity() {
      return this._opacity;
    }
    set opacity(value) {
      if (this._opacity !== value) {
        this._opacity = value;
        this.alpha = value.clamp(0, 255) / 255;
      }
    }
    // / ////// transform related stuff
    /**
     * The position of the container on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     */
    get x() {
      return this._position.x;
    }
    set x(value) {
      this._position.x = value;
    }
    /**
     * The position of the container on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     */
    get y() {
      return this._position.y;
    }
    set y(value) {
      this._position.y = value;
    }
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * @since 4.0.0
     */
    get position() {
      return this._position;
    }
    set position(value) {
      this._position.copyFrom(value);
    }
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     */
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this._skew);
      }
    }
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     */
    get angle() {
      return this.rotation * RAD_TO_DEG;
    }
    set angle(value) {
      this.rotation = value * DEG_TO_RAD;
    }
    /**
     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
     * is the projection of `pivot` in the parent's local space.
     *
     * By default, the pivot is the origin (0, 0).
     * @since 4.0.0
     */
    get pivot() {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
      }
      return this._pivot;
    }
    set pivot(value) {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
      }
      typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
    }
    /**
     * The skew factor for the object in radians.
     * @since 4.0.0
     */
    get skew() {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      return this._skew;
    }
    set skew(value) {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      this._skew.copyFrom(value);
    }
    /**
     * The scale factors of this object along the local coordinate axes.
     *
     * The default scale is (1, 1).
     * @since 4.0.0
     */
    get scale() {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 1, 1);
      }
      return this._scale;
    }
    set scale(value) {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 0, 0);
      }
      typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
    }
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set.
     * @memberof scene.Container#
     */
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(value) {
      const localWidth = this.getLocalBounds().width;
      this._setWidth(value, localWidth);
    }
    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set.
     * @memberof scene.Container#
     */
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(value) {
      const localHeight = this.getLocalBounds().height;
      this._setHeight(value, localHeight);
    }
    checkWorldTransform() {
      if (this._worldTransform === null) {
        this._worldTransform = new Matrix();
      }
    }
    updateWorldTransform() {
      if (this.transformTick === Engine.renderCount) return;
      this.transformTick = Engine.renderCount;
      if (this.renderGroup !== null) {
        this._worldTransform.copyFrom(this.renderGroup.worldTransform);
      } else {
        this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
      }
    }
    createChildren() {
      this.children = [];
    }
    enableUpdate() {
      if (this._enableUpdate) return;
      this._enableUpdate = true;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) renderGroup.addOnRender(this);
    }
    disableUpdate() {
      if (!this._enableUpdate) return;
      this._enableUpdate = false;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) renderGroup.removeOnRender(this);
    }
    update() {

    }
    move(x, y) {
      this._position.set(x, y);
    }
    /**
     * Mixes all enumerable properties and methods from a source object to Container.
     * @param source - The source of properties and methods to mix in.
     */
    static mixin(source) {
      Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));
    }
    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     * @param {...Container} children - The Container(s) to add to the container
     * @returns {Container} - The first child that was added.
     */
    addChild(...children) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        return;
      }
      if (children.length > 1) {
        for (let i = 0; i < children.length; i++) {
          this.addChild(children[i]);
        }
        return children[0];
      }
      const child = children[0];
      if (child.parent === this) {
        return child;
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      this.children[this.children.length] = child;
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      this._didViewChangeTick++;
      return child;
    }
    /**
     * Removes one or more children from the container.
     * @param {...Container} children - The Container(s) to remove
     * @returns {Container} The first child that was removed.
     */
    removeChild(...children) {
      if (children.length > 1) {
        for (let i = 0; i < children.length; i++) {
          this.removeChild(children[i]);
        }
        return children[0];
      }
      const child = children[0];
      if (this.children.remove(child)) {
        this._didViewChangeTick++;
        if (this.renderGroup) {
          this.renderGroup.removeChild(child);
        } else if (this.parentRenderGroup) {
          this.parentRenderGroup.removeChild(child);
        }
        child.parent = null;
      }
      return child;
    }
    removeAllChildren() {
      const children = this.children;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        renderGroup.removeChild(child);
        child.parent = null;
        this._didViewChangeTick++;
      }
      this.children.length = 0;
    }
    /**
     * Calling this enables a render group for this container.
     * This means it will be rendered as a separate set of instructions.
     * The transform of the container will also be handled on the GPU rather than the CPU.
     */
    enableRenderGroup() {
      if (this.renderGroup) return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
      this.renderGroup = RenderGroupPool.get(this);
      this.groupTransform = Matrix.IDENTITY;
      parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
      this._updateIsSimple();
    }
    /** This will disable the render group for this container. */
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
      RenderGroupPool.return(this.renderGroup);
      this.renderGroup = null;
      this.groupTransform = this.relativeGroupTransform;
      parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
      this._updateIsSimple();
    }
    /** @ignore */
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    /** Called when the skew or the rotation changes. */
    _updateSkew() {
      const rotation = this._rotation;
      const skew = this._skew;
      const sx = skew._x;
      const sy = skew._y;
      this._cx = Math.cos(rotation + sy);
      this._sx = Math.sin(rotation + sy);
      this._cy = -Math.sin(rotation - sx);
      this._sy = Math.cos(rotation - sx);
    }
    /**
     * Updates the local transform using the given matrix.
     * @param {Matrix} matrix - The matrix to use for updating the transform.
     */
    setFromMatrix(matrix) {
      matrix.decompose(this);
    }
    /** Updates the local transform. */
    updateLocalTransform() {
      if (!this.needUpdateLocalTransform) return;
      this.needUpdateLocalTransform = false;
      const lt = this.localTransform;
      const scale = this._scale;
      const pivot = this._pivot;
      const position = this._position;
      const sx = scale._x;
      const sy = scale._y;
      const px = pivot._x;
      const py = pivot._y;
      lt.a = this._cx * sx;
      lt.b = this._sx * sx;
      lt.c = this._cy * sy;
      lt.d = this._sy * sy;
      lt.tx = position._x - (px * lt.a + py * lt.c);
      lt.ty = position._y - (px * lt.b + py * lt.d);
    }
    // / ///// color related stuff
    set alpha(value) {
      if (value === this.localAlpha) return;
      this.localAlpha = value;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdateRenderable();
    }
    /** The opacity of the object. */
    get alpha() {
      return this.localAlpha;
    }
    set tint(value) {
      const bgr = Color.shared.setValue(value).toBgrNumber();
      if (bgr === this.localColor) return;
      this.localColor = bgr;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdateRenderable();
    }
    /**
     * The tint applied to the sprite. This is a hex value.
     *
     * A value of 0xFFFFFF will remove any tint effect.
     * @default 0xFFFFFF
     */
    get tint() {
      return bgr2rgb(this.localColor);
    }
    // / //////////////// blend related stuff
    set blendMode(value) {
      if (this.localBlendMode === value)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_BLEND;
      this.localBlendMode = value;
      this._onUpdateRenderable();
    }
    /**
     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
     * @default 'normal'
     */
    get blendMode() {
      return this.localBlendMode;
    }
    // / ///////// VISIBILITY / RENDERABLE /////////////////
    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
    get visible() {
      return this._visible;
    }
    set visible(value) {
      if (this._visible === value) return;
      this._visible = value;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 2;
      this._onUpdateRenderable();
    }
    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
    get renderable() {
      Logger.warn("");
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(value) {
      const valueNumber = value ? 1 : 0;
      if ((this.localDisplayStatus & 1) === valueNumber)
        return;
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 1;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._onUpdateRenderable();
    }
    /**
     * 
     * @param {ObservablePoint} point 
     * @returns 
     */
    _onUpdate(point) {
      if (point === this._skew) this._updateSkew();
      this.needUpdateLocalTransform = true;
      this._onUpdateRenderable();
    }
    _onUpdateRenderable() {
      if (this.didChange) return;
      this.didChange = true;
      if (this.parentRenderGroup !== null) {
        this.parentRenderGroup.onChildUpdate(this);
      }
    }
    /** Whether or not the object should be rendered. */
    get isRenderable() {
      //console.warn("");
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
     * is set to true it should destroy the texture of the child sprite
     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
     * If options.children is set to true it should destroy the texture source of the child sprite
     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
     * If options.children is set to true it should destroy the context of the child graphics
     */
    destroy(options = Zaun.Core.CoreUtils.DESTROY_OPTIONS) {
      if (this.destroyed) return;
      this.destroyed = true;
      this.removeFromParent();
      this.parent = null;
      this._maskEffect = null;
      this._filterEffect = null;
      this.effects = null;
      this._position = null;
      this._scale = null;
      this._pivot = null;
      this._skew = null;
      this.emit("destroyed", this);
      this.removeAllListeners();
      const destroyChildren = typeof options === "boolean" ? options : options == null ? void 0 : options.children;
      if (destroyChildren && this.allowChildren) {
        const oldChildren = this.children;
        const length = oldChildren.length;
        for (let i = 0; i < length; ++i) {
          const child = oldChildren[i];
          this.removeChild(child);
          child.destroy(options);
        }
      }
      this.disableRenderGroup();
      this.renderGroup = null;
      Zaun.FilterSystem.FilterManager.clearFilters(this);
    }
    reset() {
      this.disableUpdate();
      if (this.parent) this.parent.removeChild(this);
      this._position.set(0, 0);
      this._scale.set(1, 1);
      this._pivot.set(0, 0);
      this._skew.set(0, 0);
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this.groupDepth = 0;
      this.needUpdateLocalTransform = true;
      this.transformTick = -1;
      this.didViewUpdate = true;
      this._rotation = 0;
      this.updateTick = -1;
      this._didViewChangeTick = 0;
      this.localColor = 16777215;
      this.localAlpha = 1;
      this.groupAlpha = 1;
      this.groupColor = 16777215;
      this.groupColorAlpha = 4294967295;
      this.localBlendMode = "inherit";
      this.groupBlendMode = "normal";
      this.localDisplayStatus = 7;
      this.globalDisplayStatus = 7;
      this._updateFlags = 15;
      this._visible = true;
      this._opacity = -1;
    }
  }
  Container.mixin(childrenHelperMixin);
  Container.mixin(toLocalGlobalMixin);
  Container.mixin(getGlobalMixin);
  Container.mixin(measureMixin);
  Container.mixin(effectsMixin);
  Container.mixin(collectRenderablesMixin);
  Container.mixin(getFastGlobalBoundsMixin);

  var appleIphone = /iPhone/i;
  var appleIpod = /iPod/i;
  var appleTablet = /iPad/i;
  var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet = /Android/i;
  var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet = /Silk/i;
  var windowsPhone = /Windows Phone/i;
  var windowsTablet = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry = /BlackBerry/i;
  var otherBlackBerry10 = /BB10/i;
  var otherOpera = /Opera Mini/i;
  var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
      navigator.platform === 'MacIntel' &&
      typeof navigator.maxTouchPoints === 'number' &&
      navigator.maxTouchPoints > 1 &&
      typeof MSStream === 'undefined');
  };
  function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
  }
  function isMobile$1(param) {
    var nav = {
      userAgent: '',
      platform: '',
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    }
    else if (typeof param === 'string') {
      nav.userAgent = param;
    }
    else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
      userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) &&
          (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
          !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) ||
          match(appleIpod) ||
          match(appleTablet) ||
          match(appleUniversal) ||
          isAppleTabletOnIos13(nav)) &&
          !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: (!match(windowsPhone) && match(amazonPhone)) ||
          (!match(windowsPhone) && match(androidPhone)),
        tablet: !match(windowsPhone) &&
          !match(amazonPhone) &&
          !match(androidPhone) &&
          (match(amazonTablet) || match(androidTablet)),
        device: (!match(windowsPhone) &&
          (match(amazonPhone) ||
            match(amazonTablet) ||
            match(androidPhone) ||
            match(androidTablet))) ||
          match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) ||
          match(otherBlackBerry10) ||
          match(otherOpera) ||
          match(otherFirefox) ||
          match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any =
      result.apple.device ||
      result.android.device ||
      result.windows.device ||
      result.other.device;
    result.phone =
      result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
      result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }

  "use strict";
  var _a;
  const isMobileCall = (_a = isMobile$1.default) != null ? _a : isMobile$1;
  const isMobile = isMobileCall(globalThis.navigator);

  "use strict";
  const BrowserAdapter = {
    createCanvas: (width, height) => {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => {
      var _a;
      return (_a = document.baseURI) != null ? _a : window.location.href;
    },
    getFontFaceSet: () => document.fonts,
    fetch: (url, options) => fetch(url, options),
    parseXML: (xml) => {
      const parser = new DOMParser();
      return parser.parseFromString(xml, "text/xml");
    }
  };

  "use strict";
  let currentAdapter = BrowserAdapter;
  const DOMAdapter = {
    /**
     * Returns the current adapter.
     * @returns {environment.Adapter} The current adapter.
     */
    get() {
      return currentAdapter;
    },
    /**
     * Sets the current adapter.
     * @param adapter - The new adapter.
     */
    set(adapter) {
      currentAdapter = adapter;
    }
  };

  "use strict";
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i = 0; i <= path2.length; ++i) {
      if (i < path2.length) {
        code = path2.charCodeAt(i);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i)}`;
          } else {
            res = path2.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  const path = {
    /**
     * Converts a path to posix format.
     * @param path - The path to convert to posix
     */
    toPosix(path2) {
      return replaceAll(path2, "\\", "/");
    },
    /**
     * Checks if the path is a URL e.g. http://, https://
     * @param path - The path to check
     */
    isUrl(path2) {
      return /^https?:/.test(this.toPosix(path2));
    },
    /**
     * Checks if the path is a data URL
     * @param path - The path to check
     */
    isDataUrl(path2) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    /**
     * Checks if the path is a blob URL
     * @param path - The path to check
     */
    isBlobUrl(path2) {
      return path2.startsWith("blob:");
    },
    /**
     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
     * This will return true for windows file paths
     * @param path - The path to check
     */
    hasProtocol(path2) {
      return /^[^/:]+:/.test(this.toPosix(path2));
    },
    /**
     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
     * @param path - The path to get the protocol from
     */
    getProtocol(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      const matchFile = /^file:\/\/\//.exec(path2);
      if (matchFile) {
        return matchFile[0];
      }
      const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
      if (matchProtocol) {
        return matchProtocol[0];
      }
      return "";
    },
    /**
     * Converts URL to an absolute path.
     * When loading from a Web Worker, we must use absolute paths.
     * If the URL is already absolute we return it as is
     * If it's not, we convert it
     * @param url - The URL to test
     * @param customBaseUrl - The base URL to use
     * @param customRootUrl - The root URL to use
     */
    toAbsolute(url, customBaseUrl, customRootUrl) {
      assertPath(url);
      if (this.isDataUrl(url) || this.isBlobUrl(url))
        return url;
      const baseUrl = removeUrlParams(this.toPosix(customBaseUrl != null ? customBaseUrl : DOMAdapter.get().getBaseUrl()));
      const rootUrl = removeUrlParams(this.toPosix(customRootUrl != null ? customRootUrl : this.rootname(baseUrl)));
      url = this.toPosix(url);
      if (url.startsWith("/")) {
        return path.join(rootUrl, url.slice(1));
      }
      const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
      return absolutePath;
    },
    /**
     * Normalizes the given path, resolving '..' and '.' segments
     * @param path - The path to normalize
     */
    normalize(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      if (this.isDataUrl(path2) || this.isBlobUrl(path2))
        return path2;
      path2 = this.toPosix(path2);
      let protocol = "";
      const isAbsolute = path2.startsWith("/");
      if (this.hasProtocol(path2)) {
        protocol = this.rootname(path2);
        path2 = path2.slice(protocol.length);
      }
      const trailingSeparator = path2.endsWith("/");
      path2 = normalizeStringPosix(path2, false);
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return `/${path2}`;
      return protocol + path2;
    },
    /**
     * Determines if path is an absolute path.
     * Absolute paths can be urls, data urls, or paths on disk
     * @param path - The path to test
     */
    isAbsolute(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      if (this.hasProtocol(path2))
        return true;
      return path2.startsWith("/");
    },
    /**
     * Joins all given path segments together using the platform-specific separator as a delimiter,
     * then normalizes the resulting path
     * @param segments - The segments of the path to join
     */
    join(...segments) {
      var _a;
      if (segments.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < segments.length; ++i) {
        const arg = segments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else {
            const prevArg = (_a = segments[i - 1]) != null ? _a : "";
            if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
              joined += `/../${arg}`;
            } else {
              joined += `/${arg}`;
            }
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return this.normalize(joined);
    },
    /**
     * Returns the directory name of a path
     * @param path - The path to parse
     */
    dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const hasRoot = code === 47;
      let end = -1;
      let matchedSlash = true;
      const proto = this.getProtocol(path2);
      const origpath = path2;
      path2 = path2.slice(proto.length);
      for (let i = path2.length - 1; i >= 1; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
      if (hasRoot && end === 1)
        return "//";
      return proto + path2.slice(0, end);
    },
    /**
     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
     * @param path - The path to parse
     */
    rootname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let root = "";
      if (path2.startsWith("/"))
        root = "/";
      else {
        root = this.getProtocol(path2);
      }
      if (this.isUrl(path2)) {
        const index = path2.indexOf("/", root.length);
        if (index !== -1) {
          root = path2.slice(0, index);
        } else
          root = path2;
        if (!root.endsWith("/"))
          root += "/";
      }
      return root;
    },
    /**
     * Returns the last portion of a path
     * @param path - The path to test
     * @param ext - Optional extension to remove
     */
    basename(path2, ext) {
      assertPath(path2);
      if (ext)
        assertPath(ext);
      path2 = removeUrlParams(this.toPosix(path2));
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          const code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      }
      for (i = path2.length - 1; i >= 0; --i) {
        if (path2.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start, end);
    },
    /**
     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
     * the first character of the basename of path, an empty string is returned.
     * @param path - The path to parse
     */
    extname(path2) {
      assertPath(path2);
      path2 = removeUrlParams(this.toPosix(path2));
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    /**
     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
     * @param path - The path to parse
     */
    parse(path2) {
      assertPath(path2);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      path2 = removeUrlParams(this.toPosix(path2));
      let code = path2.charCodeAt(0);
      const isAbsolute = this.isAbsolute(path2);
      let start;
      const protocol = "";
      ret.root = this.rootname(path2);
      if (isAbsolute || this.hasProtocol(path2)) {
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path2.length - 1;
      let preDotState = 0;
      for (; i >= start; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      ret.dir = this.dirname(path2);
      if (protocol)
        ret.dir = protocol + ret.dir;
      return ret;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
  };

  "use strict";
  const convertToList = (input, transform, forceTransform = false) => {
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!transform) {
      return input;
    }
    return input.map((item) => {
      if (typeof item === "string" || forceTransform) {
        return transform(item);
      }
      return item;
    });
  };

  "use strict";
  const copySearchParams = (targetUrl, sourceUrl) => {
    const searchParams = sourceUrl.split("?")[1];
    if (searchParams) {
      targetUrl += `?${searchParams}`;
    }
    return targetUrl;
  };

  "use strict";
  const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  const rotationCayley = [];
  const rotationMatrices = [];
  const signum = Math.sign;
  function init() {
    for (let i = 0; i < 16; i++) {
      const row = [];
      rotationCayley.push(row);
      for (let j = 0; j < 16; j++) {
        const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
        const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
        const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
        const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
        for (let k = 0; k < 16; k++) {
          if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (let i = 0; i < 16; i++) {
      const mat = new Matrix();
      mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  init();
  const groupD8 = {
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0       | East      |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    E: 0,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45     | Southeast |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    SE: 1,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90     | South     |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    S: 2,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135    | Southwest |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    SW: 3,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180     | West      |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    W: 4,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135/225 | Northwest    |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    NW: 5,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90/270  | North        |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    N: 6,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45/315  | Northeast    |
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    NE: 7,
    /**
     * Reflection about Y-axis.
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    MIRROR_VERTICAL: 8,
    /**
     * Reflection about the main diagonal.
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    MAIN_DIAGONAL: 10,
    /**
     * Reflection about X-axis.
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    MIRROR_HORIZONTAL: 12,
    /**
     * Reflection about reverse diagonal.
     * @memberof maths.groupD8
     * @constant {GD8Symmetry}
     */
    REVERSE_DIAGONAL: 14,
    /**
     * @memberof maths.groupD8
     * @param {GD8Symmetry} ind - sprite rotation angle.
     * @returns {GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */
    uX: (ind) => ux[ind],
    /**
     * @memberof maths.groupD8
     * @param {GD8Symmetry} ind - sprite rotation angle.
     * @returns {GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */
    uY: (ind) => uy[ind],
    /**
     * @memberof maths.groupD8
     * @param {GD8Symmetry} ind - sprite rotation angle.
     * @returns {GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */
    vX: (ind) => vx[ind],
    /**
     * @memberof maths.groupD8
     * @param {GD8Symmetry} ind - sprite rotation angle.
     * @returns {GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */
    vY: (ind) => vy[ind],
    /**
     * @memberof maths.groupD8
     * @param {GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @returns {GD8Symmetry} The opposite symmetry of `rotation`
     */
    inv: (rotation) => {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    /**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof maths.groupD8
     * @param {GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @returns {GD8Symmetry} Composed operation
     */
    add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
    /**
     * Reverse of `add`.
     * @memberof maths.groupD8
     * @param {GD8Symmetry} rotationSecond - Second operation
     * @param {GD8Symmetry} rotationFirst - First operation
     * @returns {GD8Symmetry} Result
     */
    sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    /**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     * @memberof maths.groupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */
    rotate180: (rotation) => rotation ^ 4,
    /**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     * @memberof maths.groupD8
     * @param {GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */
    isVertical: (rotation) => (rotation & 3) === 2,
    // rotation % 4 === 2
    /**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `groupD8`.
     * @memberof maths.groupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @returns {GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */
    byDirection: (dx, dy) => {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    /**
     * Helps sprite to compensate texture packer rotation.
     * @memberof maths.groupD8
     * @param {Matrix} matrix - sprite world matrix
     * @param {GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
      const mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    }
  };

  "use strict";
  function nextPow2(v) {
    v += v === 0 ? 1 : 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
  }
  function isPow2(v) {
    return !(v & v - 1) && v > 0;
  }
  function log2(v) {
    let r = (v > 65535 ? 1 : 0) << 4;
    v >>>= r;
    let shift = (v > 255 ? 1 : 0) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15 ? 1 : 0) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3 ? 1 : 0) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
  }

  "use strict";
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }

  "use strict";
  const idHash$1 = /* @__PURE__ */ Object.create(null);
  function createResourceIdFromString(value) {
    const id = idHash$1[value];
    if (id === void 0) {
      idHash$1[value] = uid$1("resource");
    }
    return id;
  }
  class TextureStyle extends EventEmitter {
    /**
     * @param options - options for the style
     */
    constructor() {
      super();
      const isWebgpu = globalThis.Engine ? Engine.isWebgpu() : false;
      this._resourceType = "textureSampler";
      /**
       * Specifies the maximum anisotropy value clamp used by the sampler.
       * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range
       * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will
       * be clamped to the maximum value that the platform supports.
       * @internal
       * @ignore
       */
      if (isWebgpu) this._resourceId = uid$1("resource");
      this._maxAnisotropy = 1;
      /**
       * Has the style been destroyed?
       * @readonly
       */
      this.isTextureStyle = true;
      this.destroyed = false;
      this.gpuSampler = null;
      this.reseted = false;
    }
    setupOptions(options = TextureStyle.defaultOptions) {
      const addressMode = options.addressMode || TextureStyle.defaultOptions.addressMode;
      const scaleMode = options.scaleMode || TextureStyle.defaultOptions.scaleMode;
      this.addressMode = addressMode;
      this.scaleMode = scaleMode;
      this.lodMinClamp = options.lodMinClamp;
      this.lodMaxClamp = options.lodMaxClamp;
      this.compare = options.compare;
      if (options.maxAnisotropy) {
        this.maxAnisotropy = options.maxAnisotropy;
      }
      const isWebgpu = globalThis.Engine ? Engine.isWebgpu() : false;
      if (!isWebgpu) this._generateResourceId();
      this.reseted = false;
    }
    initGpuSampler() {
      if (this.gpuSampler === null) {
        Engine.renderer.texture._initSampler(this);
      }
      return this.gpuSampler;
    }
    set addressMode(value) {
      if (value !== this.addressModeU) {
        this.gpuSampler = null;
      }
      this.addressModeU = value;
      this.addressModeV = value;
      this.addressModeW = value;
    }
    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
    get addressMode() {
      return this.addressModeU;
    }
    set scaleMode(value) {
      if (value !== this.magFilter) {
        this.gpuSampler = null;
      }
      this.magFilter = value;
      this.minFilter = value;
      this.mipmapFilter = value;
    }
    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
    get scaleMode() {
      return this.magFilter;
    }
    /** Specifies the maximum anisotropy value clamp used by the sampler. */
    set maxAnisotropy(value) {
      if (value !== this._maxAnisotropy) this.gpuSampler = null;
      this._maxAnisotropy = Math.min(value, 16);
      if (this._maxAnisotropy > 1) {
        this.scaleMode = "linear";
      }
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    update() {
      this.emit("change", this);
    }
    _generateResourceId() {
      const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      const id = this._resourceId = createResourceIdFromString(bigKey);
      return id;
    }
    /** Destroys the style */
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this.removeAllListeners();
    }
    reset() {
      if (this.reseted) return;
      this.reseted = true;
      this.emit("change", this);
      this.emit("destroy", this);
      this.removeAllListeners();
    }
  };
  /** default options for the style */
  TextureStyle.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  TextureStyle.EMPTY = new TextureStyle();
  TextureStyle.EMPTY.setupOptions(TextureStyle.defaultOptions);
  TextureStyle.EMPTY.on = Function.empty;
  TextureStyle.EMPTY.off = Function.empty;
  TextureStyle.EMPTY.addListener = Function.empty;
  TextureStyle.EMPTY.removeListener = Function.empty;
  TextureStyle.EMPTY.removeAllListeners = Function.empty;
  TextureStyle.EMPTY.destroy = Function.empty;
  TextureStyle.EMPTY.reset = Function.empty;
  TextureStyle.EMPTY.label = "empty";

  "use strict";
  class TextureSource extends EventEmitter {
    /**
     * @param options - options for creating a new TextureSource
     */
    constructor() {
      super();
      /** unique id for this Texture source */
      this.uid = uid$1("textureSource");
      /**
       * The resource type used by this TextureSource. This is used by the bind groups to determine
       * how to handle this resource.
       * @ignore
       * @internal
       */
      this._resourceType = "textureSource";
      /**
       * i unique resource id, used by the bind group systems.
       * This can change if the texture is resized or its resource changes
       */
      this._resourceId = uid$1("resource");
      /**
       * this is how the backends know how to upload this texture to the GPU
       * It changes depending on the resource type. Classes that extend TextureSource
       * should override this property.
       * @ignore
       * @internal
       */
      this.initBaseProperties();
      /**
       * @type {TextureStyle}
       */
      this._style = TextureStyle.EMPTY;
      this.destroyed = false;
      this.renderTarget = null;
      this.textureBuffers = [];
      this.gpuTextureView = null;
    }
    setupOptions(options = TextureSource.defaultOptions) {
      if (this._style === TextureStyle.EMPTY) {
        this._style = options.style || new TextureStyle();
      }
      this._style.setupOptions(options);
      this.resource = options.resource || null;
      this._resolution = options.resolution || 1;
      if (options.width) {
        this.pixelWidth = options.width * this._resolution;
      } else {
        this.pixelWidth = this.resource ? this.resource.width : 1;
      }
      if (options.height) {
        this.pixelHeight = options.height * this._resolution;
      } else {
        this.pixelHeight = this.resource ? this.resource.height : 1;
      }
      if (this.renderTarget !== null) {
        this.renderTarget.colorTextures[0] = this;
      }
      const defaultOptions = TextureSource.defaultOptions;
      this.width = this.pixelWidth / this._resolution;
      this.height = this.pixelHeight / this._resolution;
      this.format = options.format || defaultOptions.format;
      this.dimension = options.dimensions || defaultOptions.dimensions;
      this.mipLevelCount = options.mipLevelCount || defaultOptions.mipLevelCount;
      this.autoGenerateMipmaps = options.autoGenerateMipmaps || defaultOptions.autoGenerateMipmaps;
      this.sampleCount = options.sampleCount || defaultOptions.sampleCount;
      this.antialias = options.antialias || defaultOptions.antialias;
      this.alphaMode = options.alphaMode || defaultOptions.alphaMode;
      this._refreshPOT();
      return this;
    }
    initBaseProperties() {
      this.resource = null;
      this.hasGpuTexture = false;
      this.reseted = false;
      this.gpuTexture = null;
      this.hasListeneredGpuTexture = false;
      this.isTextureSource = true;
      this.uploadMethodId = "unknown";
      // dimensions
      this._resolution = 1;
      /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */
      this.pixelWidth = 1;
      /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */
      this.pixelHeight = 1;
      /**
       * the width of this texture source, accounting for resolution
       * eg pixelWidth 200, resolution 2, then width will be 100
       */
      this.width = 1;
      /**
       * the height of this texture source, accounting for resolution
       * eg pixelHeight 200, resolution 2, then height will be 100
       */
      this.height = 1;
      /**
       * The number of samples of a multisample texture. This is always 1 for non-multisample textures.
       * To enable multisample for a texture, set antialias to true
       * @internal
       * @ignore
       */
      this.sampleCount = 1;
      /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */
      this.mipLevelCount = 1;
      /**
       * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps
       * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but
       * can look better when scaled down.
       *
       * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.
       * If you do, make sure to call `updateMipmaps` after you update the texture.
       */
      this.autoGenerateMipmaps = false;
      /** the format that the texture data has */
      this.format = "bgra8unorm";
      /** how many dimensions does this texture have? currently v8 only supports 2d */
      this.dimension = "2d";
      /**
       * Only really affects RenderTextures.
       * Should we use antialiasing for this texture. It will look better, but may impact performance as a
       * Blit operation will be required to resolve the texture.
       */
      this.antialias = false;
      /**
       * A temporary batch location for the texture batching. Here for performance reasons only!
       * @protected
       */
      this._textureBindLocation = -1;
    }
    /** returns itself */
    get source() {
      Logger.warn("");
      return this;
    }
    /** the style of the texture */
    get style() {
      return this._style;
    }
    set style(value = null) {
      if (this._style === value || value === null) return;
      if (this._style) this._style.off("change", this._onStyleChange, this);
      this._style = value;
      if (value) value.on("change", this._onStyleChange, this);
      this._onStyleChange();
    }
    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(value) {
      this._style.addressMode = value;
    }
    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(value) {
      this._style.addressMode = value;
    }
    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(value) {
      this._style.magFilter = value;
    }
    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(value) {
      this._style.minFilter = value;
    }
    /** Specifies behavior for sampling between mipmap levels. */
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(value) {
      this._style.mipmapFilter = value;
    }
    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(value) {
      this._style.lodMinClamp = value;
    }
    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(value) {
      this._style.lodMaxClamp = value;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    /** call this if you have modified the texture outside of the constructor */
    update() {
      if (this.resource !== null) {
        const resolution = this._resolution;
        const didResize = this.resize(this.width / resolution, this.height / resolution);
        if (didResize) return;
      }
      this.emit("update", this);
    }
    /** Destroys this texture source */
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      if (this._style) {
        this._style.destroy();
        this._style = null;
      }
      this.uploadMethodId = null;
      this.resource = null;
      this.removeAllListeners();
    }
    reset() {
      if (this.reseted) return;
      this.reseted = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this.gpuTextureView = null;
      this.textureBuffers.length = 0;
      if (this.renderTarget !== null) {
        this.renderTarget.destroyGpuRenderTarget();
      }
      this.removeAllListeners();
      this._style.reset();
      this.initBaseProperties();
    }
    /**
     * This will unload the Texture source from the GPU. This will free up the GPU memory
     * As soon as it is required fore rendering, it will be re-uploaded.
     */
    unload() {
      this._resourceId = uid$1("resource");
      this.emit("change", this);
      this.emit("unload", this);
    }
    /**
     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
     * but will the size of the texture when rendered.
     *
     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
     * density will have increased)
     */
    get resolution() {
      return this._resolution;
    }
    set resolution(resolution) {
      if (this._resolution === resolution)
        return;
      this._resolution = resolution;
      this.width = this.pixelWidth / resolution;
      this.height = this.pixelHeight / resolution;
    }
    /**
     * Resize the texture, this is handy if you want to use the texture as a render texture
     * @param width - the new width of the texture
     * @param height - the new height of the texture
     * @param resolution - the new resolution of the texture
     * @returns - if the texture was resized
     */
    resize(width, height, resolution) {
      resolution = resolution || this._resolution;
      width = width || this.width;
      height = height || this.height;
      const newPixelWidth = Math.round(width * resolution);
      const newPixelHeight = Math.round(height * resolution);
      this.width = width;
      this.height = height;
      this._resolution = resolution;
      if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
        return false;
      }
      this._refreshPOT();
      this.pixelWidth = newPixelWidth;
      this.pixelHeight = newPixelHeight;
      this.emit("resize", this);
      this._resourceId = uid$1("resource");
      this.emit("change", this);
      return true;
    }
    /**
     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
     * This is only important for RenderTexture instances, as standard Texture instances will have their
     * mipmaps generated on upload. You should call this method after you make any change to the texture
     *
     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
     * We want you, the developer to specify when this action should happen.
     *
     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
     */
    updateMipmaps() {
      if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
        this.emit("updateMipmaps", this);
      }
    }
    set wrapMode(value) {
      this._style.wrapMode = value;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(value) {
      this._style.scaleMode = value;
    }
    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
    get scaleMode() {
      return this._style.scaleMode;
    }
    /**
     * Refresh check for isPowerOfTwo texture based on size
     * @private
     */
    _refreshPOT() {
      this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
    }
  };
  /** The default options used when creating a new TextureSource. override these to add your own defaults */
  TextureSource.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
  };

  const TextureSourcePool = createPool("TextureSourcePool", TextureSource, 100);

  TextureSource.EMPTY = new TextureSource();
  TextureSource.EMPTY.setupOptions({ ...TextureSource.defaultOptions, style: TextureStyle.EMPTY });
  TextureSource.EMPTY.on = Function.empty;
  TextureSource.EMPTY.off = Function.empty;
  TextureSource.EMPTY.addListener = Function.empty;
  TextureSource.EMPTY.removeListener = Function.empty;
  TextureSource.EMPTY.removeAllListeners = Function.empty;
  TextureSource.EMPTY.destroy = Function.empty;
  TextureSource.EMPTY.reset = Function.empty;

  "use strict";
  class BufferImageSource extends TextureSource {
    setupOptions(options) {
      const buffer = options.resource || new Float32Array(options.width * options.height * 4);
      let format = options.format;
      if (!format) {
        if (buffer instanceof Float32Array) {
          format = "rgba32float";
        } else if (buffer instanceof Int32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Uint32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Int16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Uint16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Int8Array) {
          format = "bgra8unorm";
        } else {
          format = "bgra8unorm";
        }
      }
      options.format = format;
      super.setupOptions(options);
      this.uploadMethodId = "buffer";
      return this;
    }
    static test(resource) {
      return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
    }
  }
  BufferImageSource.extension = ExtensionType.TextureSource;

  "use strict";
  class TextureMatrix {
    /**
     * @param texture - observed texture
     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
     */
    constructor(texture, clampMargin = 0.5) {
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._updateID = 0;
      /**
       * @type {Texture}
       */
      this._texture = null;
      this.clampOffset = 0;
      this.clampMargin = clampMargin;
      this.isSimple = false;
      this.texture = texture;
    }
    /** Texture property. */
    get texture() {
      return this._texture;
    }
    set texture(value = null) {
      if (this._texture === value) return;
      if (this._texture !== null) {
        this._texture.removeListener("update", this.update, this);
        this._texture._textureMatrix = null;
      }
      if (value === null) {
        this._texture = Texture.EMPTY;
        return;
      }
      value._textureMatrix = this;
      this._texture = value;
      value.addListener("update", this.update, this);
      this.update();
    }
    /**
     * Multiplies uvs array to transform
     * @param uvs - mesh uvs
     * @param [out=uvs] - output
     * @returns - output
     */
    multiplyUvs(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      const mat = this.mapCoord;
      const a = mat.a;
      const b = mat.b;
      const c = mat.c;
      const d = mat.d;
      const tx = mat.tx;
      const ty = mat.ty;
      for (let i = 0; i < uvs.length; i += 2) {
        const x = uvs[i];
        const y = uvs[i + 1];
        out[i] = x * a + y * c + tx;
        out[i + 1] = x * b + y * d + ty;
      }
      return out;
    }
    /**
     * Updates matrices if texture was changed
     * @returns - whether or not it was updated
     */
    update() {
      const tex = this._texture;
      this._updateID++;
      const uvs = tex.uvs;
      const ux0 = uvs[0];
      const uy0 = uvs[1];
      const ux1 = uvs[2];
      const uy1 = uvs[3];
      const ux3 = uvs[6];
      const uy3 = uvs[7];
      this.mapCoord.set(ux1 - ux0, uy1 - uy0, ux3 - ux0, uy3 - uy0, ux0, uy0);
      const texBase = tex._source;
      const texFrame = tex.frame;
      const tfX = texFrame.x;
      const tfY = texFrame.y;
      const tfW = texFrame.width;
      const tfH = texFrame.height;
      const tbW = texBase.width;
      const tbH = texBase.height;
      const frame = this.uClampFrame;
      const resolution = texBase._resolution;
      const margin = this.clampMargin / resolution;
      const offset = this.clampOffset / resolution;
      frame[0] = (tfX + margin + offset) / tbW;
      frame[1] = (tfY + margin + offset) / tbH;
      frame[2] = (tfX + tfW - margin + offset) / tbW;
      frame[3] = (tfY + tfH - margin + offset) / tbH;
      this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
      this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
      this.isSimple = texFrame.width === texBase.width && texFrame.height === texBase.height && tex.rotate === 0;
      return true;
    }
  }

  const emptyUvs = [0, 0, 1, 0, 1, 1, 0, 1];
  class TextureUvs extends Float32Array {
    constructor() {
      super(emptyUvs);
    }
    /**
     * Sets the texture Uvs based on the given frame information.
     * @protected
     * @param {number} fx - The frame x of the texture
     * @param {number} fy - The frame y of the texture
     * @param {number} fw - The frame width of the texture
     * @param {number} fh - The frame height of the texture
     * @param {TextureSource}textureSource - The base frame of the texture
     */
    set(fx, fy, fw, fh, textureSource) {
      const tw = textureSource.width;
      const th = textureSource.height;
      const ux = fx / tw;
      const uy = fy / th;
      const uw = (fx + fw) / tw;
      const uh = (fy + fh) / th;
      this[0] = ux;
      this[1] = uy;
      this[2] = uw;
      this[3] = uy;
      this[4] = uw;
      this[5] = uh;
      this[6] = ux;
      this[7] = uh;
    }
    copyFrom(uvs) {
      this[0] = uvs[0];
      this[1] = uvs[1];
      this[2] = uvs[2];
      this[3] = uvs[3];
      this[4] = uvs[4];
      this[5] = uvs[5];
      this[6] = uvs[6];
      this[7] = uvs[7];
    }
    reset() {
      this[0] = 0;
      this[1] = 0;
      this[2] = 1;
      this[3] = 0;
      this[4] = 1;
      this[5] = 1;
      this[6] = 0;
      this[7] = 1;
    }
  }

  "use strict";
  class Texture extends EventEmitter {
    static defaultOptions = {
      source: null,
      frame: null,
      orig: null,
      rotate: null,
      defaultBorders: null
    }
    /**
     * @param {rendering.TextureOptions} options - Options for the texture
     */
    constructor(options = Texture.defaultOptions) {
      super();
      /** unique id for this texture */
      this.uid = uid$1("texture");
      /** A uvs object based on the given frame and the texture source */
      this.uvs = new TextureUvs();
      this.frame = new Rectangle();
      this.isTexture = true;
      this._source = options.source || null;
      if (options.frame) {
        this.frame.copyFrom(options.frame);
      } else if (this._source) {
        const source = this._source;
        const width = source.width;
        const height = source.height;
        const frame = this.frame;
        frame.width = width;
        frame.height = height;
      }
      this.orig = options.orig || this.frame;
      this.rotate = options.rotate != null ? options.rotate : 0;
      this.defaultBorders = options.defaultBorders;
      /**
       * @type {TextureMatrix|null}
       */
      this._textureMatrix = null;
      this.destroyed = false;
      this._textureBindGroup = null;
      const frame = this.frame;
      const isValid = frame.width > 0 && frame.height > 0;
      if (isValid) {
        this.setFrame(frame.x, frame.y, frame.width, frame.height);
      }
    }
    /** the underlying source of the texture (equivalent of baseTexture in v7) */
    get source() {
      Logger.warn("");
      return this._source;
    }
    set source(value = null) {
      this._source = value;
      if (value === null) return;
      const textureBindGroup = this._textureBindGroup;
      if (textureBindGroup !== null) {
        textureBindGroup.setResource(value, 0);
        textureBindGroup.setResource(value._style, 1);
      }
    }
    /**
    * Creates texture with params that were specified in pool constructor.
    * @description  sourcesource
    * @param {number} pixelWidth - Width of texture in pixels.
    * @param {number} pixelHeight - Height of texture in pixels.
    * @param {boolean} antialias
    */
    create(pixelWidth, pixelHeight, antialias) {
      if (this._source) return this;
      const textureSource = TextureSourcePool.get();
      textureSource.width = pixelWidth;
      textureSource.height = pixelHeight;
      textureSource.pixelWidth = pixelWidth;
      textureSource.pixelHeight = pixelHeight;
      textureSource.antialias = antialias;
      const options = Zaun.GeometrySystem.TextureOptions;
      options.source = textureSource;
      const texture = new Texture(options);
      options.source = null;
      return texture;
    }
    reset() {
      //empty doing nothing
    }
    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
    checkTextureMatrix() {
      if (this._textureMatrix === null) {
        this._textureMatrix = new TextureMatrix(this);
      }
    }
    /** The width of the Texture in pixels. */
    get width() {
      return this.orig.width;
    }
    /** The height of the Texture in pixels. */
    get height() {
      return this.orig.height;
    }
    setFrame(x, y, width, height) {
      const frame = this.frame;
      frame.x = x;
      frame.y = y;
      frame.width = width;
      frame.height = height;
      this.updateUvs(x, y, width, height);
    }
    /** Call this function when you have modified the frame of this texture. */
    updateUvs(fx, fy, fw, fh) {
      const uvs = this.uvs;
      const source = this._source;
      uvs.set(fx, fy, fw, fh, source);
      this.emit("update");
    }
    /**
     * Destroys this texture
     * @param destroySource - Destroy the source when the texture is destroyed.
     */
    destroy(destroySource = false) {
      if (this._source) {
        if (destroySource) {
          this._source.destroy();
          this._source = null;
        }
      }
      if (this._textureBindGroup !== null) {
        this._textureBindGroup.destroy();
        this._textureBindGroup = null;
      }
      this._textureMatrix = null;
      this.destroyed = true;
      this.emit("destroy", this);
      this.removeAllListeners();
    }
  }
  Texture.EMPTY = new Texture({
    source: TextureSource.EMPTY
  });
  Texture.EMPTY.destroy = Function.empty;
  Texture.WHITE = new Texture({
    source: (new BufferImageSource()).setupOptions({
      resource: new Uint8Array([255, 255, 255, 255]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Texture.WHITE._source.on = Function.empty;
  Texture.WHITE._source.off = Function.empty;
  Texture.WHITE._source.addListener = Function.empty;
  Texture.WHITE._source.removeListener = Function.empty;
  Texture.WHITE._source.once = Function.empty;
  Texture.WHITE.destroy = Function.empty;

  "use strict";
  function updateQuadBounds(bounds, anchor, texture) {
    const orig = texture.orig;
    const width = orig.width;
    const height = orig.height
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }

  "use strict";
  class ViewContainer extends Container {
    constructor() {
      super(...arguments);
      /** @private */
      this.canBundle = true;
      /** @private */
      this.allowChildren = false;
      /** @private */
      this._roundPixels = 0;
      /** @private */
      this._lastUsed = 0;
      this._gpuData = null;
      /** @private */
      this._lastInstructionTick = -1;
      this._bounds = new Bounds(0, 1, 0, 0);
      this._boundsDirty = true;
    }
    createChildren() { }
    /**
     * Whether or not to round the x/y position of the sprite.
     * @type {boolean}
     */
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(value) {
      this._roundPixels = value ? 1 : 0;
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const bounds = this.bounds;
      const x = point.x;
      const y = point.y;
      return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;
    }
    /** @private */
    onViewUpdate() {
      this._didViewChangeTick++;
      if (this.didViewUpdate) return;
      this.didViewUpdate = true;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) renderGroup.onChildViewUpdate(this);
    }
    collectRenderablesSimple(instructionSet, renderer) {
      const renderPipes = renderer.renderPipes;
      renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);
      const rp = renderPipes;
      rp[this.renderPipeId].addRenderable(this, instructionSet);
      this.didViewUpdate = false;
    }
    destroy(options) {
      super.destroy(options);
      this._gpuData = null;
      this._bounds = null;
    }
  }

  "use strict";
  class Sprite extends ViewContainer {
    /**
     * @param options - The options for creating the sprite.
     */
    constructor(options = Object.empty) {
      super();
      this.renderPipeId = "sprite";
      this.batched = true;
      this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
      this._anchor = new ObservablePoint(
        {
          _onUpdate: this._updateBounds.bind(this)
        }
      );
      const texture = options.texture || Texture.EMPTY;
      const roundPixels = options.roundPixels;
      const anchor = options.anchor;
      this._sourceBoundsDirty = true;
      if (anchor) {
        this.anchor = anchor;
      }
      this.texture = texture;
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value) return;
      this._texture = value;
      const frame = value.frame;
      if (frame.width > 1 && frame.height > 1) {
        this._updateBounds();
      }
    }
    /** The texture that the sprite is using. */
    get texture() {
      return this._texture;
    }
    /**
     * The local bounds of the sprite.
     * @type {rendering.Bounds}
     */
    get bounds() {
      return this._bounds;
    }
    /**
     * The bounds of the sprite, taking the texture's trim into account.
     * @type {rendering.Bounds}
     */
    get sourceBounds() {
      if (this._sourceBoundsDirty) {
        this._updateSourceBounds();
        this._sourceBoundsDirty = false
      }
      return this._sourceBounds;
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const bounds = this.sourceBounds;
      if (point.x >= bounds.maxX && point.x <= bounds.minX) {
        if (point.y >= bounds.maxY && point.y <= bounds.minY) {
          return true;
        }
      }
      return false;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      const _bounds = this.bounds;
      bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
    }
    _updateBounds() {
      updateQuadBounds(this._bounds, this._anchor, this._texture);
    }
    _updateSourceBounds() {
      const anchor = this._anchor;
      const texture = this._texture;
      const sourceBounds = this._sourceBounds;
      const orig = texture.orig;
      const width = orig.width;
      const height = orig.height;
      sourceBounds.maxX = -anchor._x * width;
      sourceBounds.minX = sourceBounds.maxX + width;
      sourceBounds.maxY = -anchor._y * height;
      sourceBounds.minY = sourceBounds.maxY + height;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options = false) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
      this._bounds = null;
      this._sourceBounds = null;
      this._anchor = null;
    }
    /**
     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the sprite's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * import { Sprite } from 'pixi.js';
     *
     * const sprite = new Sprite({texture: Texture.WHITE});
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      this._setWidth(value, this._texture.orig.width);
      this._width = value;
    }
    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      this._setHeight(value, this._texture.orig.height);
      this._height = value;
    }
    /**
     * Retrieves the size of the Sprite as a [Size]{@link Size} object.
     * This is faster than get the width and height separately.
     * @param out - Optional object to store the size in.
     * @returns - The size of the Sprite.
     */
    getSize(out) {
      out || (out = {});
      out.width = Math.abs(this.scale.x) * this._texture.orig.width;
      out.height = Math.abs(this.scale.y) * this._texture.orig.height;
      return out;
    }
    /**
     * Sets the size of the Sprite to the specified width and height.
     * This is faster than setting the width and height separately.
     * @param value - This can be either a number or a [Size]{@link Size} object.
     * @param height - The height to set. Defaults to the value of `width` if not provided.
     */
    setSize(value, height) {
      var _a;
      if (typeof value === "object") {
        height = (_a = value.height) != null ? _a : value.width;
        value = value.width;
      } else {
        height != null ? height : height = value;
      }
      value !== void 0 && this._setWidth(value, this._texture.orig.width);
      height !== void 0 && this._setHeight(height, this._texture.orig.height);
    }
  }

  "use strict";
  const tempBounds$4 = new Bounds();
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds$4;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }

  "use strict";
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      Logger.warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }

  "use strict";
  class AlphaMask {
    constructor(options) {
      this.priority = 0;
      this.inverse = false;
      this.pipe = "alphaMask";
      if (options == null ? void 0 : options.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
      this.renderMaskToTexture = !(mask instanceof Sprite);
      this.mask.renderable = this.renderMaskToTexture;
      this.mask.includeInBuild = !this.renderMaskToTexture;
      this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true;
      this.mask = null;
    }
    addBounds(bounds, skipUpdateTransform) {
      if (!this.inverse) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    destroy() {
      this.reset();
    }
    static test(mask) {
      return mask instanceof Sprite;
    }
  }
  AlphaMask.extension = ExtensionType.MaskEffect;

  "use strict";
  class ColorMask {
    constructor(options) {
      this.priority = 0;
      this.pipe = "colorMask";
      if (options == null ? void 0 : options.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
    }
    destroy() {
    }
    static test(mask) {
      return typeof mask === "number";
    }
  }
  ColorMask.extension = ExtensionType.MaskEffect;

  "use strict";
  class StencilMask {
    constructor(options) {
      this.priority = 0;
      this.pipe = "stencilMask";
      if (options == null ? void 0 : options.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
      this.mask.includeInBuild = false;
      this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true;
      this.mask.includeInBuild = true;
      this.mask = null;
    }
    addBounds(bounds, skipUpdateTransform) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    destroy() {
      this.reset();
    }
    static test(mask) {
      return mask instanceof Container;
    }
  }
  StencilMask.extension = ExtensionType.MaskEffect;

  "use strict";
  extensions.add(AlphaMask, ColorMask, StencilMask, BufferImageSource);

  "use strict";
  class BindGroup {
    static bigBindGroupHash = Object.create(null);
    static clearGPUCache() {
      if (Engine.isWebgl()) return;
      this.bigBindGroupHash = Object.create(null);
    }
    /**
     * Create a new instance of the Bind Group.
     * @param resources - The resources that are bound together for use by a shader.
     */
    constructor(resources) {
      /** The resources that are bound together for use by a shader. */
      this.resources = [];
      this._dirty = true;
      let index = 0;
      for (const i in resources) {
        const resource = resources[i];
        this.setResource(resource, index++);
      }
      this._gpuBindGroup = null;
      this._key = "";
      if (index > 0) this._update();
    }
    resetForBatch(maxTextures) {
      const emptyTexture = TextureSource.EMPTY;
      const emptyStyle = TextureStyle.EMPTY;
      const resources = this.resources;
      for (let i = 0; i < maxTextures; i++) {
        const textureIndex = i * 2;
        const styleIndex = i * 2 + 1;
        const lastTexture = resources[textureIndex];
        const lastStyle = resources[styleIndex];
        if (lastTexture !== emptyTexture) {
          resources[textureIndex] = emptyTexture;
          lastTexture.off("change", this.onResourceChange);
        }
        if (lastStyle !== emptyStyle) {
          resources[styleIndex] = emptyStyle;
          lastStyle.off("change", this.onResourceChange);
        }
      }
      this._dirty = true;
    }
    reset() {
      const resources = this.resources;
      for (let i = 0; i < resources.length; i++) {
        const resource = resources[i];
        if (resource) {
          resource.off("change", this.onResourceChange, this);
        }
      }
      this._gpuBindGroup = null;
      resources.length = 0;
      this._dirty = false;
    }
    /**
     * Updates the key if its flagged as dirty. This is used internally to
     * match this bind group to a WebGPU BindGroup.
     * @internal
     * @ignore
     */
    _update() {
      if (!this._dirty) return;
      const resources = this.resources;
      let newKey = "";
      const oldKey = this._key;
      for (let i = 0; i < resources.length; i++) {
        const resource = resources[i];
        const id = resource._resourceId;
        newKey += `${id}|`;
      }
      if (this._gpuBindGroup !== null) {
        BindGroup.bigBindGroupHash[oldKey] = this._gpuBindGroup;
      }
      this._key = newKey;
      const newBindgroup = BindGroup.bigBindGroupHash[newKey];
      this._gpuBindGroup = newBindgroup !== void 0 ? newBindgroup : null;
      this._dirty = false;
    }
    /**
     * Set a resource at a given index. this function will
     * ensure that listeners will be removed from the current resource
     * and added to the new resource.
     * @param resource - The resource to set.
     * @param index - The index to set the resource at.
     */
    setResource(resource, index) {
      const currentResource = this.resources[index];
      if (resource === currentResource) return;
      if (currentResource != null) {
        currentResource.off("change", this.onResourceChange, this);
      }
      //change
      resource.clearListener("change");
      resource.on("change", this.onResourceChange, this);
      this.resources[index] = resource;
      this._dirty = true;
    }
    /**
     * Returns the resource at the current specified index.
     * @param index - The index of the resource to get.
     * @returns - The resource at the specified index.
     */
    getResource(index) {
      return this.resources[index];
    }
    /** Destroys this bind group and removes all listeners. */
    destroy() {
      this.reset();
    }
    onResourceChange(resource) {
      this._dirty = true;
      if (resource.reseted) {
        const empty = resource.isTextureSource ? TextureSource.EMPTY : TextureStyle.EMPTY;
        const resources = this.resources;
        for (let i = 0; i < resources.length; i++) {
          const res = resources[i];
          if (res === resource) {
            this.setResource(empty, i);
            break;
          }
        }
        this._gpuBindGroup = null;
      } else {
        this._update();
      }
    }
  }

  const BindGroupPool = createPool("BindGroupPool", BindGroup, 100);

  "use strict";
  const fragTemplate$1 = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += `if(test == ${i}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }

  "use strict";
  const cachedGroups = {};
  //
  function getTextureBatchBindGroup(textures, size, maxTextures) {
    let uid = 2166136261;
    for (let i = 0; i < size; i++) {
      uid ^= textures[i].uid
      uid = Math.imul(uid, 16777619);
      uid >>>= 0;
    }
    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);
  }
  function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
    const bindGroupResources = {};
    let bindIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      const texture = i < size ? textures[i] : Texture.EMPTY._source;
      bindGroupResources[bindIndex++] = texture;
      bindGroupResources[bindIndex++] = texture._style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }

  "use strict";
  class ViewableBuffer {
    constructor(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
      this.size = this.rawBinaryData.byteLength;
    }
    /** View on the raw binary data as a `Int8Array`. */
    get int8View() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    }
    /** View on the raw binary data as a `Uint8Array`. */
    get uint8View() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    }
    /**  View on the raw binary data as a `Int16Array`. */
    get int16View() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    }
    /** View on the raw binary data as a `Int32Array`. */
    get int32View() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    }
    /** View on the raw binary data as a `Float64Array`. */
    get float64View() {
      if (!this._float64Array) {
        this._float64Array = new Float64Array(this.rawBinaryData);
      }
      return this._float64Array;
    }
    /** View on the raw binary data as a `BigUint64Array`. */
    get bigUint64View() {
      if (!this._bigUint64Array) {
        this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
      }
      return this._bigUint64Array;
    }
    /**
     * Returns the view of the given type.
     * @param type - One of `int8`, `uint8`, `int16`,
     *    `uint16`, `int32`, `uint32`, and `float32`.
     * @returns - typed array of given type
     */
    view(type) {
      const key = type + "View";
      return this[key];
    }
    /** Destroys all buffer references. Do not use after calling this. */
    destroy() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this.uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    }
    /**
     * Returns the size of the given type in bytes.
     * @param type - One of `int8`, `uint8`, `int16`,
     *   `uint16`, `int32`, `uint32`, and `float32`.
     * @returns - size of the type in bytes
     */
    static sizeOf(type) {
      switch (type) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${type} isn't a valid view type`);
      }
    }
  }

  "use strict";
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }

  "use strict";
  const BLEND_TO_NPM = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  var STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
    STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
    STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
    STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
    return STENCIL_MODES2;
  })(STENCIL_MODES || {});

  "use strict";
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }

  "use strict";
  class BatchTextureArray {
    constructor() {
      /** Respective locations for textures. */
      this.ids = /* @__PURE__ */ Object.create(null);
      this.textures = [];
      this.count = 0;
      const isWebgpu = Engine.isWebgpu();
      if (isWebgpu) {
        const bindGroup = this.bindGroup = new BindGroup();
        const maxTextures = Engine.renderer.limits.maxBatchableTextures;
        let index = 0;
        for (let i = 0; i < maxTextures; i++) {
          bindGroup.setResource(TextureSource.EMPTY, index++);
          bindGroup.setResource(TextureStyle.EMPTY, index++);
        }
      }
      this._setGpuResource = isWebgpu ? this.setGpuRespurce : Function.empty;
      this._resetGpuBindgroup = isWebgpu ? this.resetGpuBindgroup : Function.empty;
    }
    /** Clear the textures and their locations. */
    clear() {
      const textures = this.textures;
      const ids = this.ids;
      const count = this.count;
      for (let i = 0; i < count; i++) {
        const t = textures[i];
        textures[i] = null;
        ids[t.uid] = null;
      }
      textures.length = 0;
      this.count = 0;
      this._resetGpuBindgroup();
    }
    resetGpuBindgroup() {
      this.bindGroup.resetForBatch(Engine.renderer.limits.maxBatchableTextures);
    }
    // mark texture index error
    addTexture(element, source) {
      const count = this.count;
      const textures = this.textures;
      const ids = this.ids;
      element._textureId = source._textureBindLocation = count;
      textures[this.count++] = source;
      ids[source.uid] = count;
      this._setGpuResource(source, count);
    }
    setGpuRespurce(texture, count) {
      const bindGroup = this.bindGroup;
      count = count * 2;
      bindGroup.setResource(texture, count);
      bindGroup.setResource(texture._style, count + 1);
    }
  }

  "use strict";
  class Batch {
    constructor() {
      this.renderPipeId = "batch";
      this.action = "startBatch";
      // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones
      // public elementStart = 0;
      // public elementSize = 0;
      // for drawing..
      this.start = 0;
      this.size = 0;
      this.textures = new BatchTextureArray();
      this.blendMode = "normal";
      this.canBundle = true;
    }
    destroy() {
      this.textures = null;
      this.gpuBindGroup = null;
      this.bindGroup = null;
      this.batcher = null;
    }
  }
  const batchPool = [];
  let batchPoolIndex = 0;
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  globalThis.batchPool = batchPool;
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  let BATCH_TICK = 0;
  function checkAndUpdateTexture(batchableObject, texture) {
    const textureId = batchableObject._batch.textures.ids[texture._source.uid];
    if (textureId == null) return false;
    batchableObject._textureId = textureId;
    batchableObject.texture = texture;
    return true;
  }

  function packQuadIndex(indexBuffer, index, indicesOffset) {
    indexBuffer[index] = indicesOffset + 0;
    indexBuffer[index + 1] = indicesOffset + 1;
    indexBuffer[index + 2] = indicesOffset + 2;
    indexBuffer[index + 3] = indicesOffset + 0;
    indexBuffer[index + 4] = indicesOffset + 2;
    indexBuffer[index + 5] = indicesOffset + 3;
  }

  function packIndex(element, indexBuffer, index, indicesOffset) {
    const indices = element.indices;
    const size = element.indexSize;
    const indexOffset = element.indexOffset;
    const attributeOffset = element.attributeOffset;
    for (let i = 0; i < size; i++) {
      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;
    }
  }

  class Batcher {
    constructor(options = Batcher.defaultOptions) {
      /** unique id for this batcher */
      this.uid = uid$1("batcher");
      /** Indicates whether the batch data has been modified and needs updating. */
      this.dirty = true;
      /** The current index of the batch being processed. */
      this.batchIndex = 0;
      /** An array of all batches created during the current rendering process. */
      this.batches = [];
      this._elements = [];
      this.attributeSize = 0;
      this.indexSize = 0;
      this.elementSize = 0;
      this.elementStart = 0;
      options.maxTextures = options.maxTextures || 16;
      const attributesInitialSize = options.attributesInitialSize || 4;
      const indicesInitialSize = options.indicesInitialSize || 6;
      this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
      this.indexBuffer = new Uint16Array(indicesInitialSize);
      this.maxTextures = options.maxTextures;
    }
    begin() {
      this.elementSize = 0;
      this.elementStart = 0;
      this.indexSize = 0;
      this.attributeSize = 0;
      const batches = this.batches;
      for (let i = 0; i < this.batchIndex; i++) {
        returnBatchToPool(batches[i]);
      }
      this.batchIndex = 0;
      this._batchIndexStart = 0;
      this._batchIndexSize = 0;
      this.dirty = true;
    }
    add(batchableObject) {
      this._elements[this.elementSize++] = batchableObject;
      batchableObject._indexStart = this.indexSize;
      batchableObject._attributeStart = this.attributeSize;
      batchableObject._batcher = this;
      this.indexSize += batchableObject.indexSize;
      this.attributeSize += batchableObject.attributeSize * this.vertexSize;
    }
    updateElement(batchableObject) {
      this.dirty = true;
      const attributeBuffer = this.attributeBuffer;
      if (batchableObject.packAsQuad) {
        this.packQuadAttributes(
          batchableObject,
          attributeBuffer.float32View,
          attributeBuffer.uint32View,
          batchableObject._attributeStart,
          batchableObject._textureId
        );
      } else {
        this.packAttributes(
          batchableObject,
          attributeBuffer.float32View,
          attributeBuffer.uint32View,
          batchableObject._attributeStart,
          batchableObject._textureId
        );
      }
    }
    /**
     * breaks the batcher. This happens when a batch gets too big,
     * or we need to switch to a different type of rendering (a filter for example)
     * @param instructionSet
     */
    break(instructionSet) {
      const elements = this._elements;
      if (!elements[this.elementStart]) return;
      let batch = getBatchFromPool();
      let textureBatch = batch.textures;
      textureBatch.clear();
      const firstElement = elements[this.elementStart];
      let blendMode = getAdjustedBlendModeBlend(firstElement.renderable.groupBlendMode, firstElement.texture._source);
      if (this.attributeSize * 4 > this.attributeBuffer.size) {
        this._resizeAttributeBuffer(this.attributeSize * 4);
      }
      if (this.indexSize > this.indexBuffer.length) {
        this._resizeIndexBuffer(this.indexSize);
      }
      const attributeBuffer = this.attributeBuffer;
      const f32 = attributeBuffer.float32View;
      const u32 = attributeBuffer.uint32View;
      const indexBuffer = this.indexBuffer;
      let size = this._batchIndexSize;
      let start = this._batchIndexStart;
      let action = "startBatch";
      const maxTextures = this.maxTextures;
      const vertexSize = this.vertexSize;
      for (let i = this.elementStart; i < this.elementSize; ++i) {
        const element = elements[i];
        elements[i] = null;
        const texture = element.texture;
        const source = texture._source;
        const adjustedBlendMode = getAdjustedBlendModeBlend(element.renderable.groupBlendMode, source);
        const breakRequired = blendMode !== adjustedBlendMode;
        if (source._batchTick === BATCH_TICK && !breakRequired) {
          element._textureId = source._textureBindLocation;
          size += element.indexSize;
          if (element.packAsQuad) {
            this.packQuadAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            packQuadIndex(
              indexBuffer,
              element._indexStart,
              element._attributeStart / vertexSize
            )
          } else {
            this.packAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            packIndex(
              element,
              indexBuffer,
              element._indexStart,
              element._attributeStart / vertexSize
            );
          }
          element._batch = batch;
          continue;
        }
        source._batchTick = BATCH_TICK;
        if (textureBatch.count >= maxTextures || breakRequired) {
          this._finishBatch(
            batch,
            start,
            size - start,
            textureBatch,
            blendMode,
            instructionSet,
            action
          );
          action = "renderBatch";
          start = size;
          blendMode = adjustedBlendMode;
          batch = getBatchFromPool();
          textureBatch = batch.textures;
          textureBatch.clear();
          ++BATCH_TICK;
        }
        this.onAddTexture(element, texture, textureBatch);
        element._batch = batch;
        size += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          packQuadIndex(
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        } else {
          this.packAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          packIndex(
            element,
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        }
      }
      if (textureBatch.count > 0) {
        this._finishBatch(
          batch,
          start,
          size - start,
          textureBatch,
          blendMode,
          instructionSet,
          action
        );
        start = size;
        ++BATCH_TICK;
      }
      this.elementStart = this.elementSize;
      this._batchIndexStart = start;
      this._batchIndexSize = size;
    }
    /**
     * @param {BatchableSprite} element 
     * @param {Texture} texture 
     * @param {BatchTextureArray} textureBatch 
     */
    onAddTexture(element, texture, textureBatch) {
      textureBatch.addTexture(element, texture._source);
    }
    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
      batch.gpuBindGroup = null;
      batch.bindGroup = null;
      batch.action = action;
      batch.batcher = this;
      batch.textures = textureBatch;
      batch.blendMode = blendMode;
      batch.start = indexStart;
      batch.size = indexSize;
      ++BATCH_TICK;
      this.batches[this.batchIndex++] = batch;
      instructionSet.add(batch);
    }
    finish(instructionSet) {
      this.break(instructionSet);
    }
    /**
     * Resizes the attribute buffer to the given size (1 = 1 float32)
     * @param size - the size in vertices to ensure (not bytes!)
     */
    ensureAttributeBuffer(size) {
      if (size * 4 <= this.attributeBuffer.size)
        return;
      this._resizeAttributeBuffer(size * 4);
    }
    /**
     * Resizes the index buffer to the given size (1 = 1 float32)
     * @param size - the size in vertices to ensure (not bytes!)
     */
    ensureIndexBuffer(size) {
      if (size <= this.indexBuffer.length)
        return;
      this._resizeIndexBuffer(size);
    }
    _resizeAttributeBuffer(size) {
      const attributeBuffer = this.attributeBuffer;
      const newSize = Math.max(size, attributeBuffer.size * 2);
      const newArrayBuffer = new ViewableBuffer(newSize);
      fastCopy(attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
      this.attributeBuffer = newArrayBuffer;
    }
    _resizeIndexBuffer(size) {
      const indexBuffer = this.indexBuffer;
      let newSize = Math.max(size, indexBuffer.length * 1.5);
      newSize += newSize % 2;
      const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
      if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
        for (let i = 0; i < indexBuffer.length; i++) {
          newIndexBuffer[i] = indexBuffer[i];
        }
      } else {
        fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
      }
      this.indexBuffer = newIndexBuffer;
    }
    destroy() {
      for (let i = 0; i < this.batches.length; i++) {
        returnBatchToPool(this.batches[i]);
      }
      this.batches = null;
      for (let i = 0; i < this._elements.length; i++) {
        this._elements[i]._batch = null;
      }
      this._elements = null;
      this.indexBuffer = null;
      this.attributeBuffer.destroy();
      this.attributeBuffer = null;
    }
  };
  Batcher.defaultOptions = {
    maxTextures: 16,
    attributesInitialSize: 4,
    indicesInitialSize: 6,
    shader: null
  };

  "use strict";
  var BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
    BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
    BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
    BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
    BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
    BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
    BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
    BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
    BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
    BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
    BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
    BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
    return BufferUsage2;
  })(BufferUsage || {});

  "use strict";
  class Buffer extends EventEmitter {
    /**
     * Creates a new Buffer with the given options
     * @param options - the options for the buffer
     */
    constructor(options) {
      super();
      this._gpuBuffer = null;
      /**
       * emits when the underlying buffer has changed shape (i.e. resized)
       * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
       * @event change
       */
      /**
       * emits when the underlying buffer data has been updated. letting the renderer know
       * that it needs to update the buffer on the GPU
       * @event update
       */
      /**
       * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU
       * @event destroy
       */
      /** a unique id for this uniform group used through the renderer */
      this.uid = uid$1("buffer");
      /**
       * a resource type, used to identify how to handle it when its in a bind group / shader resource
       * @internal
       * @ignore
       */
      this._resourceType = "buffer";
      /**
       * the resource id used internally by the renderer to build bind group keys
       * @internal
       * @ignore
       */
      this._resourceId = uid$1("resource");
      /**
       * @internal
       * @ignore
       */
      this._updateID = 1;
      /**
       * should the GPU buffer be shrunk when the data becomes smaller?
       * changing this will cause the buffer to be destroyed and a new one created on the GPU
       * this can be expensive, especially if the buffer is already big enough!
       * setting this to false will prevent the buffer from being shrunk. This will yield better performance
       * if you are constantly setting data that is changing size often.
       * @default true
       */
      this.shrinkToFit = true;
      /**
       * Has the buffer been destroyed?
       * @readonly
       */
      this.destroyed = false;
      this.reseted = false;
      this.descriptor = {
        size: 0,
        usage: 0,
        mappedAtCreation: false,
        label: ""
      };
      this.setupOptions(options);
    }
    reset() {
      if (this.reseted) return;
      this.emit("destroy", this);
      this.emit("change", this);
      this.reseted = true;
      this.shrinkToFit = true;
      this.destroyed = false;
      this._updateID = 1;
      this._gpuBuffer = null;
    }
    setupOptions(options) {
      let { data, size } = options;
      const { usage, label, shrinkToFit } = options;
      if (Array.isArray(data)) {
        data = new Float32Array(data);
      }
      this._data = data;
      this._dataInt32 = null;
      size = size != null ? size : data == null ? void 0 : data.byteLength;
      const mappedAtCreation = !!data;
      const descriptor = this.descriptor;
      descriptor.size = size;
      descriptor.usage = usage;
      descriptor.mappedAtCreation = mappedAtCreation;
      descriptor.label = label;
      this.shrinkToFit = shrinkToFit != null ? shrinkToFit : true
    }
    /** the data in the buffer */
    get data() {
      return this._data;
    }
    set data(value) {
      this.setDataWithSize(value, value.length, true);
    }
    get dataInt32() {
      if (!this._dataInt32) {
        this._dataInt32 = new Int32Array((this._data).buffer);
      }
      return this._dataInt32;
    }
    /** whether the buffer is static or not */
    get static() {
      return !!(this.descriptor.usage & BufferUsage.STATIC);
    }
    set static(value) {
      if (value) {
        this.descriptor.usage |= BufferUsage.STATIC;
      } else {
        this.descriptor.usage &= ~BufferUsage.STATIC;
      }
    }
    /**
     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
     * If you only want to update a subset of the buffer, you can pass in the size of the data.
     * @param value - the data to set
     * @param size - the size of the data in bytes
     * @param syncGPU - should the buffer be updated on the GPU immediately?
     */
    setDataWithSize(value, size, syncGPU) {
      this._updateID++;
      this._updateSize = size * value.BYTES_PER_ELEMENT;
      if (this._data === value) return;
      const oldData = this._data;
      this._data = value;
      this._dataInt32 = null;
      if (!oldData || oldData.length !== value.length) {
        if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
          if (syncGPU)
            this.emit("update", this);
        } else {
          this.descriptor.size = value.byteLength;
          this._resourceId = uid$1("resource");
          this.emit("change", this);
        }
      }
    }
    /**
     * updates the buffer on the GPU to reflect the data in the buffer.
     * By default it will update the entire buffer. If you only want to update a subset of the buffer,
     * you can pass in the size of the buffer to update.
     * @param sizeInBytes - the new size of the buffer in bytes
     */
    update(sizeInBytes) {
      this._updateSize = sizeInBytes != null ? sizeInBytes : this._updateSize;
      this._updateID++;
      this.emit("update", this);
    }
    /** Destroys the buffer */
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this._data = null;
      this.descriptor = null;
      this.removeAllListeners();
    }
  }

  "use strict";
  function ensureIsBuffer(buffer, index) {
    if (!(buffer._resourceType === "buffer")) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (Array.isArray(buffer)) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }

  "use strict";
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer._data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i = offset; i < data.length; i += stride) {
      const x = data[i];
      const y = data[i + 1];
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }

  "use strict";
  function ensureIsAttribute(attribute) {
    if (attribute._resourceType === "buffer" || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  class Geometry extends EventEmitter {
    /**
     * Create a new instance of a geometry
     * @param options - The options for the geometry.
     */
    constructor(options = {}) {
      super();
      /** The unique id of the geometry. */
      this.uid = uid$1("geometry");
      /**
       * the layout key will be generated by WebGPU all geometries that have the same structure
       * will have the same layout key. This is used to cache the pipeline layout
       * @internal
       * @ignore
       */
      this.attributeArray = [];
      this.attributeCount = 0;
      this._layoutKey = 0;
      /** the instance count of the geometry to draw */
      this.instanceCount = 1;
      this._bounds = new Bounds();
      this._boundsDirty = true;
      const { attributes, indexBuffer, topology } = options;
      this.buffers = [];
      this.attributes = {};
      if (attributes) {
        for (const i in attributes) {
          this.addAttribute(i, attributes[i]);
        }
      }
      this.instanceCount = options.instanceCount || 1;
      if (indexBuffer) {
        this.addIndex(indexBuffer);
      }
      this.topology = topology || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true;
      this.emit("update", this);
    }
    /**
     * Returns the requested attribute.
     * @param id - The name of the attribute required
     * @returns - The attribute requested.
     */
    getAttribute(id) {
      return this.attributes[id];
    }
    /**
     * Returns the index buffer
     * @returns - The index buffer.
     */
    getIndex() {
      return this.indexBuffer;
    }
    /**
     * Returns the requested buffer.
     * @param id - The name of the buffer required.
     * @returns - The buffer requested.
     */
    getBuffer(id) {
      return this.getAttribute(id).buffer;
    }
    /**
     * Used to figure out how many vertices there are in this geometry
     * @returns the number of vertices in the geometry
     */
    getSize() {
      if (this.attributeCount === 0) return 0;
      const firstAttribute = this.attributeArray[0];
      const buffer = firstAttribute.buffer;
      return buffer._data.length / (attribute.stride / 4 || attribute.size);
    }
    /**
     * Adds an attribute to the geometry.
     * @param name - The name of the attribute to add.
     * @param attributeOption - The attribute option to add.
     */
    addAttribute(name, attributeOption) {
      const attribute = ensureIsAttribute(attributeOption);
      const buffer = attribute.buffer;
      if (this.buffers.add(buffer)) {
        buffer.on("update", this.onBufferUpdate, this);
        buffer.on("change", this.onBufferUpdate, this);
      }
      if (this.attributeArray.add(attribute)) this.attributeCount += 1;
      this.attributes[name] = attribute;
      return this;
    }
    /**
     * Adds an index buffer to the geometry.
     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
     */
    addIndex(indexBuffer) {
      this.indexBuffer = ensureIsBuffer(indexBuffer, true);
      this.buffers.add(this.indexBuffer);
      return this;
    }
    /** Returns the bounds of the geometry. */
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      this._boundsDirty = false;
      return getGeometryBounds(this, "aPosition", this._bounds);
    }
    /**
     * destroys the geometry.
     * @param destroyBuffers - destroy the buffers associated with this geometry
     */
    destroy(destroyBuffers = false) {
      this.emit("destroy", this);
      this.removeAllListeners();
      if (destroyBuffers) {
        const buffers = this.buffers;
        for (let i = 0; i < buffers.length; i++) {
          buffers[i].destroy();
        }
      }
      this.attributes = null;
      this.buffers = null;
      this.indexBuffer = null;
      this._bounds = null;
    }
  }

  "use strict";
  const placeHolderBufferData = new Float32Array(1);
  const placeHolderIndexData = new Uint32Array(1);
  class BatchGeometry extends Geometry {
    constructor() {
      const vertexSize = 6;
      const attributeBuffer = new Buffer({
        data: placeHolderBufferData,
        label: "attribute-batch-buffer",
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const indexBuffer = new Buffer({
        data: placeHolderIndexData,
        label: "index-batch-buffer",
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
        // | BufferUsage.STATIC,
        shrinkToFit: false
      });
      const stride = vertexSize * 4;
      super({
        attributes: {
          aPosition: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 0
          },
          aUV: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 2 * 4
          },
          aColor: {
            buffer: attributeBuffer,
            format: "unorm8x4",
            stride,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: attributeBuffer,
            format: "uint16x2",
            stride,
            offset: 5 * 4
          }
        },
        indexBuffer
      });
    }
  }

  "use strict";
  const idCounts = /* @__PURE__ */ Object.create(null);
  const idHash = /* @__PURE__ */ Object.create(null);
  function createIdFromString(value, groupId) {
    let id = idHash[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash[value] = id = idCounts[groupId]++;
    }
    return id;
  }

  "use strict";
  let maxFragmentPrecision;
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = Engine.renderer.gl;
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }

  "use strict";
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }

  "use strict";
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }

  "use strict";
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }

  "use strict";
  const fragmentNameCache = {};
  const VertexNameCache = {};
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }

  "use strict";
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }

  "use strict";
  var __defProp$_ = Object.defineProperty;
  var __getOwnPropSymbols$_ = Object.getOwnPropertySymbols;
  var __hasOwnProp$_ = Object.prototype.hasOwnProperty;
  var __propIsEnum$_ = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$_ = (obj, key, value) => key in obj ? __defProp$_(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$_ = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$_.call(b, prop))
        __defNormalProp$_(a, prop, b[prop]);
    if (__getOwnPropSymbols$_)
      for (var prop of __getOwnPropSymbols$_(b)) {
        if (__propIsEnum$_.call(b, prop))
          __defNormalProp$_(a, prop, b[prop]);
      }
    return a;
  };
  const processes = {
    // strips any version headers..
    stripVersion,
    // adds precision string if not already present
    ensurePrecision,
    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
    addProgramDefines,
    // add the program name to the shader
    setProgramName,
    // add the version string to the shader header
    insertVersion
  };
  const programCache$1 = /* @__PURE__ */ Object.create(null);
  class GlProgram {
    /**
     * Creates a shiny new GlProgram. Used by WebGL renderer.
     * @param options - The options for the program.
     */
    constructor(options) {
      options = __spreadValues$_(__spreadValues$_({}, GlProgram.defaultOptions), options);
      const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
      const preprocessorOptions = {
        stripVersion: isES300,
        ensurePrecision: {
          requestedFragmentPrecision: options.preferredFragmentPrecision,
          requestedVertexPrecision: options.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: getMaxFragmentPrecision()
        },
        setProgramName: {
          name: options.name
        },
        addProgramDefines: isES300,
        insertVersion: isES300
      };
      let fragment = options.fragment;
      let vertex = options.vertex;
      for (const processKey in processes) {
        const processOptions = preprocessorOptions[processKey];
        fragment = processes[processKey](fragment, processOptions, true);
        vertex = processes[processKey](vertex, processOptions, false);
      }
      this.fragment = fragment;
      this.vertex = vertex;
      this.transformFeedbackVaryings = options.transformFeedbackVaryings;
      this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    /** destroys the program */
    destroy() {
      this.fragment = null;
      this.vertex = null;
      this._attributeData = null;
      this._uniformData = null;
      this._uniformBlockData = null;
      this.transformFeedbackVaryings = null;
    }
    /**
     * Helper function that creates a program for a given source.
     * It will check the program cache if the program has already been created.
     * If it has that one will be returned, if not a new one will be created and cached.
     * @param options - The options for the program.
     * @returns A program using the same source
     */
    static from(options) {
      const key = `${options.vertex}:${options.fragment}`;
      if (!programCache$1[key]) {
        programCache$1[key] = new GlProgram(options);
      }
      return programCache$1[key];
    }
  };
  /** The default options used by the program. */
  GlProgram.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump",
    transformFeedbackVaryings: { names: [], bufferMode: 'separate' | 'interleaved' }
  };

  "use strict";
  const attributeFormatData = {
    uint8x2: { size: 2, stride: 2, normalised: false },
    uint8x4: { size: 4, stride: 4, normalised: false },
    sint8x2: { size: 2, stride: 2, normalised: false },
    sint8x4: { size: 4, stride: 4, normalised: false },
    unorm8x2: { size: 2, stride: 2, normalised: true },
    unorm8x4: { size: 4, stride: 4, normalised: true },
    snorm8x2: { size: 2, stride: 2, normalised: true },
    snorm8x4: { size: 4, stride: 4, normalised: true },
    uint16x2: { size: 2, stride: 4, normalised: false },
    uint16x4: { size: 4, stride: 8, normalised: false },
    sint16x2: { size: 2, stride: 4, normalised: false },
    sint16x4: { size: 4, stride: 8, normalised: false },
    unorm16x2: { size: 2, stride: 4, normalised: true },
    unorm16x4: { size: 4, stride: 8, normalised: true },
    snorm16x2: { size: 2, stride: 4, normalised: true },
    snorm16x4: { size: 4, stride: 8, normalised: true },
    float16x2: { size: 2, stride: 4, normalised: false },
    float16x4: { size: 4, stride: 8, normalised: false },
    float32: { size: 1, stride: 4, normalised: false },
    float32x2: { size: 2, stride: 8, normalised: false },
    float32x3: { size: 3, stride: 12, normalised: false },
    float32x4: { size: 4, stride: 16, normalised: false },
    uint32: { size: 1, stride: 4, normalised: false },
    uint32x2: { size: 2, stride: 8, normalised: false },
    uint32x3: { size: 3, stride: 12, normalised: false },
    uint32x4: { size: 4, stride: 16, normalised: false },
    sint32: { size: 1, stride: 4, normalised: false },
    sint32x2: { size: 2, stride: 8, normalised: false },
    sint32x3: { size: 3, stride: 12, normalised: false },
    sint32x4: { size: 4, stride: 16, normalised: false }
  };
  function getAttributeInfoFromFormat(format) {
    var _a;
    return (_a = attributeFormatData[format]) != null ? _a : attributeFormatData.float32;
  }

  "use strict";
  const WGSL_TO_VERTEX_TYPES = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };

  function extractAttributesFromGpuProgram({ source, entryPoint }) {
    var _a;
    const results = {};
    const mainVertStart = source.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = GPU_STRUCT_REGEX.inputsRegex;
        inputsRegex.lastIndex = 0;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = (_a = WGSL_TO_VERTEX_TYPES[match[3]]) != null ? _a : "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }

  const GPU_STRUCT_REGEX = {
    linePattern: /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
    groupPattern: /@group\((\d+)\)/,
    bindingPattern: /@binding\((\d+)\)/,
    namePattern: /var(<[^>]+>)? (\w+)/,
    typePattern: /:\s*(\w+)/,
    structPattern: /struct\s+(\w+)\s*{([^}]+)}/g,
    structMemberPattern: /(\w+)\s*:\s*([\w\<\>]+)/g,
    structName: /struct\s+(\w+)/,
    inputsRegex: /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g
  }

  "use strict";
  function extractStructAndGroups(wgsl) {
    const linePattern = GPU_STRUCT_REGEX.linePattern;
    const groupPattern = GPU_STRUCT_REGEX.groupPattern;
    const bindingPattern = GPU_STRUCT_REGEX.bindingPattern;
    const namePattern = GPU_STRUCT_REGEX.namePattern;
    const typePattern = GPU_STRUCT_REGEX.typePattern;
    const structPattern = GPU_STRUCT_REGEX.structPattern;
    const structMemberPattern = GPU_STRUCT_REGEX.structMemberPattern;
    const structName = GPU_STRUCT_REGEX.structName;
    const groups = wgsl.match(linePattern);
    const results = [];
    if (groups !== null) {
      for (let i = 0; i < groups.length; i++) {
        const item = groups[i];
        results[results.length] = {
          group: parseInt(item.match(groupPattern)[1], 10),
          binding: parseInt(item.match(bindingPattern)[1], 10),
          name: item.match(namePattern)[2],
          isUniform: item.match(namePattern)[1] === "<uniform>",
          type: item.match(typePattern)[1]
        }
      }
    } else {
      return Array.empty;
    }
    const structs = wgsl.match(structPattern);
    let resultStructs = null;
    if (structs !== null) {
      resultStructs = [];
      for (let i = 0; i < structs.length; i++) {
        const struct = structs[i];
        const name = struct.match(structName)[1];
        const memberTexts = struct.match(structMemberPattern);
        if (memberTexts === null) {
          resultStructs[resultStructs.length] = null;
          continue;
        }
        const members = {};
        for (let j = 0; j < memberTexts.length; j++) {
          const member = memberTexts[j];
          const [name, type] = member.split(":");
          members[name.trim()] = type.trim();
        }
        resultStructs[resultStructs.length] = { name, members };
      }
    } else {
      resultStructs = Array.empty;
    }
    let matched = false;
    for (let i = resultStructs.length - 1; i > -1; i--) {
      const struct = resultStructs[i];
      const name = struct.name;
      matched = false;
      for (let j = 0; j < results.length; j++) {
        const group = results[j];
        if (group.type === name) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        resultStructs.remove(struct, i);
      }
    }
    return {
      groups: results,
      structs: resultStructs
    }
  }

  "use strict";
  var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
    ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
    ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
    ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
    return ShaderStage2;
  })(ShaderStage || {});

  "use strict";
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      const groupIndex = group.group;
      let groupLayout = layout[groupIndex];
      if (!groupLayout) {
        groupLayout = layout[groupIndex] = [];
      }
      if (group.isUniform) {
        groupLayout[groupLayout.length] = {
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        };
      } else if (group.type === "sampler") {
        groupLayout[groupLayout.length] = {
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        };
      } else if (group.type === "texture_2d") {
        groupLayout[groupLayout.length] = {
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        };
      }
    }
    return layout;
  }
  "use strict";
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      const groupIndex = group.group;
      let groupArray = layout[groupIndex];
      if (!layout[group.group]) {
        groupArray = layout[groupIndex] = [];
      }
      const binding = group.binding;
      groupArray[binding] = binding;
    }
    return layout;
  }

  "use strict";
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  function filterStructs(struct) {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  }
  function filterGroups(group) {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  }

  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    structNameSet.clear();
    dupeGroupKeySet.clear();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter(filterStructs);
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter(filterGroups);
    return { structs, groups };
  }

  "use strict";
  const programCache = /* @__PURE__ */ Object.create(null);
  class GpuProgram {
    /**
     * Create a new GpuProgram
     * @param options - The options for the gpu program
     */
    constructor(options) {
      /**
       * @internal
       * @ignore
       */
      this._layoutKey = 0;
      /**
       * @internal
       * @ignore
       */
      this._attributeLocationsKey = 0;
      var _a, _b;
      const { fragment, vertex, layout, gpuLayout, name } = options;
      this.name = name;
      this.fragment = fragment;
      this.vertex = vertex;
      if (fragment.source === vertex.source) {
        const structsAndGroups = extractStructAndGroups(fragment.source);
        this.structsAndGroups = structsAndGroups;
      } else {
        const vertexStructsAndGroups = extractStructAndGroups(vertex.source);
        const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);
        this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
      }
      this.layout = layout != null ? layout : generateLayoutHash(this.structsAndGroups);
      this.gpuLayout = gpuLayout != null ? gpuLayout : generateGpuLayoutGroups(this.structsAndGroups);
      this.autoAssignGlobalUniforms = !!(((_a = this.layout[0]) == null ? void 0 : _a.globalUniforms) !== void 0);
      this.autoAssignLocalUniforms = !!(((_b = this.layout[1]) == null ? void 0 : _b.localUniforms) !== void 0);
      this._generateProgramKey();
    }
    // TODO maker this pure
    _generateProgramKey() {
      const vertex = this.vertex;
      const fragment = this.fragment;
      const bigKey = `${vertex.source}:${fragment.source}:${vertex.entryPoint}:${fragment.entryPoint}`;
      this._layoutKey = createIdFromString(bigKey, "program");
    }
    get attributeData() {
      var _a;
      (_a = this._attributeData) != null ? _a : this._attributeData = extractAttributesFromGpuProgram(this.vertex);
      return this._attributeData;
    }
    /** destroys the program */
    destroy() {
      this.gpuLayout = null;
      this.layout = null;
      this.structsAndGroups = null;
      this.fragment = null;
      this.vertex = null;
    }
    /**
     * Helper function that creates a program for a given source.
     * It will check the program cache if the program has already been created.
     * If it has that one will be returned, if not a new one will be created and cached.
     * @param options - The options for the program.
     * @returns A program using the same source
     */
    static from(options) {
      const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
      if (!programCache[key]) {
        programCache[key] = new GpuProgram(options);
      }
      return programCache[key];
    }
  }

  "use strict";
  const bitsInRegex = /@in\s+[^;]+;\s*/g;
  const bitsOutRegex = /@out\s+[^;]+;\s*/g;
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i in srcParts) {
        const id = i.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i];
          if (i === "header") {
            sanitisedPart = sanitisedPart.replace(bitsInRegex, "").replace(bitsOutRegex, "");
          }
          if (name) {
            part[part.length] = `//----${name}----//`;
          }
          part[part.length] = sanitisedPart;
        } else {
          Logger.warn(`${i} placement hook does not exist in shader`);
        }
      }
    }
  }

  "use strict";
  const findHooksRx = /\{\{(.*?)\}\}/g;
  const findReplaceRegex = /[{()}]/g;
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx);
    if (partMatches === null) {
      return parts;
    }
    for (let i = 0; i < partMatches.length; i++) {
      const hook = partMatches[i];
      const id = hook.replace(findReplaceRegex, "");
      parts[id] = [];
    }
    return parts;
  }

  "use strict";
  const GpuInputRexex = /@in\s+([^;]+);/g;
  const GpuInputReplace = /@in\s+[^;]+;\s*/g;
  function extractInputs(fragmentSource, out) {
    let match;
    const regex = GpuInputRexex;
    regex.lastIndex = 0;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out[out.length] = match[1];
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    for (let i = 0; i < fragments.length; i++) {
      const fragment = fragments[i];
      if (fragment.header) {
        extractInputs(fragment.header, results);
      }
    }
    const mainInput = results;
    if (sort) mainInput.sort();
    let finalString = "";
    for (let i = 0; i < mainInput.length; i++) {
      finalString += `       @location(${i}) ${mainInput[i]},\n`;
    }
    let cleanedString = template.replace(GpuInputReplace, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }

  "use strict";
  const GpuOutputRegex = /@out\s+([^;]+);/g;
  const GpuVariableNameRegex = /\b(\w+)\s*:/g;
  const GpuVariableRegex = /@.*?\s+/g;
  const GpuOutStructRegex = /@out\s+[^;]+;\s*/g;
  function extractOutputs(fragmentSource, out) {
    let match;
    const regex = GpuOutputRegex;
    regex.lastIndex = 0;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out[out.length] = match[1];
    }
  }
  function extractVariableName(value) {
    const regex = GpuVariableNameRegex;
    regex.lastIndex = 0;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = GpuVariableRegex;
    regex.lastIndex = 0;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    for (let i = 0; i < fragments.length; i++) {
      const fragment = fragments[i];
      if (fragment.header) {
        extractOutputs(fragment.header, results);
      }
    }
    results.sort();
    let index = 0;
    let mainStruct = "", mainStart = "", mainEnd = "return VSOutput(";
    for (let i = 0; i < results.length; i++) {
      const inValue = results[i];
      if (inValue.indexOf("builtin") > -1) {
        mainStruct += `${inValue},\n`;
      } else {
        mainStruct += `@location(${index++}) ${inValue},\n`;
      }
      mainStart += `       var ${stripVariable(inValue)};\n`;
      mainEnd += ` ${extractVariableName(inValue)},\n`;
    }
    mainEnd += ");";
    GpuOutStructRegex.lastIndex = 0;
    let compiledCode = template.replace(GpuOutStructRegex, "");
    compiledCode = compiledCode.replace("{{struct}}", `${mainStruct}`);
    compiledCode = compiledCode.replace("{{start}}", `${mainStart}`);
    compiledCode = compiledCode.replace("{{return}}", `${mainEnd}`);
    return compiledCode;
  }

  "use strict";
  function injectBits(templateSrc, fragmentParts) {
    let out = templateSrc;
    for (const i in fragmentParts) {
      const parts = fragmentParts[i];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out = out.replace(`{{${i}}}`, `//-----${i} START-----//
${parts.join("\n")}
//----${i} FINISH----//`);
      } else {
        out = out.replace(`{{${i}}}`, "");
      }
    }
    return out;
  }

  "use strict";
  const cacheMap = /* @__PURE__ */ Object.create(null);
  const bitCacheMap = /* @__PURE__ */ new Map();
  let CACHE_UID = 0;

  function compileHighShader(template, bits) {
    const cacheId = generateCacheId(template, bits);
    let shader = cacheMap[cacheId];
    if (shader !== void 0) return shader;
    const { vertex, fragment } = compileInputsAndOutputs(template, bits);
    shader = cacheMap[cacheId] = compileBits(vertex, fragment, bits);
    return shader;
  }
  function compileHighShaderGl(template, bits) {
    const cacheId = generateCacheId(template, bits);
    let shader = cacheMap[cacheId];
    if (shader !== void 0) return shader;
    shader = cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return shader;
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = [];
    const fragmentFragments = [];
    let vx = 0, fx = 0;
    for (let i = 0; i < bits.length; i++) {
      const shaderBit = bits[i];
      const vertex = shaderBit.vertex;
      const fragment = shaderBit.fragment;
      if (vertex) {
        vertexFragments[vx++] = vertex;
      }
      if (fragment) {
        fragmentFragments[fx++] = fragment;
      }
    }
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    let result = "";
    for (let i = 0; i < bits.length; i++) {
      const highFragment = bits[i];
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      result += `${bitCacheMap.get(highFragment)}-`;
    }
    return `${result}${template.vertex}${template.fragment}`;
  }

  function compileBits(vertex, fragment, bits) {
    const vertexParts = compileHooks(vertex);
    const fragmentParts = compileHooks(fragment);
    for (let i = 0; i < bits.length; i++) {
      const shaderBit = bits[i];
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    }
    return {
      vertex: injectBits(vertex, vertexParts),
      fragment: injectBits(fragment, fragmentParts)
    };
  }

  "use strict";
  const vertexGPUTemplate = (
    /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
  );
  const fragmentGPUTemplate = (
    /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
  );
  const vertexGlTemplate = (
    /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
  );
  const fragmentGlTemplate = (
    /* glsl */
    `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`
  );

  "use strict";
  const globalUniformsBit = {
    name: "global-uniforms-bit",
    vertex: {
      header: (
        /* wgsl */
        `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
      )
    }
  };
  const globalUniformsUBOBitGl = {
    name: "global-uniforms-ubo-bit",
    vertex: {
      header: (
        /* glsl */
        `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `
      )
    }
  };
  const globalUniformsBitGl = {
    name: "global-uniforms-bit",
    vertex: {
      header: (
        /* glsl */
        `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
      )
    }
  };

  "use strict";
  var __defProp$Z = Object.defineProperty;
  var __getOwnPropSymbols$Z = Object.getOwnPropertySymbols;
  var __hasOwnProp$Z = Object.prototype.hasOwnProperty;
  var __propIsEnum$Z = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$Z = (obj, key, value) => key in obj ? __defProp$Z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$Z = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$Z.call(b, prop))
        __defNormalProp$Z(a, prop, b[prop]);
    if (__getOwnPropSymbols$Z)
      for (var prop of __getOwnPropSymbols$Z(b)) {
        if (__propIsEnum$Z.call(b, prop))
          __defNormalProp$Z(a, prop, b[prop]);
      }
    return a;
  };
  function compileHighShaderGpuProgram(bits, name) {
    const source = compileHighShader(
      {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      [
        globalUniformsBit,
        ...bits
      ]
    );
    return GpuProgram.from({
      name,
      vertex: {
        source: source.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram(bits, name) {
    return GlProgram.from(__spreadValues$Z({
      name
    }, compileHighShaderGl(
      {
        vertex: vertexGlTemplate, fragment: fragmentGlTemplate
      },
      [
        globalUniformsBitGl,
        ...bits
      ]
    )));
  }

  "use strict";
  const colorBit = {
    name: "color-bit",
    vertex: {
      header: (
        /* wgsl */
        `
            @in aColor: vec4<f32>;
        `
      ),
      main: (
        /* wgsl */
        `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
      )
    }
  };
  const colorBitGl = {
    name: "color-bit",
    vertex: {
      header: (
        /* glsl */
        `
            in vec4 aColor;
        `
      ),
      main: (
        /* glsl */
        `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
      )
    }
  };

  "use strict";
  const textureBatchBitGpuCache = {};
  function generateBindingSrc(maxTextures) {
    let src = "";
    if (maxTextures === 1) {
      src += "@group(1) @binding(0) var textureSource1: texture_2d<f32>;\n";
      src += "@group(1) @binding(1) var textureSampler1: sampler;\n";
    } else {
      let bindingIndex = 0;
      for (let i = 0; i < maxTextures; i++) {
        src += `@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;\n`;
        src += `@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;\n`;
      }
    }
    return src;
  }
  function generateSampleSrc(maxTextures) {
    let src = "";
    if (maxTextures === 1) {
      src += "outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\n";
    } else {
      src += "switch vTextureId {\n";
      for (let i = 0; i < maxTextures; i++) {
        if (i === maxTextures - 1) {
          src += `  default:{\n`;
        } else {
          src += `  case ${i}:{\n`;
        }
        src += `      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);\n`;
        src += `      break;}\n`;
      }
      src += `}\n`;
    }
    return src;
  }
  function generateTextureBatchBit(maxTextures) {
    if (!textureBatchBitGpuCache[maxTextures]) {
      textureBatchBitGpuCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures];
  }
  exports.generateBindingSrc = generateBindingSrc;
  exports.generateSampleSrc = generateSampleSrc;
  const textureBatchBitGlCache = {};
  function generateSampleGlSrc(maxTextures) {
    const src = [];
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src.push("else");
      }
      if (i < maxTextures - 1) {
        src.push(`if(vTextureId < ${i}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures) {
    if (!textureBatchBitGlCache[maxTextures]) {
      textureBatchBitGlCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures];
  }

  "use strict";
  const roundPixelsBit = {
    name: "round-pixels-bit",
    vertex: {
      header: (
        /* wgsl */
        `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
      )
    }
  };
  const roundPixelsBitGl = {
    name: "round-pixels-bit",
    vertex: {
      header: (
        /* glsl */
        `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
      )
    }
  };

  "use strict";
  const UNIFORM_TYPES_VALUES = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    'mat3x4<f32>',
    'vec2<i32>',
    'vec3<i32>',
    'vec4<i32>',
  ];
  const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
    acc[type] = true;
    return acc;
  }, {});

  "use strict";
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }

  "use strict";
  var __defProp$Y = Object.defineProperty;
  var __getOwnPropSymbols$Y = Object.getOwnPropertySymbols;
  var __hasOwnProp$Y = Object.prototype.hasOwnProperty;
  var __propIsEnum$Y = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$Y = (obj, key, value) => key in obj ? __defProp$Y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$Y = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$Y.call(b, prop))
        __defNormalProp$Y(a, prop, b[prop]);
    if (__getOwnPropSymbols$Y)
      for (var prop of __getOwnPropSymbols$Y(b)) {
        if (__propIsEnum$Y.call(b, prop))
          __defNormalProp$Y(a, prop, b[prop]);
      }
    return a;
  };
  class UniformGroup {
    /**
     * Create a new Uniform group
     * @param uniformStructures - The structures of the uniform group
     * @param options - The optional parameters of this uniform group
     */
    constructor(uniformStructures, options = UniformGroup.defaultOptions) {
      /** used internally to know if a uniform group was used in the last render pass */
      this._touched = 0;
      /** a unique id for this uniform group used through the renderer */
      this.uid = uid$1("uniform");
      /** a resource type, used to identify how to handle it when its in a bind group / shader resource */
      this._resourceType = "uniformGroup";
      /** the resource id used internally by the renderer to build bind group keys */
      this._resourceId = uid$1("resource");
      /** used ito identify if this is a uniform group */
      this.isUniformGroup = true;
      /**
       * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU
       * @internal
       * @ignore
       */
      this._dirtyId = 0;
      // implementing the interface - UniformGroup are not destroyed
      this.destroyed = false;
      var _a, _b;
      this.uniformStructures = uniformStructures;
      const uniforms = {};
      let signature = "";
      for (const i in uniformStructures) {
        const uniformData = uniformStructures[i];
        uniformData.name = i;
        uniformData.size = (_a = uniformData.size) != null ? _a : 1;
        if (!UNIFORM_TYPES_MAP[uniformData.type]) {
          throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
        }
        (_b = uniformData.value) != null ? _b : uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size);
        uniforms[i] = uniformData.value;
        signature += `${i}-${uniformData.type}`;
      }
      this.uniforms = uniforms;
      this._dirtyId = 1;
      this.ubo = options.ubo || UniformGroup.defaultOptions.ubo;
      this.isStatic = options.isStatic || UniformGroup.defaultOptions.isStatic;
      this._signature = createIdFromString(signature, "uniform-group");
      this._bindGroup = null;
      this.buffer = null;
    }
    on = Function.empty;
    off = Function.empty;
    clearListener = Function.empty;
    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
    update() {
      this._dirtyId++;
    }
  };
  /** The default options used by the uniform group. */
  UniformGroup.defaultOptions = {
    /** if true the UniformGroup is handled as an Uniform buffer object. */
    ubo: false,
    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
    isStatic: false
  };

  "use strict";
  const batchSamplersUniformGroupHash = {};
  function getBatchSamplersUniformGroup(maxTextures) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures);
    for (let i = 0; i < maxTextures; i++) {
      sampleValues[i] = i;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
      uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
    }, { isStatic: true });
    return batchSamplersUniformGroup;
  }

  "use strict";
  var RendererType = /* @__PURE__ */ ((RendererType2) => {
    RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
    RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
    RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
    return RendererType2;
  })(RendererType || {});

  "use strict";
  var __defProp$X = Object.defineProperty;
  var __getOwnPropSymbols$X = Object.getOwnPropertySymbols;
  var __hasOwnProp$X = Object.prototype.hasOwnProperty;
  var __propIsEnum$X = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$X = (obj, key, value) => key in obj ? __defProp$X(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$X = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$X.call(b, prop))
        __defNormalProp$X(a, prop, b[prop]);
    if (__getOwnPropSymbols$X)
      for (var prop of __getOwnPropSymbols$X(b)) {
        if (__propIsEnum$X.call(b, prop))
          __defNormalProp$X(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest$k = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$X.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$X)
      for (var prop of __getOwnPropSymbols$X(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$X.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class Shader extends EventEmitter {
    constructor(options) {
      super();
      this._uniformBindMap = Object.create(null);
      this._ownedBindGroups = [];
      this.uid = uid$1("shader");
      const isWebgl = Engine.renderer.type === RendererType.WEBGL;
      let {
        gpuProgram,
        glProgram,
        resources,
      } = options;
      this.gpuProgram = gpuProgram;
      this.glProgram = glProgram;
      const groups = {};
      const groupMap = this._uniformBindMap;
      if (resources) {
        const ownedBindGroups = this._ownedBindGroups;
        if (isWebgl) {
          let bindTick = 0;
          const group = groups[99] = BindGroupPool.get();
          ownedBindGroups.push(groups[99]);
          groupMap[99] = Object.create(null);
          for (const key in resources) {
            let value = resources[key];
            if (!value.isTextureSource && !value._resourceType) {
              value = new UniformGroup(value);
            }
            const bindIndex = bindTick++;
            group.setResource(value, bindIndex);
            groupMap[99][bindIndex] = key;
          }
        } else {
          const nameHash = {};
          const groupData = gpuProgram.structsAndGroups.groups;
          for (let i = 0; i < groupData.length; i++) {
            const data = groupData[i];
            const group = data.group;
            const binding = data.binding;
            const name = data.name;
            groupMap[group] = groupMap[group] || Object.create(null);
            groupMap[group][binding] = name;
            nameHash[name] = data;
          }
          for (const i in resources) {
            let value = resources[i];
            if (!value.isTextureSource && !value._resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[i];
            if (data) {
              const group = data.group;
              const binding = data.binding;
              let bindGroup = groups[group];
              if (!bindGroup) {
                bindGroup = groups[group] = BindGroupPool.get();
                ownedBindGroups.push(bindGroup);
              }
              bindGroup.setResource(value, binding);
            }
          }
        }
      }
      this.groups = groups;
    }
    updateGlUniformGroup(shaderSystem, renderer) {
      shaderSystem.updateUniformGroup(renderer.globalUniforms._currentGlobalUniformData.bindGroup.resources[0]);
    }
    updateGpuUniformGroup(encoderSystem, renderer, program) {
      const globalUniformsBindGroup = renderer.globalUniforms._currentGlobalUniformData.bindGroup;
      encoderSystem.setBindGroup(0, globalUniformsBindGroup, program, renderer.bindGroup);
    }
    /**
     * Sometimes a resource group will be provided later (for example global uniforms)
     * In such cases, this method can be used to let the shader know about the group.
     * @param name - the name of the resource group
     * @param groupIndex - the index of the group (should match the webGPU shader group location)
     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
     */
    addResource(name, groupIndex, bindIndex) {
      const uniformBindMap = this._uniformBindMap;
      const groups = this.groups;
      let bindMap = uniformBindMap[groupIndex];
      if (bindMap === void 0) {
        bindMap = uniformBindMap[groupIndex] = {};
      }
      bindMap[bindIndex] = name;
      let group = groups[groupIndex];
      if (!group) {
        group = groups[groupIndex] = BindGroupPool.get();
        this._ownedBindGroups.push(group);
      }
    }
    /**
     * Use to destroy the shader when its not longer needed.
     * It will destroy the resources and remove listeners.
     * @param destroyPrograms - if the programs should be destroyed as well.
     * Make sure its not being used by other shaders!
     */
    destroy(destroyPrograms = false) {
      var _a, _b;
      this.emit("destroy", this);
      if (destroyPrograms) {
        (_a = this.gpuProgram) == null ? void 0 : _a.destroy();
        (_b = this.glProgram) == null ? void 0 : _b.destroy();
      }
      this.gpuProgram = null;
      this.glProgram = null;
      this.removeAllListeners();
      this._uniformBindMap = null;
      const ownedBindGroups = this.ownedBindGroups;
      for (let i = 0; i < ownedBindGroups.length; i++) {
        BindGroupPool.return(ownedBindGroups[i]);
      }
      this._ownedBindGroups = null;
      this.resources = null;
      this.groups = null;
    }
    static from(options) {
      const _a = options, { gpu, gl } = _a, rest = __objRest$k(_a, ["gpu", "gl"]);
      let gpuProgram;
      let glProgram;
      if (gpu) {
        gpuProgram = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram = GlProgram.from(gl);
      }
      return new Shader(__spreadValues$X({
        gpuProgram,
        glProgram
      }, rest));
    }
  }

  "use strict";
  class DefaultShader extends Shader {
    constructor(maxTextures) {
      const glProgram = compileHighShaderGlProgram(
        [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          roundPixelsBitGl
        ],
        "batch"
      );
      const gpuProgram = compileHighShaderGpuProgram(
        [
          colorBit,
          generateTextureBatchBit(maxTextures),
          roundPixelsBit
        ]
        , "batch"
      );
      super({
        glProgram,
        gpuProgram,
        resources: {
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  }

  "use strict";
  class DefaultBatcher extends Batcher {
    constructor(options = Batcher.defaultOptions) {
      super(options);
      this.geometry = new BatchGeometry();
      this.shader = options.shader;
      this.name = "default";
      /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */
      this.vertexSize = 6;
    }
    /**
     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
     * @param element - The DefaultBatchableMeshElement to pack.
     * @param float32View - The Float32Array view to pack into.
     * @param uint32View - The Uint32Array view to pack into.
     * @param index - The starting index in the views.
     * @param textureId - The texture ID to use.
     */
    packAttributes(element, float32View, uint32View, index, textureId) {
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      const wt = element.transform;
      const a = wt.a;
      const b = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const positions = element.positions;
      const uvs = element.uvs;
      const argb = element.renderable.groupColorAlpha;
      const offset = element.attributeOffset;
      const end = offset + element.attributeSize;
      for (let i = offset; i < end; i++) {
        const i2 = i * 2;
        const x = positions[i2];
        const y = positions[i2 + 1];
        float32View[index++] = a * x + c * y + tx;
        float32View[index++] = d * y + b * x + ty;
        float32View[index++] = uvs[i2];
        float32View[index++] = uvs[i2 + 1];
        uint32View[index++] = argb;
        uint32View[index++] = textureIdAndRound;
      }
    }
    /**
     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
     * @param element - The DefaultBatchableQuadElement to pack.
     * @param float32View - The Float32Array view to pack into.
     * @param uint32View - The Uint32Array view to pack into.
     * @param index - The starting index in the views.
     * @param textureId - The texture ID to use.
     */
    packQuadAttributes(element, float32View, uint32View, index, textureId) {
      const texture = element.texture;
      const wt = element.transform;
      const a = wt.a;
      const b = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const bounds = element.bounds;
      const w0 = bounds.maxX;
      const w1 = bounds.minX;
      const h0 = bounds.maxY;
      const h1 = bounds.minY;
      const uvs = texture.uvs;
      const argb = element.renderable.groupColorAlpha;
      const ux0 = uvs[0];
      const uy0 = uvs[1];
      const ux1 = uvs[2];
      const uy1 = uvs[3];
      const ux2 = uvs[4];
      const uy2 = uvs[5];
      const ux3 = uvs[6];
      const uy3 = uvs[7];
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      float32View[index + 0] = a * w1 + c * h1 + tx;
      float32View[index + 1] = d * h1 + b * w1 + ty;
      float32View[index + 2] = ux0;
      float32View[index + 3] = uy0;
      uint32View[index + 4] = argb;
      uint32View[index + 5] = textureIdAndRound;
      float32View[index + 6] = a * w0 + c * h1 + tx;
      float32View[index + 7] = d * h1 + b * w0 + ty;
      float32View[index + 8] = ux1;
      float32View[index + 9] = uy1;
      uint32View[index + 10] = argb;
      uint32View[index + 11] = textureIdAndRound;
      float32View[index + 12] = a * w0 + c * h0 + tx;
      float32View[index + 13] = d * h0 + b * w0 + ty;
      float32View[index + 14] = ux2;
      float32View[index + 15] = uy2;
      uint32View[index + 16] = argb;
      uint32View[index + 17] = textureIdAndRound;
      float32View[index + 18] = a * w1 + c * h0 + tx;
      float32View[index + 19] = d * h0 + b * w1 + ty;
      float32View[index + 20] = ux3;
      float32View[index + 21] = uy3;
      uint32View[index + 22] = argb;
      uint32View[index + 23] = textureIdAndRound;
    }
  };
  /** @ignore */
  DefaultBatcher.extension = {
    type: [
      ExtensionType.Batcher
    ],
    name: "default"
  };

  "use strict";
  function transformVertices(vertices, m, offset, stride, size) {
    const a = m.a;
    const b = m.b;
    const c = m.c;
    const d = m.d;
    const tx = m.tx;
    const ty = m.ty;
    offset = offset || 0;
    stride = stride || 2;
    size = size || vertices.length / stride - offset;
    let index = offset * stride;
    for (let i = 0; i < size; i++) {
      const x = vertices[index];
      const y = vertices[index + 1];
      vertices[index] = a * x + c * y + tx;
      vertices[index + 1] = b * x + d * y + ty;
      index += stride;
    }
  }

  "use strict";
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r = ((r1 * r2) / 255) | 0;
    const g = ((g1 * g2) / 255) | 0;
    const b = ((b1 * b2) / 255) | 0;
    return (r << 16) + (g << 8) + b;
  }

  function multiplyColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR) {
      return parentBGRColor;
    }

    if (parentBGRColor === WHITE_BGR) {
      return localBGRColor;
    }

    return multiplyHexColors(localBGRColor, parentBGRColor);
  }

  "use strict";
  const closePointEps = 1e-4;
  const curveEps = 1e-4;

  "use strict";
  function getOrientationOfPoints(points) {
    const m = points.length;
    if (m < 6) {
      return 1;
    }
    let area = 0;
    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
      const x2 = points[i];
      const y2 = points[i + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }

  "use strict";
  const blendModeIds = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8,
    min: 9,
    max: 10
  };
  const BLEND$1 = 0;
  const OFFSET$1 = 1;
  const CULLING$1 = 2;
  const DEPTH_TEST$1 = 3;
  const WINDING$1 = 4;
  const DEPTH_MASK$1 = 5;
  class State {
    constructor() {
      this.data = 0;
      this.blendMode = "normal";
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    /**
     * Activates blending of the computed fragment color values.
     * @default true
     */
    get blend() {
      return !!(this.data & 1 << BLEND$1);
    }
    set blend(value) {
      if (!!(this.data & 1 << BLEND$1) !== value) {
        this.data ^= 1 << BLEND$1;
      }
    }
    /**
     * Activates adding an offset to depth values of polygon's fragments
     * @default false
     */
    get offsets() {
      return !!(this.data & 1 << OFFSET$1);
    }
    set offsets(value) {
      if (!!(this.data & 1 << OFFSET$1) !== value) {
        this.data ^= 1 << OFFSET$1;
      }
    }
    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
    set cullMode(value) {
      if (value === "none") {
        this.culling = false;
        return;
      }
      this.culling = true;
      this.clockwiseFrontFace = value === "front";
    }
    get cullMode() {
      if (!this.culling) {
        return "none";
      }
      return this.clockwiseFrontFace ? "front" : "back";
    }
    /**
     * Activates culling of polygons.
     * @default false
     */
    get culling() {
      return !!(this.data & 1 << CULLING$1);
    }
    set culling(value) {
      if (!!(this.data & 1 << CULLING$1) !== value) {
        this.data ^= 1 << CULLING$1;
      }
    }
    /**
     * Activates depth comparisons and updates to the depth buffer.
     * @default false
     */
    get depthTest() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    }
    set depthTest(value) {
      if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
        this.data ^= 1 << DEPTH_TEST$1;
      }
    }
    /**
     * Enables or disables writing to the depth buffer.
     * @default true
     */
    get depthMask() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    }
    set depthMask(value) {
      if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
        this.data ^= 1 << DEPTH_MASK$1;
      }
    }
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @default false
     */
    get clockwiseFrontFace() {
      return !!(this.data & 1 << WINDING$1);
    }
    set clockwiseFrontFace(value) {
      if (!!(this.data & 1 << WINDING$1) !== value) {
        this.data ^= 1 << WINDING$1;
      }
    }
    /**
     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     * @default 'normal'
     */
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(value) {
      this.blend = value !== "none";
      this._blendMode = value;
      this._blendModeId = blendModeIds[value] || 0;
    }
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     * @default 0
     */
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    }
    toString() {
      return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    /**
     * A quickly getting an instance of a State that is configured for 2d rendering.
     * @returns a new State with values set for 2d rendering
     */
    static for2d() {
      const state = new State();
      state.depthTest = false;
      state.blend = true;
      return state;
    }
  };
  State.default2d = State.for2d();

  "use strict";
  function colorToUniform(rgb, alpha, out, offset) {
    out[offset++] = (rgb >> 16 & 255) / 255;
    out[offset++] = (rgb >> 8 & 255) / 255;
    out[offset++] = (rgb & 255) / 255;
    out[offset++] = alpha;
  }
  function color32BitToUniform(abgr, out, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out[offset++] = (abgr & 255) / 255 * alpha;
    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out[offset++] = alpha;
  }

  "use strict";
  class BatchableMesh {
    constructor() {
      /**
       * @type {MeshGeometry|null}
       */
      this.geometry = null;
      this.batcherName = "default";
      this.packAsQuad = false;
      this.indexOffset = 0;
      this.attributeOffset = 0;
      this.roundPixels = 0;
      this._batcher = null;
      this._batch = null;
      this._uvUpdateId = -1;
      this._textureMatrixUpdateId = -1;
    }
    setTexture(value) {
      if (this.texture === value) return;
      this.texture = value;
      this._textureMatrixUpdateId = -1;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    reset() {
      this.attributeOffset = 0;
      this.indexOffset = 0;
      this.roundPixels = 0;
      this.renderable = null;
      this.texture = null;
      this._batcher = null;
      this._batch = null;
      this.geometry = returnPoolObject(this.geometry);
      this.geometry = null;
      this._uvUpdateId = -1;
      this._textureMatrixUpdateId = -1;
    }
    get uvs() {
      const geometry = this.geometry;
      const uvBuffer = geometry.getBuffer("aUV");
      const uvs = uvBuffer._data;
      const textureMatrix = this.texture._textureMatrix;
      if (!textureMatrix.isSimple) {
        if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
          this._textureMatrixUpdateId = textureMatrix._updateID;
          this._uvUpdateId = uvBuffer._updateID;
          textureMatrix.multiplyUvs(uvs);
        }
      }
      return uvs;
    }
    get positions() {
      return this.geometry.attributes.aPosition.buffer._data;
    }
    get indices() {
      return this.geometry.indexBuffer._data;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    get groupTransform() {
      return this.renderable.groupTransform;
    }
    get attributeSize() {
      return this.geometry.attributes.aPosition.buffer._data.length / 2;
    }
    get indexSize() {
      return this.geometry.indexBuffer._data.length;
    }
  }

  "use strict";
  class MeshGpuData {
    constructor() {
      this.batched = true;
      this.indexSize = void 0;
      this.vertexSize = void 0;
      this.batchableMesh = null;
    }
  }
  class MeshPipe {
    constructor(renderer, adaptor) {
      this.localUniforms = new UniformGroup({
        uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 0, type: "f32" }
      });
      this.localUniformsBindGroup = new BindGroup({
        0: this.localUniforms
      });
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init();
    }
    validateRenderable(mesh) {
      const meshData = this._getMeshData(mesh);
      const wasBatched = meshData.batched;
      const isBatched = mesh.batched;
      meshData.batched = isBatched;
      if (wasBatched !== isBatched) {
        return true;
      } else if (isBatched) {
        const geometry = mesh._geometry;
        const attributes = geometry.attributes;
        const indices = geometry.indexBuffer._data;
        const positions = attributes.aPosition.buffer._data;
        if (indices.length !== meshData.indexSize || positions.length !== meshData.vertexSize) {
          meshData.indexSize = indices.length;
          meshData.vertexSize = positions.length;
          return true;
        }
        const batchableMesh = this._getBatchableMesh(mesh);
        if (batchableMesh.texture.uid !== mesh._texture.uid) {
          batchableMesh._textureMatrixUpdateId = -1;
        }
        return !checkAndUpdateTexture(batchableMesh, mesh._texture);
      }
      return false;
    }
    addRenderable(mesh, instructionSet) {
      const batcher = this.renderer.renderPipes.batch;
      const batched = this._getMeshData(mesh).batched;
      if (batched) {
        const gpuBatchableMesh = this._getBatchableMesh(mesh);
        gpuBatchableMesh.setTexture(mesh._texture);
        gpuBatchableMesh.geometry = mesh._geometry;
        batcher.addToBatch(gpuBatchableMesh, instructionSet);
      } else {
        batcher.break(instructionSet);
        instructionSet.add(mesh);
      }
    }
    updateRenderable(mesh) {
      if (mesh.batched) {
        const gpuBatchableMesh = this._getBatchableMesh(mesh);
        gpuBatchableMesh.setTexture(mesh._texture);
        gpuBatchableMesh.geometry = mesh._geometry;
        gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
      }
    }
    execute(mesh) {
      if (!mesh.isRenderable) return;
      mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
      const localUniforms = this.localUniforms;
      localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
      localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
      localUniforms.update();
      color32BitToUniform(
        mesh.groupColorAlpha,
        localUniforms.uniforms.uColor,
        0
      );
      this._adaptor.execute(this, mesh);
    }
    _getMeshData(mesh) {
      return mesh._gpuData || this._initMeshData(mesh);
    }
    _initMeshData(mesh) {
      const gpuData = new MeshGpuData();
      gpuData.batched = mesh.batched;
      const attributes = mesh._geometry.attributes;
      const indices = mesh._geometry.indexBuffer._data;
      const positions = attributes.aPosition.buffer._data;
      gpuData.indexSize = indices ? indices.length : 0;
      gpuData.vertexSize = positions ? positions.length : 0;
      mesh._gpuData = gpuData;
      return gpuData;
    }
    _getBatchableMesh(mesh) {
      return mesh._gpuData.batchableMesh || this._initBatchableMesh(mesh);
    }
    _initBatchableMesh(mesh) {
      const gpuMesh = new BatchableMesh();
      gpuMesh.renderable = mesh;
      gpuMesh.setTexture(mesh._texture);
      gpuMesh.transform = mesh.groupTransform;
      gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
      mesh._gpuData.batchableMesh = gpuMesh;
      return gpuMesh;
    }
    destroy() {
      this.localUniforms = null;
      this.localUniformsBindGroup = null;
      this._adaptor.destroy();
      this._adaptor = null;
      this.renderer = null;
    }
  }
  /** @ignore */
  MeshPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "mesh"
  };

  "use strict";
  extensions.add(MeshPipe);

  "use strict";
  class GlParticleContainerAdaptor {
    execute(particleContainerPipe, container) {
      const state = particleContainerPipe.state;
      const renderer = particleContainerPipe.renderer;
      const shader = container.shader || particleContainerPipe.defaultShader;
      const shaderBindGroup = shader.groups[99];
      shaderBindGroup.setResource(container.texture._source, 0);
      const gl = renderer.gl;
      const buffer = particleContainerPipe.getBuffers(container);
      renderer.shader.bind(shader);
      renderer.state.set(state);
      renderer.geometry.bind(buffer.geometry, shader.glProgram);
      const byteSize = buffer.geometry.indexBuffer._data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
    }
  }

  "use strict";
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (totalIndices > 65535) {
      outBuffer = outBuffer || new Uint32Array(totalIndices);
    } else {
      outBuffer = outBuffer || new Uint16Array(totalIndices);
    }
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
      outBuffer[i + 0] = j + 0;
      outBuffer[i + 1] = j + 1;
      outBuffer[i + 2] = j + 2;
      outBuffer[i + 3] = j + 0;
      outBuffer[i + 4] = j + 2;
      outBuffer[i + 5] = j + 3;
    }
    return outBuffer;
  }

  "use strict";
  function generateParticleUpdateFunction(properties) {
    return {
      dynamicUpdate: generateUpdateFunction(properties, true),
      staticUpdate: generateUpdateFunction(properties, false)
    };
  }
  function generateUpdateFunction(properties, dynamic) {
    let funcSource = "";
    funcSource += `
        var index = 0;
        for (let i = 0; i < ps.length; ++i){
            const p = ps[i];
            `;
    if (dynamic) {
      funcSource += `p.update();\n`;
    }
    let offset = 0;
    for (const i in properties) {
      const property = properties[i];
      if (dynamic !== property.dynamic)
        continue;
      funcSource += `offset = index + ${offset}`;
      funcSource += property.code;
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      offset += attributeInfo.stride / 4;
    }
    funcSource += `
            index += stride * 4;
        }
    `;
    const funckeys = `
      var stride = ${offset};
      ${funcSource}
  `;
    return new Function("ps", "f32v", "u32v", funckeys);
  }

  "use strict";
  class ParticleBuffer {
    static _generateParticleUpdateCache = {};
    constructor(options) {
      this._size = 0;
      var _a;
      const size = this._size = (_a = options.size) != null ? _a : 1e3;
      const properties = options.properties;
      let staticVertexSize = 0;
      let dynamicVertexSize = 0;
      for (const i in properties) {
        const property = properties[i];
        const attributeInfo = getAttributeInfoFromFormat(property.format);
        if (property.dynamic) {
          dynamicVertexSize += attributeInfo.stride;
        } else {
          staticVertexSize += attributeInfo.stride;
        }
      }
      this._dynamicVertexSize = dynamicVertexSize;
      this._staticVertexSize = staticVertexSize;
      this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
      this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
      this.indexBuffer = createIndicesForQuads(size);
      const geometry = new Geometry();
      let dynamicOffset = 0;
      let staticOffset = 0;
      this._staticBuffer = new Buffer({
        data: new Float32Array(1),
        label: "static-particle-buffer",
        shrinkToFit: false,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      this._dynamicBuffer = new Buffer({
        data: new Float32Array(1),
        label: "dynamic-particle-buffer",
        shrinkToFit: false,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      for (const i in properties) {
        const property = properties[i];
        const attributeInfo = getAttributeInfoFromFormat(property.format);
        if (property.dynamic) {
          geometry.addAttribute(property.attributeName, {
            buffer: this._dynamicBuffer,
            stride: dynamicVertexSize,
            offset: dynamicOffset * 4,
            format: property.format
          });
          dynamicOffset += attributeInfo.size;
        } else {
          geometry.addAttribute(property.attributeName, {
            buffer: this._staticBuffer,
            stride: staticVertexSize,
            offset: staticOffset * 4,
            format: property.format
          });
          staticOffset += attributeInfo.size;
        }
      }
      geometry.addIndex(this.indexBuffer);
      const uploadFunction = this.getParticleUpdate(properties);
      this._dynamicUpload = uploadFunction.dynamicUpdate;
      this._staticUpload = uploadFunction.staticUpdate;
      this.geometry = geometry;
    }
    getParticleUpdate(properties) {
      const key = getParticleSyncKey(properties);
      const cache = ParticleBuffer._generateParticleUpdateCache;
      if (cache[key]) {
        return cache[key];
      }
      cache[key] = this.generateParticleUpdate(properties);
      return cache[key];
    }
    generateParticleUpdate(properties) {
      return generateParticleUpdateFunction(properties);
    }
    update(particles, uploadStatic) {
      const particlesSize = particles.length;
      if (particlesSize > this._size) {
        uploadStatic = true;
        this._size = Math.max(particlesSize, this._size * 2 | 0);
        this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticVertexSize * 4);
        this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicVertexSize * 4);
        const indexBuffer = this.indexBuffer = createIndicesForQuads(this._size);
        this.geometry.indexBuffer.setDataWithSize(
          indexBuffer,
          indexBuffer.byteLength,
          true
        );
      }
      const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
      this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
      this._dynamicBuffer.setDataWithSize(
        this.dynamicAttributeBuffer.float32View,
        particlesSize * this._dynamicVertexSize,
        true
      );
      if (uploadStatic) {
        const staticAttributeBuffer = this.staticAttributeBuffer;
        this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
        this._staticBuffer.setDataWithSize(
          staticAttributeBuffer.float32View,
          particlesSize * this._staticVertexSize,
          true
        );
      }
    }
    destroy() {
      this._staticBuffer.destroy();
      this._dynamicBuffer.destroy();
      this.geometry.destroy(true);
    }
  }
  function getParticleSyncKey(properties) {
    let keys = "";
    for (const key in properties) {
      const property = properties[key];
      keys += `${key}${property.code}${property.dynamic ? "d" : "s"}_`;
    }
    return keys;
  }

  var fragment$5 = `
in vec2 vUV;
in vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color=texture(uTexture,vUV)*vColor;
    finalColor=color;
}`;

  var vertex$3 = `
in vec2 aVertex;
in vec2 aUV;
in vec4 aColor;

in vec2 aPosition;
in float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

out vec2 vUV;
out vec4 vColor;

void main(void){
    float cosRotation=cos(aRotation);
    float sinRotation=sin(aRotation);
    float x=aVertex.x*cosRotation-aVertex.y*sinRotation;
    float y=aVertex.x*sinRotation+aVertex.y*cosRotation;
    vec2 v=vec2(x,y);
    v=v+aPosition;
    gl_Position=vec4((uTranslationMatrix*vec3(v,1.)).xy,0.,1.);
    vUV=aUV;
    vColor=aColor*uColor;
}`

  var wgsl = `
  struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);
   let vColor = aColor * uniforms.uColor;
  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {
    var sample = textureSample(uTexture, uSampler, uv) * color;
    return sample;
}`

  "use strict";
  class ParticleShader extends Shader {
    constructor(uniformGroup) {
      const glProgram = GlProgram.from({
        vertex: vertex$3,
        fragment: fragment$5
      });
      const gpuProgram = GpuProgram.from({
        fragment: {
          source: wgsl,
          entryPoint: "mainFragment"
        },
        vertex: {
          source: wgsl,
          entryPoint: "mainVertex"
        }
      });
      super({
        glProgram,
        gpuProgram,
        resources: {
          // this will be replaced with the texture from the particle container
          uTexture: Texture.WHITE._source,
          // this will be replaced with the texture style from the particle container
          uSampler: TextureStyle.EMPTY,
          // this will be replaced with the local uniforms from the particle container
          uniforms: uniformGroup
        }
      });
    }
  }

  "use strict";
  class ParticleContainerPipe {
    /**
     * @param renderer - The renderer this sprite batch works for.
     * @param adaptor
     */
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this.createUniformGroup();
      this.renderer = renderer;
      this.adaptor = adaptor;
      this.defaultShader = new ParticleShader(this.localUniforms);
    }
    createUniformGroup() {
      this.localUniforms = new UniformGroup({
        uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 1, type: "f32" },
        uResolution: { value: [0, 0], type: "vec2<f32>" }
      });
    }
    validateRenderable(_renderable) {
      return false;
    }
    addRenderable(renderable, instructionSet) {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(renderable);
    }
    getBuffers(renderable) {
      return renderable._gpuData || this._initBuffer(renderable);
    }
    _initBuffer(renderable) {
      renderable._gpuData = new ParticleBuffer({
        size: renderable.particleChildren.length,
        properties: renderable._properties
      });
      return renderable._gpuData;
    }
    updateRenderable(_renderable) {
    }
    execute(container) {
      const children = container.particleChildren;
      if (children.length === 0) return;
      const renderer = this.renderer;
      const buffer = this.getBuffers(container);
      const state = this.state;
      buffer.update(children, container._childrenDirty);
      container._childrenDirty = false;
      const source = container.texture._source;
      const isCompressed = source.alphaMode === "no-premultiply-alpha";
      const blendMode = isCompressed ? "normal-npm" : container.blendMode;
      state.blendMode = blendMode;
      const uniforms = this.localUniforms.uniforms;
      const transformationMatrix = uniforms.uTranslationMatrix;
      const globalUniformData = renderer.globalUniforms._currentGlobalUniformData;
      container.updateWorldTransform();
      container._worldTransform.copyTo(transformationMatrix);
      transformationMatrix.prepend(globalUniformData.projectionMatrix);
      uniforms.uResolution = globalUniformData.resolution;
      uniforms.uRound = renderer._roundPixels | container._roundPixels;
      color32BitToUniform(
        container.groupColorAlpha,
        uniforms.uColor,
        0
      );
      this.adaptor.execute(this, container);
    }
    /** Destroys the ParticleRenderer. */
    destroy() {
      if (this.defaultShader) {
        this.defaultShader.destroy();
        this.defaultShader = null;
      }
    }
  }

  "use strict";
  class GlParticleContainerPipe extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GlParticleContainerAdaptor());
    }
  }
  /** @ignore */
  GlParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGLPipes
    ],
    name: "particle"
  };

  "use strict";
  const PARTICLE_DRAW_OPTIONS = {
    geometry: null,
    shader: null,
    state: null,
    size: 0
  }
  class GpuParticleContainerAdaptor {
    execute(particleContainerPipe, container) {
      const renderer = particleContainerPipe.renderer;
      const shader = container.shader || particleContainerPipe.defaultShader;
      const shaderGroups = shader.groups;
      const localUniforms = particleContainerPipe.localUniforms;
      const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
      shaderGroups[0] = localBindGroup;
      const bindGroup = renderer.texture.getTextureBindGroup(container.texture, false);
      shaderGroups[1] = bindGroup;
      const state = particleContainerPipe.state;
      const buffer = particleContainerPipe.getBuffers(container);
      PARTICLE_DRAW_OPTIONS.geometry = buffer.geometry;
      PARTICLE_DRAW_OPTIONS.shader = container.shader || particleContainerPipe.defaultShader;
      PARTICLE_DRAW_OPTIONS.state = state;
      PARTICLE_DRAW_OPTIONS.size = container.particleChildren.length * 6;
      renderer.encoder.draw(PARTICLE_DRAW_OPTIONS);
    }
  }
  "use strict";
  class GpuParticleContainerPipe extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GpuParticleContainerAdaptor());
    }
  }
  /** @ignore */
  GpuParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "particle"
  };

  "use strict";
  extensions.add(GlParticleContainerPipe);
  extensions.add(GpuParticleContainerPipe);

  "use strict";
  class BatchableSprite {
    constructor() {
      this.batcherName = "default";
      // batch specific..
      this.attributeSize = 4;
      this.indexSize = 6;
      this.packAsQuad = true;
      this.roundPixels = 0;
      this._attributeStart = 0;
      // location in the buffer
      this._batcher = null;
      this._batch = null;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    reset() {
      this.renderable = null;
      this.texture = null;
      this._batcher = null;
      this._batch = null;
      this.bounds = null;
      this.transform = null;
      this._attributeStart = 0;
      this.attributeSize = 4;
      this.indexSize = 6;
      this.packAsQuad = true;
      this.roundPixels = 0;
    }
  }

  class TexturePoolClass {
    constructor() {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null);
      this._texturePool = Object.create(null);
    }
    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     * @param frameWidth - The minimum width of the render texture.
     * @param frameHeight - The minimum height of the render texture.
     * @param resolution - The resolution of the render texture.
     * @param antialias
     * @returns The new render texture.
     */
    getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
      let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
      let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
      po2Width = nextPow2(po2Width);
      po2Height = nextPow2(po2Height);
      const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
      if (!this._texturePool[key]) {
        this._texturePool[key] = new Pool(Texture, 100);
      }
      const texture = this._texturePool[key].get().create(po2Width, po2Height, antialias);
      const source = texture._source;
      source._resolution = resolution;
      source.width = po2Width / resolution;
      source.height = po2Height / resolution;
      source.pixelWidth = po2Width;
      source.pixelHeight = po2Height;
      texture.setFrame(0, 0, frameWidth, frameHeight)
      this._poolKeyHash[texture.uid] = key;
      return texture;
    }
    /**
     * Gets extra texture of the same size as input renderTexture
     * @param texture - The texture to check what size it is.
     * @param antialias - Whether to use antialias.
     * @returns A texture that is a power of two
     */
    getSameSizeTexture(texture, antialias = false) {
      const source = texture._source;
      return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);
    }
    /**
     * Place a render texture back into the pool.
     * @param renderTexture - The renderTexture to free
     */
    returnTexture(renderTexture) {
      const key = this._poolKeyHash[renderTexture.uid];
      const pool = this._texturePool[key];
      pool.return(renderTexture);
    }
    /**
     * Clears the pool.
     * @param destroyTextures - Destroy all stored textures.
     */
    clear(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        const texturePools = this._texturePool;
        for (const i in texturePools) {
          const textures = texturePools[i];
          textures.clear();
        }
      }
    }
  }
  const TexturePool = new TexturePoolClass();
  PoolCache.RenderTexturePool = TexturePool;

  "use strict";
  class Circle {
    /**
     * @param x - The X coordinate of the center of this circle
     * @param y - The Y coordinate of the center of this circle
     * @param radius - The radius of the circle
     */
    constructor(x = 0, y = 0, radius = 0) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'circle'
       */
      this.type = "circle";
      this.x = x;
      this.y = y;
      this.radius = radius;
    }
    /**
     * Creates a clone of this Circle instance
     * @returns A copy of the Circle
     */
    clone() {
      return new Circle(this.x, this.y, this.radius);
    }
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @returns Whether the x/y coordinates are within this Circle
     */
    contains(x, y) {
      if (this.radius <= 0)
        return false;
      const r2 = this.radius * this.radius;
      let dx = this.x - x;
      let dy = this.y - y;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this circle including the stroke.
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @param width - The width of the line to check
     * @returns Whether the x/y coordinates are within this Circle
     */
    strokeContains(x, y, width) {
      if (this.radius === 0)
        return false;
      const dx = this.x - x;
      const dy = this.y - y;
      const r = this.radius;
      const w2 = width / 2;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < r + w2 && distance > r - w2;
    }
    /**
     * Returns the framing rectangle of the circle as a Rectangle object
     * @param out
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      out.x = this.x - this.radius;
      out.y = this.y - this.radius;
      out.width = this.radius * 2;
      out.height = this.radius * 2;
      return out;
    }
    /**
     * Copies another circle to this one.
     * @param circle - The circle to copy from.
     * @returns Returns itself.
     */
    copyFrom(circle) {
      this.x = circle.x;
      this.y = circle.y;
      this.radius = circle.radius;
      return this;
    }
    /**
     * Copies this circle to another one.
     * @param circle - The circle to copy to.
     * @returns Returns given parameter.
     */
    copyTo(circle) {
      circle.copyFrom(this);
      return circle;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }

  "use strict";
  class Ellipse {
    /**
     * @param x - The X coordinate of the center of this ellipse
     * @param y - The Y coordinate of the center of this ellipse
     * @param halfWidth - The half width of this ellipse
     * @param halfHeight - The half height of this ellipse
     */
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'ellipse'
       */
      this.type = "ellipse";
      this.x = x;
      this.y = y;
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
    }
    /**
     * Creates a clone of this Ellipse instance
     * @returns {Ellipse} A copy of the ellipse
     */
    clone() {
      return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @returns Whether the x/y coords are within this ellipse
     */
    contains(x, y) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) {
        return false;
      }
      let normx = (x - this.x) / this.halfWidth;
      let normy = (y - this.y) / this.halfHeight;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse including stroke
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @param width
     * @returns Whether the x/y coords are within this ellipse
     */
    strokeContains(x, y, width) {
      const { halfWidth, halfHeight } = this;
      if (halfWidth <= 0 || halfHeight <= 0) {
        return false;
      }
      const halfStrokeWidth = width / 2;
      const innerA = halfWidth - halfStrokeWidth;
      const innerB = halfHeight - halfStrokeWidth;
      const outerA = halfWidth + halfStrokeWidth;
      const outerB = halfHeight + halfStrokeWidth;
      const normalizedX = x - this.x;
      const normalizedY = y - this.y;
      const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
      const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
      return innerEllipse > 1 && outerEllipse <= 1;
    }
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     * @param out
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      out.x = this.x - this.halfWidth;
      out.y = this.y - this.halfHeight;
      out.width = this.halfWidth * 2;
      out.height = this.halfHeight * 2;
      return out;
    }
    /**
     * Copies another ellipse to this one.
     * @param ellipse - The ellipse to copy from.
     * @returns Returns itself.
     */
    copyFrom(ellipse) {
      this.x = ellipse.x;
      this.y = ellipse.y;
      this.halfWidth = ellipse.halfWidth;
      this.halfHeight = ellipse.halfHeight;
      return this;
    }
    /**
     * Copies this ellipse to another one.
     * @param ellipse - The ellipse to copy to.
     * @returns Returns given parameter.
     */
    copyTo(ellipse) {
      ellipse.copyFrom(this);
      return ellipse;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }

  "use strict";
  function squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {
    const a = x - x1;
    const b = y - y1;
    const c = x2 - x1;
    const d = y2 - y1;
    const dot = a * c + b * d;
    const lenSq = c * c + d * d;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * c;
      yy = y1 + param * d;
    }
    const dx = x - xx;
    const dy = y - yy;
    return dx * dx + dy * dy;
  }

  "use strict";
  class Polygon {
    /**
     * @param points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */
    constructor(...points) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'polygon'
       */
      this.type = "polygon";
      let flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        const p = [];
        for (let i = 0, il = flat.length; i < il; i++) {
          p.push(flat[i].x, flat[i].y);
        }
        flat = p;
      }
      this.points = flat;
      this.closePath = true;
    }
    /**
     * Creates a clone of this polygon.
     * @returns - A copy of the polygon.
     */
    clone() {
      const points = this.points.slice();
      const polygon = new Polygon(points);
      polygon.closePath = this.closePath;
      return polygon;
    }
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon.
     * @param x - The X coordinate of the point to test.
     * @param y - The Y coordinate of the point to test.
     * @returns - Whether the x/y coordinates are within this polygon.
     */
    contains(x, y) {
      let inside = false;
      const length = this.points.length / 2;
      for (let i = 0, j = length - 1; i < length; j = i++) {
        const xi = this.points[i * 2];
        const yi = this.points[i * 2 + 1];
        const xj = this.points[j * 2];
        const yj = this.points[j * 2 + 1];
        const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @param strokeWidth - The width of the line to check
     * @returns Whether the x/y coordinates are within this polygon
     */
    strokeContains(x, y, strokeWidth) {
      const halfStrokeWidth = strokeWidth / 2;
      const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
      const { points } = this;
      const iterationLength = points.length - (this.closePath ? 0 : 2);
      for (let i = 0; i < iterationLength; i += 2) {
        const x1 = points[i];
        const y1 = points[i + 1];
        const x2 = points[(i + 2) % points.length];
        const y2 = points[(i + 3) % points.length];
        const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);
        if (distanceSqrd <= halfStrokeWidthSqrd) {
          return true;
        }
      }
      return false;
    }
    /**
     * Returns the framing rectangle of the polygon as a Rectangle object
     * @param out - optional rectangle to store the result
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      const points = this.points;
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      for (let i = 0, n = points.length; i < n; i += 2) {
        const x = points[i];
        const y = points[i + 1];
        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;
        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
      }
      out.x = minX;
      out.width = maxX - minX;
      out.y = minY;
      out.height = maxY - minY;
      return out;
    }
    /**
     * Copies another polygon to this one.
     * @param polygon - The polygon to copy from.
     * @returns Returns itself.
     */
    copyFrom(polygon) {
      this.points = polygon.points.slice();
      this.closePath = polygon.closePath;
      return this;
    }
    /**
     * Copies this polygon to another one.
     * @param polygon - The polygon to copy to.
     * @returns Returns given parameter.
     */
    copyTo(polygon) {
      polygon.copyFrom(this);
      return polygon;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
    }
    /**
     * Get the last X coordinate of the polygon
     * @readonly
     */
    get lastX() {
      return this.points[this.points.length - 2];
    }
    /**
     * Get the last Y coordinate of the polygon
     * @readonly
     */
    get lastY() {
      return this.points[this.points.length - 1];
    }
    /**
     * Get the first X coordinate of the polygon
     * @readonly
     */
    get x() {
      return this.points[this.points.length - 2];
    }
    /**
     * Get the first Y coordinate of the polygon
     * @readonly
     */
    get y() {
      return this.points[this.points.length - 1];
    }
  }

  "use strict";
  const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
    const dx = pX - cornerX;
    const dy = pY - cornerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
  };
  class RoundedRectangle {
    /**
     * @param x - The X coordinate of the upper-left corner of the rounded rectangle
     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param width - The overall width of this rounded rectangle
     * @param height - The overall height of this rounded rectangle
     * @param radius - Controls the radius of the rounded corners
     */
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'roundedRectangle'
       */
      this.type = "roundedRectangle";
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.radius = radius;
    }
    /**
     * Returns the framing rectangle of the rounded rectangle as a Rectangle object
     * @param out - optional rectangle to store the result
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      out.x = this.x;
      out.y = this.y;
      out.width = this.width;
      out.height = this.height;
      return out;
    }
    /**
     * Creates a clone of this Rounded Rectangle.
     * @returns - A copy of the rounded rectangle.
     */
    clone() {
      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    /**
     * Copies another rectangle to this one.
     * @param rectangle - The rectangle to copy from.
     * @returns Returns itself.
     */
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    /**
     * Copies this rectangle to another one.
     * @param rectangle - The rectangle to copy to.
     * @returns Returns given parameter.
     */
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     * @param x - The X coordinate of the point to test.
     * @param y - The Y coordinate of the point to test.
     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
     */
    contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x <= this.x + this.width) {
        if (y >= this.y && y <= this.y + this.height) {
          const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
            return true;
          }
          let dx = x - (this.x + radius);
          let dy = y - (this.y + radius);
          const radius2 = radius * radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + this.width - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y - (this.y + this.height - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
     * @param pX - The X coordinate of the point to test
     * @param pY - The Y coordinate of the point to test
     * @param strokeWidth - The width of the line to check
     * @returns Whether the x/y coordinates are within this rectangle
     */
    strokeContains(pX, pY, strokeWidth) {
      const { x, y, width, height, radius } = this;
      const halfStrokeWidth = strokeWidth / 2;
      const innerX = x + radius;
      const innerY = y + radius;
      const innerWidth = width - radius * 2;
      const innerHeight = height - radius * 2;
      const rightBound = x + width;
      const bottomBound = y + height;
      if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
        return true;
      }
      if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
        return true;
      }
      return (
        // Top-left
        pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)
      );
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }

  "use strict";
  function isSafari() {
    const { userAgent } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }

  "use strict";
  var __defProp$M = Object.defineProperty;
  var __getOwnPropSymbols$M = Object.getOwnPropertySymbols;
  var __hasOwnProp$M = Object.prototype.hasOwnProperty;
  var __propIsEnum$M = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$M = (obj, key, value) => key in obj ? __defProp$M(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$M = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$M.call(b, prop))
        __defNormalProp$M(a, prop, b[prop]);
    if (__getOwnPropSymbols$M)
      for (var prop of __getOwnPropSymbols$M(b)) {
        if (__propIsEnum$M.call(b, prop))
          __defNormalProp$M(a, prop, b[prop]);
      }
    return a;
  };
  class MeshGeometry extends Geometry {
    constructor(options) {
      options = __spreadValues$M(__spreadValues$M({}, MeshGeometry.defaultOptions), options);
      const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
      const shrinkToFit = options.shrinkBuffersToFit;
      const positionBuffer = new Buffer({
        data: positions,
        label: "attribute-mesh-positions",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const uvBuffer = new Buffer({
        data: uvs,
        label: "attribute-mesh-uvs",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const indexBuffer = new Buffer({
        data: indices,
        label: "index-mesh-buffer",
        shrinkToFit,
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST
      });
      super({
        attributes: {
          aPosition: {
            buffer: positionBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          },
          aUV: {
            buffer: uvBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer,
        topology: options.topology
      });
      this.batchMode = "auto";
    }
    /** The positions of the mesh. */
    get positions() {
      return this.attributes.aPosition.buffer._data;
    }
    set positions(value) {
      this.attributes.aPosition.buffer.setDataWithSize(value, value.length, true);
    }
    /** The UVs of the mesh. */
    get uvs() {
      return this.attributes.aUV.buffer._data;
    }
    set uvs(value) {
      this.attributes.aUV.buffer.setDataWithSize(value, value.length, true);
    }
    /** The indices of the mesh. */
    get indices() {
      return this.indexBuffer._data;
    }
    set indices(value) {
      this.indexBuffer.setDataWithSize(value, value.length, true);
    }
  };
  MeshGeometry.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
  };

  "use strict";
  var __defProp$L = Object.defineProperty;
  var __defProps$l = Object.defineProperties;
  var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$L = Object.getOwnPropertySymbols;
  var __hasOwnProp$L = Object.prototype.hasOwnProperty;
  var __propIsEnum$L = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$L = (obj, key, value) => key in obj ? __defProp$L(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$L = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$L.call(b, prop))
        __defNormalProp$L(a, prop, b[prop]);
    if (__getOwnPropSymbols$L)
      for (var prop of __getOwnPropSymbols$L(b)) {
        if (__propIsEnum$L.call(b, prop))
          __defNormalProp$L(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$l = (a, b) => __defProps$l(a, __getOwnPropDescs$l(b));
  const localUniformBit = {
    name: "local-uniform-bit",
    vertex: {
      header: (
        /* wgsl */
        `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
      ),
      main: (
        /* wgsl */
        `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
      ),
      end: (
        /* wgsl */
        `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
      )
    }
  };
  const localUniformBitGroup2 = __spreadProps$l(__spreadValues$L({}, localUniformBit), {
    vertex: __spreadProps$l(__spreadValues$L({}, localUniformBit.vertex), {
      // replace the group!
      header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
    })
  });
  const localUniformBitGl = {
    name: "local-uniform-bit",
    vertex: {
      header: (
        /* glsl */
        `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
      ),
      main: (
        /* glsl */
        `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
      ),
      end: (
        /* glsl */
        `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
      )
    }
  };

  "use strict";
  const tilingBit = {
    name: "tiling-bit",
    vertex: {
      header: (
        /* wgsl */
        `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
      ),
      main: (
        /* wgsl */
        `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
      )
    },
    fragment: {
      header: (
        /* wgsl */
        `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
      ),
      main: (
        /* wgsl */
        `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
      )
    }
  };
  const tilingBitGl = {
    name: "tiling-bit",
    vertex: {
      header: (
        /* glsl */
        `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
      ),
      main: (
        /* glsl */
        `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
      )
    },
    fragment: {
      header: (
        /* glsl */
        `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
      ),
      main: (
        /* glsl */
        `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
      )
    }
  };

  "use strict";
  let gpuProgram;
  let glProgram;
  class TilingSpriteShader extends Shader {
    constructor() {
      gpuProgram != null ? gpuProgram : gpuProgram = compileHighShaderGpuProgram(
        [
          localUniformBit,
          tilingBit,
          roundPixelsBit
        ],
        "tiling-sprite-shader"
      );
      glProgram != null ? glProgram : glProgram = compileHighShaderGlProgram(
        [
          localUniformBitGl,
          tilingBitGl,
          roundPixelsBitGl
        ],
        "tiling-sprite-shader"
      );
      const tilingUniforms = new UniformGroup({
        uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
        uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
        uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
        uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
        uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
      });
      const localUniforms = new UniformGroup({
        uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 0, type: "f32" }
      })
      super({
        glProgram,
        gpuProgram,
        resources: {
          localUniforms,
          tilingUniforms,
          uTexture: Texture.EMPTY._source,
          uSampler: Texture.EMPTY._source._style
        }
      });
      const isWebgl = Engine.renderer.type === RendererType.WEBGL;
      if (isWebgl) {
        this.textureBingGroup = this.groups[99];
        this._updateTextureBindGroup = this.updateGlTextures;
      } else {
        this.textureBingGroup = this.groups[2];
        this._updateTextureBindGroup = this.updateGpuTextures;
      }
      this._localUniforms = localUniforms.uniforms;
      this._tilingUniforms = tilingUniforms.uniforms;
    }
    updateGlTextures(textureBindGroup, source, style) {
      textureBindGroup.setResource(source, 2);
      textureBindGroup.setResource(style, 3);
    }
    updateGpuTextures(textureBindGroup, source, style) {
      textureBindGroup.setResource(source, 1);
      textureBindGroup.setResource(style, 2);
    }
    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
      const tilingUniforms = this._tilingUniforms;
      const frame = texture.frame;
      const textureWidth = frame.width;
      const textureHeight = frame.height;
      const textureMatrix = texture._textureMatrix;
      const uTextureTransform = tilingUniforms.uTextureTransform;
      const tw = textureWidth / width;
      const th = textureHeight / height;
      uTextureTransform.set(
        matrix.a * tw,
        matrix.b * tw,
        matrix.c * th,
        matrix.d * th,
        matrix.tx / width,
        matrix.ty / height
      );
      uTextureTransform.invert();
      tilingUniforms.uMapCoord = textureMatrix.mapCoord;
      tilingUniforms.uClampFrame = textureMatrix.uClampFrame;
      tilingUniforms.uClampOffset = textureMatrix.uClampOffset;
      tilingUniforms.uSizeAnchor[0] = width;
      tilingUniforms.uSizeAnchor[1] = height;
      tilingUniforms.uSizeAnchor[2] = anchorX;
      tilingUniforms.uSizeAnchor[3] = anchorY;
      if (texture) {
        const group = this.textureBingGroup;
        const source = texture._source;
        this._updateTextureBindGroup(group, source, source._style);
      }
    }
  }

  "use strict";
  class QuadGeometry extends MeshGeometry {
    constructor() {
      super({
        positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        indices: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
    }
  }

  "use strict";
  function setPositions(tilingSprite, positions) {
    const anchor = tilingSprite._anchor;
    const anchorX = anchor._x;
    const anchorY = anchor._y;
    const width = tilingSprite._width;
    const height = tilingSprite._height;
    const aw = (1 - anchorX) * width;
    const ah = (1 - anchorY) * height;
    const ax = -anchorX * width;
    const ay = -anchorY * height;
    positions[0] = ax;
    positions[1] = ay;
    positions[2] = aw;
    positions[3] = ay;
    positions[4] = aw;
    positions[5] = ah;
    positions[6] = ax;
    positions[7] = ah;
  }

  "use strict";
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    for (index = 0; index < size; index++) {
      const x = array[offset];
      const y = array[offset + 1];
      array[offset] = a * x + c * y + tx;
      array[offset + 1] = b * x + d * y + ty;
      offset += stride;
    }
  }

  "use strict";
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite._texture;
    const frame = texture.frame;
    const width = frame.width;
    const height = frame.height;
    const tw = tilingSprite._width;
    const th = tilingSprite._height;
    uvs[0] = uvs[6] = 0;
    uvs[2] = uvs[4] = 1;
    uvs[1] = uvs[3] = 0;
    uvs[5] = uvs[7] = 1;
    const textureMatrix = tempMatrix$5.identity();
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tw;
    textureMatrix.ty /= th;
    textureMatrix.invert();
    textureMatrix.scale(tw / width, th / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }

  "use strict";
  const TILINGSPRITE_DRAW_OPTIONS = {
    geometry: null,
    shader: null,
    state: null
  }
  const sharedQuad = new QuadGeometry();
  class TilingSpriteGpuData {
    constructor() {
      this.canBatch = true;
      this.renderable = null;
      this.batchableMesh = null;
      this.shader = null;
      this.geometry = new MeshGeometry({
        positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        indices: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
    }
    destroy() {
      this.geometry.destroy(true);
      this.shader?.destroy();
    }
  }
  class TilingSpritePipe {
    constructor(renderer) {
      this._state = State.default2d;
      this._renderer = renderer;
      this._nonPowOf2wrapping = null;
      const isWebgl = renderer.type === RendererType.WEBGL;
      if (isWebgl) {
        this._nonPowOf2wrapping = renderer.context.supports.nonPowOf2wrapping;
      } else {
        this._nonPowOf2wrapping = true;
      }
    }
    validateRenderable(renderable) {
      const tilingSpriteData = this._getTilingSpriteData(renderable);
      const couldBatch = tilingSpriteData.canBatch;
      const canBatch = this._updateCanBatch(renderable);
      if (canBatch && canBatch === couldBatch) {
        const batchableMesh = tilingSpriteData.batchableMesh;
        if (batchableMesh._batcher === null) return true;
        return !checkAndUpdateTexture(batchableMesh, renderable._texture);
      }
      return couldBatch !== canBatch;
    }
    addRenderable(tilingSprite, instructionSet) {
      const renderer = this._renderer;
      const batcher = renderer.renderPipes.batch;
      this._updateCanBatch(tilingSprite);
      const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const geometry = tilingSpriteData.geometry;
      const canBatch = tilingSpriteData.canBatch;
      if (canBatch) {
        tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
        const batchableMesh = tilingSpriteData.batchableMesh;
        batchableMesh.geometry = geometry;
        batchableMesh.renderable = tilingSprite;
        batchableMesh.transform = tilingSprite.groupTransform;
        batchableMesh.setTexture(tilingSprite._texture);
        if (tilingSprite.didViewUpdate) {
          this._updateBatchableMesh(tilingSprite, tilingSpriteData);
        }
        batchableMesh.roundPixels = renderer._roundPixels | tilingSprite._roundPixels;
        batcher.addToBatch(batchableMesh, instructionSet);
      } else {
        batcher.break(instructionSet);
        tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
        this.updateRenderable(tilingSprite);
        instructionSet.add(tilingSprite);
      }
    }
    execute(tilingSprite) {
      const renderer = this._renderer;
      const shader = this._getTilingSpriteData(tilingSprite).shader;
      shader.groups[0] = renderer.globalUniforms._currentGlobalUniformData.bindGroup;
      const localUniforms = shader._localUniforms;
      localUniforms.uTransformMatrix = tilingSprite.groupTransform;
      localUniforms.uRound = renderer._roundPixels | tilingSprite._roundPixels;
      color32BitToUniform(
        tilingSprite.groupColorAlpha,
        localUniforms.uColor,
        0
      );
      this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite._texture._source);
      TILINGSPRITE_DRAW_OPTIONS.geometry = sharedQuad;
      TILINGSPRITE_DRAW_OPTIONS.shader = shader;
      TILINGSPRITE_DRAW_OPTIONS.state = this._state;
      renderer.encoder.draw(TILINGSPRITE_DRAW_OPTIONS);
    }
    updateRenderable(tilingSprite) {
      const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const canBatch = tilingSpriteData.canBatch;
      if (canBatch) {
        const batchableMesh = tilingSpriteData.batchableMesh;
        if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite, tilingSpriteData);
        batchableMesh._batcher.updateElement(batchableMesh);
      } else if (tilingSprite.didViewUpdate) {
        const shader = tilingSpriteData.shader;
        const anchor = tilingSprite._anchor;
        shader.updateUniforms(
          tilingSprite._width,
          tilingSprite._height,
          tilingSprite._tileTransform.matrix,
          anchor._x,
          anchor._y,
          tilingSprite._texture
        );
      }
    }
    _getTilingSpriteData(renderable) {
      return renderable._gpuData || this._initTilingSpriteData(renderable);
    }
    _initTilingSpriteData(tilingSprite) {
      const gpuData = new TilingSpriteGpuData();
      gpuData.renderable = tilingSprite;
      tilingSprite._gpuData = gpuData;
      return gpuData;
    }
    _updateBatchableMesh(tilingSprite, renderableData) {
      const geometry = renderableData.geometry;
      const attributes = geometry.attributes;
      setUvs(tilingSprite, attributes.aUV.buffer._data);
      setPositions(tilingSprite, attributes.aPosition.buffer._data);
    }
    destroy() {
      this._renderer = null;
    }
    _updateCanBatch(tilingSprite) {
      const renderableData = this._getTilingSpriteData(tilingSprite);
      const texture = tilingSprite._texture;
      const source = texture._source;
      const _nonPowOf2wrapping = this._nonPowOf2wrapping;
      const textureMatrix = tilingSprite._textureMatrix;
      renderableData.canBatch = textureMatrix.isSimple && (_nonPowOf2wrapping || source.isPowerOfTwo);
      return renderableData.canBatch;
    }
  }
  /** @ignore */
  TilingSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "tilingSprite"
  };

  "use strict";
  extensions.add(TilingSpritePipe);

  "use strict";
  var __defProp$K = Object.defineProperty;
  var __getOwnPropSymbols$K = Object.getOwnPropertySymbols;
  var __hasOwnProp$K = Object.prototype.hasOwnProperty;
  var __propIsEnum$K = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$K = (obj, key, value) => key in obj ? __defProp$K(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$K = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$K.call(b, prop))
        __defNormalProp$K(a, prop, b[prop]);
    if (__getOwnPropSymbols$K)
      for (var prop of __getOwnPropSymbols$K(b)) {
        if (__propIsEnum$K.call(b, prop))
          __defNormalProp$K(a, prop, b[prop]);
      }
    return a;
  };
  class PlaneGeometry extends MeshGeometry {
    constructor(...args) {
      var _a;
      super({});
      let options = (_a = args[0]) != null ? _a : {};
      if (typeof options === "number") {
        deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
        options = {
          width: options,
          height: args[1],
          verticesX: args[2],
          verticesY: args[3]
        };
      }
      this.build(options);
    }
    /**
     * Refreshes plane coordinates
     * @param options - Options to be applied to plane geometry
     */
    build(options) {
      var _a, _b, _c, _d;
      options = __spreadValues$K(__spreadValues$K({}, PlaneGeometry.defaultOptions), options);
      this.verticesX = (_a = this.verticesX) != null ? _a : options.verticesX;
      this.verticesY = (_b = this.verticesY) != null ? _b : options.verticesY;
      this.width = (_c = this.width) != null ? _c : options.width;
      this.height = (_d = this.height) != null ? _d : options.height;
      const total = this.verticesX * this.verticesY;
      const verts = [];
      const uvs = [];
      const indices = [];
      const verticesX = this.verticesX - 1;
      const verticesY = this.verticesY - 1;
      const sizeX = this.width / verticesX;
      const sizeY = this.height / verticesY;
      for (let i = 0; i < total; i++) {
        const x = i % this.verticesX;
        const y = i / this.verticesX | 0;
        verts.push(x * sizeX, y * sizeY);
        uvs.push(x / verticesX, y / verticesY);
      }
      const totalSub = verticesX * verticesY;
      for (let i = 0; i < totalSub; i++) {
        const xpos = i % verticesX;
        const ypos = i / verticesX | 0;
        const value = ypos * this.verticesX + xpos;
        const value2 = ypos * this.verticesX + xpos + 1;
        const value3 = (ypos + 1) * this.verticesX + xpos;
        const value4 = (ypos + 1) * this.verticesX + xpos + 1;
        indices.push(
          value,
          value2,
          value3,
          value2,
          value4,
          value3
        );
      }
      const buffers = this.buffers;
      const indexBuffer = this.indexBuffer;
      buffers[0].setDataWithSize(new Float32Array(verts), verts.length, true);
      buffers[1].setDataWithSize(new Float32Array(uvs), uvs.length, true);
      indexBuffer.setDataWithSize(new Uint32Array(indices), indices.length, true);
    }
  };
  PlaneGeometry.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
  };

  "use strict";
  var __defProp$J = Object.defineProperty;
  var __getOwnPropSymbols$J = Object.getOwnPropertySymbols;
  var __hasOwnProp$J = Object.prototype.hasOwnProperty;
  var __propIsEnum$J = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$J = (obj, key, value) => key in obj ? __defProp$J(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$J = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$J.call(b, prop))
        __defNormalProp$J(a, prop, b[prop]);
    if (__getOwnPropSymbols$J)
      for (var prop of __getOwnPropSymbols$J(b)) {
        if (__propIsEnum$J.call(b, prop))
          __defNormalProp$J(a, prop, b[prop]);
      }
    return a;
  };
  const NineSliceGeometry = class NineSliceGeometry extends PlaneGeometry {
    constructor(options = {}) {
      options = __spreadValues$J(__spreadValues$J({}, NineSliceGeometry.defaultOptions), options);
      super({
        width: options.width,
        height: options.height,
        verticesX: 4,
        verticesY: 4
      });
      this.update(options);
    }
    /**
     * Updates the NineSliceGeometry with the options.
     * @param options - The options of the NineSliceGeometry.
     */
    update(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.width = (_a = options.width) != null ? _a : this.width;
      this.height = (_b = options.height) != null ? _b : this.height;
      this._originalWidth = (_c = options.originalWidth) != null ? _c : this._originalWidth;
      this._originalHeight = (_d = options.originalHeight) != null ? _d : this._originalHeight;
      this._leftWidth = (_e = options.leftWidth) != null ? _e : this._leftWidth;
      this._rightWidth = (_f = options.rightWidth) != null ? _f : this._rightWidth;
      this._topHeight = (_g = options.topHeight) != null ? _g : this._topHeight;
      this._bottomHeight = (_h = options.bottomHeight) != null ? _h : this._bottomHeight;
      this.updateUvs();
      this.updatePositions();
    }
    /** Updates the positions of the vertices. */
    updatePositions() {
      const positions = this.positions;
      const w = this._leftWidth + this._rightWidth;
      const scaleW = this.width > w ? 1 : this.width / w;
      const h = this._topHeight + this._bottomHeight;
      const scaleH = this.height > h ? 1 : this.height / h;
      const scale = Math.min(scaleW, scaleH);
      positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
      positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
      positions[25] = positions[27] = positions[29] = positions[31] = this.height;
      positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
      positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
      positions[6] = positions[14] = positions[22] = positions[30] = this.width;
      this.getBuffer("aPosition").update();
    }
    /** Updates the UVs of the vertices. */
    updateUvs() {
      const uvs = this.uvs;
      uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
      uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
      uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
      uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
      const _uvw = 1 / this._originalWidth;
      const _uvh = 1 / this._originalHeight;
      uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
      uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
      uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
      uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
      this.getBuffer("aUV").update();
    }
  };
  /** The default options for the NineSliceGeometry. */
  NineSliceGeometry.defaultOptions = {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    width: 100,
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    height: 100,
    /** The width of the left column. */
    leftWidth: 10,
    /** The height of the top row. */
    topHeight: 10,
    /** The width of the right column. */
    rightWidth: 10,
    /** The height of the bottom row. */
    bottomHeight: 10,
    /** The original width of the texture */
    originalWidth: 100,
    /** The original height of the texture */
    originalHeight: 100
  };

  "use strict";
  class NineSliceSpritePipe {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderable(sprite, instructionSet) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
      const gpuSprite = sprite._gpuData;
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
      const texture = sprite._texture;
      const gpuSprite = this._getGpuSprite(sprite);
      if (gpuSprite._batcher === null) return true;
      return !checkAndUpdateTexture(gpuSprite, texture);
    }
    destroyRenderable(sprite) {
      const batchableMesh = sprite._gpuData;
      returnPoolObject(batchableMesh.geometry);
      returnPoolObject(batchableMesh);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
      batchableSprite.geometry.update(sprite);
      batchableSprite.texture = sprite._texture;
    }
    _getGpuSprite(sprite) {
      return sprite._gpuData || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
      const batchableMesh = getPoolObject(BatchableMesh);
      batchableMesh.geometry = getPoolObject(NineSliceGeometry);
      batchableMesh.renderable = sprite;
      batchableMesh.transform = sprite.groupTransform;
      batchableMesh.texture = sprite._texture;
      batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
      sprite._gpuData = batchableMesh;
      if (!sprite.didViewUpdate) {
        this._updateBatchableSprite(sprite, batchableMesh);
      }
      return batchableMesh;
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  NineSliceSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "nineSliceSprite"
  };

  "use strict";
  extensions.add(NineSliceSpritePipe);

  class FilterSet {
    constructor() {
      this.renderPipeId = "filter";
      this.canBundle = false;
      this.action = "push";
      this.container = null;
      this.filterEffect = null;
    }
    push(container, filterEffect) {
      this.action = "push";
      this.canBundle = false;
      this.container = container;
      this.filterEffect = filterEffect;
    }
    pop() {
      this.container = null;
      this.filterEffect = null;
      this.canBundle = false;
      this.action = "pop";
    }
    reset() {
      this.container = null;
      this.filterEffect = null;
      this.canBundle = false;
    }
  }
  const FilterSetPool = createPool("FilterSetPool", FilterSet);

  "use strict";
  class FilterPipe {
    constructor(renderer) {
      this._renderer = renderer;
    }
    push(filterEffect, container, instructionSet) {
      const renderPipes = this._renderer.renderPipes;
      renderPipes.batch.break(instructionSet);
      const filterPush = FilterSetPool.get();
      filterPush.push(container, filterEffect);
      instructionSet.add(filterPush);
    }
    pop(_filterEffect, _container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      const filterPop = FilterSetPool.get();
      filterPop.pop();
      instructionSet.add(filterPop);
    }
    execute(instruction) {
      const action = instruction.action;
      this._renderer.filter[action](instruction);
    }
    destroy() {
      this._renderer = null;
    }
  }
  FilterPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "filter"
  };

  "use strict";
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix = bounds.matrix;
    for (let i = 0; i < renderables.length; i++) {
      const renderable = renderables[i];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      renderable.checkWorldTransform();
      renderable.updateWorldTransform();
      bounds.matrix = renderable._worldTransform;
      renderable.addBounds(bounds);
    }
    bounds.matrix = tempMatrix;
    return bounds;
  }

  "use strict";
  const quadGeometry = new Geometry({
    attributes: {
      aPosition: {
        buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        format: "float32x2",
        stride: 2 * 4,
        offset: 0
      }
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
  });
  const FILTER_PUSH_OPTIONS = {
    offset: new Point()
  };
  const FILTER_DRAW_OPTIONS = {
    geometry: quadGeometry,
    shader: null,
    state: null,
    topology: "triangle-list",
    set(geometry, shader, state, topology) {
      this.geometry = geometry;
      this.shader = shader;
      this.state = state;
      this.topology = topology;
    }
  }
  const FILTER_POINT1 = new Point(0, 0);
  const FILTER_POINT2 = new Point(0, 0);
  const FILTER_TEXTURE_SIZE = {
    width: 0,
    height: 0,
    set(width, height) {
      this.width = width;
      this.height = height;
    }
  }
  class FilterData {
    constructor() {
      /**
       * Indicates whether the filter should be skipped.
       * @type {boolean}
       */
      this.skip = false;
      /**
       * The texture to which the filter is applied.
       * @type {Texture}
       */
      this.inputTexture = null;
      /**
       * The back texture used for blending, if required.
       * @type {Texture | null}
       */
      this.backTexture = null;
      /**
       * The list of filters to be applied.
       * @type {Filter[]}
       */
      this.filters = null;
      /**
       * The bounds of the filter area.
       * @type {Bounds}
       */
      this.bounds = new Bounds();
      /**
       * The container to which the filter is applied.
       * @type {Container}
       */
      this.container = null;
      /**
       * Indicates whether blending is required for the filter.
       * @type {boolean}
       */
      this.blendRequired = false;
      /**
       * The render surface where the output of the filter is rendered.
       * @type {RenderSurface}
       */
      this.outputRenderSurface = null;
      /**
       * The global frame of the filter area.
       * @type {{ x: number, y: number, width: number, height: number }}
       */
      this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
    }
  }
  class FilterSystem {
    constructor(renderer) {
      this._filterStackIndex = 0;
      this._filterStack = [];
      this._filterGlobalUniforms = new UniformGroup({
        uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
        uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
        uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
        uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
        uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
        uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
      });
      this._globalFilterBindGroup = new BindGroup({});
      this.renderer = renderer;
      this.emptyBounds = new Bounds(0, 0, 1, 1);
      const isWebgl = renderer.type === RendererType.WEBGL;
      this._finishGlRenderPass = isWebgl ? this.finishGlRenderPass : Function.empty;
      this._updateGpuResource = isWebgl ? this.setupGlResource : this.setupGpuResource;
    }
    /**
     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
     * @readonly
     */
    get activeBackTexture() {
      var _a;
      return (_a = this._activeFilterData) == null ? void 0 : _a.backTexture;
    }
    /**
     * Pushes a filter instruction onto the filter stack.
     * @param instruction - The instruction containing the filter effect and container.
     * @internal
     */
    push(instruction) {
      const renderer = this.renderer;
      const filters = instruction.filterEffect.filters;
      const filterData = this._pushFilterData();
      const renderTargetSystem = renderer.renderTarget;
      filterData.skip = false;
      filterData.filters = filters;
      filterData.container = instruction.container;
      filterData.outputRenderSurface = renderTargetSystem.renderSurface;
      const colorTextureSource = renderTargetSystem.renderTarget.colorTextures[0];
      const rootResolution = colorTextureSource.resolution;
      const rootAntialias = colorTextureSource.antialias;
      if (filters.length === 0) {
        filterData.skip = true;
        return;
      }
      const bounds = filterData.bounds;
      this._calculateFilterArea(instruction, bounds);
      this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
      if (filterData.skip) {
        return;
      }
      const previousFilterData = this._getPreviousFilterData();
      const globalResolution = this._findFilterResolution(rootResolution);
      let offsetX = 0;
      let offsetY = 0;
      if (previousFilterData) {
        const bounds = previousFilterData.bounds;
        offsetX = bounds.minX;
        offsetY = bounds.minY;
      }
      this._calculateGlobalFrame(
        filterData,
        offsetX,
        offsetY,
        globalResolution,
        colorTextureSource.width,
        colorTextureSource.height
      );
      this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
    }
    /**
     * Applies filters to a texture.
     *
     * This method takes a texture and a list of filters, applies the filters to the texture,
     * and returns the resulting texture.
     * @param {object} params - The parameters for applying filters.
     * @param {Texture} params.texture - The texture to apply filters to.
     * @param {Filter[]} params.filters - The filters to apply.
     * @returns {Texture} The resulting texture after all filters have been applied.
     * @example
     *
     * ```ts
     * // Create a texture and a list of filters
     * const texture = new Texture(...);
     * const filters = [new BlurFilter(), new ColorMatrixFilter()];
     *
     * // Apply the filters to the texture
     * const resultTexture = filterSystem.applyToTexture({ texture, filters });
     *
     * // Use the resulting texture
     * sprite.texture = resultTexture;
     * ```
     *
     * Key Points:
     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.
     * 2. If all filters are disabled or skipped, the original texture is returned.
     */
    generateFilteredTexture({ texture, filters }) {
      const filterData = this._pushFilterData();
      this._activeFilterData = filterData;
      filterData.skip = false;
      filterData.filters = filters;
      const colorTextureSource = texture.source;
      const rootResolution = colorTextureSource.resolution;
      const rootAntialias = colorTextureSource.antialias;
      if (filters.length === 0) {
        filterData.skip = true;
        return texture;
      }
      const bounds = filterData.bounds;
      bounds.addRect(texture.frame);
      this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
      if (filterData.skip) {
        return texture;
      }
      const globalResolution = rootResolution;
      const offsetX = 0;
      const offsetY = 0;
      this._calculateGlobalFrame(
        filterData,
        offsetX,
        offsetY,
        globalResolution,
        colorTextureSource.width,
        colorTextureSource.height
      );
      filterData.outputRenderSurface = TexturePool.getOptimalTexture(
        bounds.width,
        bounds.height,
        filterData.resolution,
        filterData.antialias
      );
      filterData.backTexture = Texture.EMPTY;
      filterData.inputTexture = texture;
      const renderer = this.renderer;
      renderer.renderTarget.finishRenderPass();
      this._applyFiltersToTexture(filterData, "clear");
      const outputTexture = filterData.outputRenderSurface;
      outputTexture._source.alphaMode = "premultiplied-alpha";
      return outputTexture;
    }
    /** @internal */
    pop() {
      const renderer = this.renderer;
      const filterData = this._popFilterData();
      if (filterData.skip) {
        return;
      }
      renderer.globalUniforms.pop();
      renderer.renderTarget.finishRenderPass();
      this._activeFilterData = filterData;
      this._applyFiltersToTexture(filterData, "load");
      if (filterData.blendRequired) {
        TexturePool.returnTexture(filterData.backTexture);
      }
      TexturePool.returnTexture(filterData.inputTexture);
    }
    /**
     * Copies the last render surface to a texture.
     * @param lastRenderSurface - The last render surface to copy from.
     * @param bounds - The bounds of the area to copy.
     * @param previousBounds - The previous bounds to use for offsetting the copy.
     */
    getBackTexture(lastRenderSurface, bounds, previousBounds) {
      const backgroundResolution = lastRenderSurface.colorTextures[0]._resolution;
      const backTexture = TexturePool.getOptimalTexture(
        bounds.width,
        bounds.height,
        backgroundResolution,
        false
      );
      let x = bounds.minX;
      let y = bounds.minY;
      if (previousBounds) {
        x -= previousBounds.minX;
        y -= previousBounds.minY;
      }
      x = Math.floor(x * backgroundResolution);
      y = Math.floor(y * backgroundResolution);
      const width = Math.ceil(bounds.width * backgroundResolution);
      const height = Math.ceil(bounds.height * backgroundResolution);
      FILTER_POINT1.set(x, y);
      FILTER_POINT2.set(0, 0);
      FILTER_TEXTURE_SIZE.set(width, height);
      this.renderer.renderTarget.copyToTexture(
        lastRenderSurface,
        backTexture,
        FILTER_POINT1,
        FILTER_TEXTURE_SIZE,
        FILTER_POINT2
      );
      return backTexture;
    }
    /**
     * Applies a filter to a texture.
     * @param filter - The filter to apply.
     * @param input - The input texture.
     * @param output - The output render surface.
     * @param clear - Whether to clear the output surface before applying the filter.
     */
    applyFilter(filter, input, output, clear) {
      const renderer = this.renderer;
      const filterData = this._activeFilterData;
      const outputRenderSurface = filterData.outputRenderSurface;
      const isFinalTarget = outputRenderSurface === output;
      const rootResolution = renderer.renderTarget.rootRenderTarget.colorTextures[0]._resolution;
      const resolution = this._findFilterResolution(rootResolution);
      let offsetX = 0;
      let offsetY = 0;
      if (isFinalTarget) {
        const offset = this._findPreviousFilterBounds();
        offsetX = offset.minX;
        offsetY = offset.minY;
      }
      this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
      this._setupBindGroupsAndRender(filter, input, renderer);
    }
    /**
     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
     *
     * Use `outputMatrix * vTextureCoord` in the shader.
     * @param outputMatrix - The matrix to output to.
     * @param {Sprite} sprite - The sprite to map to.
     * @returns The mapped matrix.
     */
    calculateSpriteMatrix(outputMatrix, sprite) {
      const data = this._activeFilterData;
      const inputTextureSource = data.inputTexture._source;
      const bounds = data.bounds;
      const sprite_frame = sprite._texture.orig;
      const anchor = sprite._anchor;
      const mappedMatrix = outputMatrix.set(
        inputTextureSource.width,
        0,
        0,
        inputTextureSource.height,
        bounds.minX,
        bounds.minY
      );
      sprite.checkWorldTransform();
      sprite.updateWorldTransform();
      const worldTransform = sprite._worldTransform.copyTo(Matrix.shared);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(
        1 / sprite_frame.width,
        1 / sprite_frame.height
      );
      mappedMatrix.translate(anchor.x, anchor.y);
      return mappedMatrix;
    }
    destroy() {
    }
    setupGlResource(globalFilterBindGroup) {
      globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
    }
    setupGpuResource(globalFilterBindGroup, renderer) {
      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
      globalFilterBindGroup.setResource(batchUniforms, 0);
    }
    finishGlRenderPass(renderer) {
      renderer.renderTarget.finishRenderPass();
    }
    /**
     * Sets up the bind groups and renders the filter.
     * @param filter - The filter to apply
     * @param input - The input texture
     * @param renderer - The renderer instance
     */
    _setupBindGroupsAndRender(filter, input, renderer) {
      const inputSource = input._source;
      const inputStyle = inputSource._style;
      const globalFilterBindGroup = this._globalFilterBindGroup;
      this._updateGpuResource(globalFilterBindGroup, renderer);
      globalFilterBindGroup.setResource(inputSource, 1);
      globalFilterBindGroup.setResource(inputStyle, 2);
      filter.groups[0] = globalFilterBindGroup;
      FILTER_DRAW_OPTIONS.set(quadGeometry, filter, filter._state, "triangle-list");
      renderer.encoder.draw(FILTER_DRAW_OPTIONS);
      this._finishGlRenderPass(renderer);
    }
    /**
     * Sets up the filter textures including input texture and back texture if needed.
     * @param filterData - The filter data to update
     * @param {Bounds} bounds - The bounds for the texture
     * @param renderer - The renderer instance
     * @param previousFilterData - The previous filter data for back texture calculation
     */
    _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
      filterData.backTexture = Texture.EMPTY;
      filterData.inputTexture = TexturePool.getOptimalTexture(
        bounds.width,
        bounds.height,
        filterData.resolution,
        filterData.antialias
      );
      const renderTargetSystem = renderer.renderTarget;
      if (filterData.blendRequired) {
        renderTargetSystem.finishRenderPass();
        const renderTarget = renderTargetSystem.getRenderTarget(filterData.outputRenderSurface);
        filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData == null ? void 0 : previousFilterData.bounds);
      }
      renderTargetSystem.bind(filterData.inputTexture, "clear");
      FILTER_PUSH_OPTIONS.offset.set(bounds.minX, bounds.minY);
      renderer.globalUniforms.push(FILTER_PUSH_OPTIONS);
    }
    /**
     * Calculates and sets the global frame for the filter.
     * @param filterData - The filter data to update
     * @param offsetX - The X offset
     * @param offsetY - The Y offset
     * @param globalResolution - The global resolution
     * @param sourceWidth - The source texture width
     * @param sourceHeight - The source texture height
     */
    _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
      const globalFrame = filterData.globalFrame;
      globalFrame.x = offsetX * globalResolution;
      globalFrame.y = offsetY * globalResolution;
      globalFrame.width = sourceWidth * globalResolution;
      globalFrame.height = sourceHeight * globalResolution;
    }
    /**
     * Updates the filter uniforms with the current filter state.
     * @param input - The input texture
     * @param output - The output render surface
     * @param filterData - The current filter data
     * @param offsetX - The X offset for positioning
     * @param offsetY - The Y offset for positioning
     * @param resolution - The current resolution
     * @param isFinalTarget - Whether this is the final render target
     * @param clear - Whether to clear the output surface
     */
    _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
      const uniforms = this._filterGlobalUniforms.uniforms;
      const outputFrame = uniforms.uOutputFrame;
      const inputSize = uniforms.uInputSize;
      const inputPixel = uniforms.uInputPixel;
      const inputClamp = uniforms.uInputClamp;
      const globalFrame = uniforms.uGlobalFrame;
      const outputTexture = uniforms.uOutputTexture;
      const inputSource = input._source;
      const inputFrame = input.frame;
      const bounds = filterData.bounds;
      if (isFinalTarget) {
        outputFrame[0] = bounds.minX - offsetX;
        outputFrame[1] = bounds.minY - offsetY;
      } else {
        outputFrame[0] = 0;
        outputFrame[1] = 0;
      }
      outputFrame[2] = inputFrame.width;
      outputFrame[3] = inputFrame.height;
      inputSize[0] = inputSource.width;
      inputSize[1] = inputSource.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = inputSource.pixelWidth;
      inputPixel[1] = inputSource.pixelHeight;
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = inputFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = inputFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTextures[0];
      globalFrame[0] = offsetX * resolution;
      globalFrame[1] = offsetY * resolution;
      globalFrame[2] = rootTexture.width * resolution;
      globalFrame[3] = rootTexture.height * resolution;
      if (output.isTexture) output._source.resource = null;
      const renderTargetSystem = this.renderer.renderTarget;
      const renderTarget = renderTargetSystem.getRenderTarget(output);
      renderTargetSystem.bind(output, clear);
      if (output.isTexture) {
        const outputFrame = output.frame;
        outputTexture[0] = outputFrame.width;
        outputTexture[1] = outputFrame.height;
      } else {
        outputTexture[0] = renderTarget.width;
        outputTexture[1] = renderTarget.height;
      }
      outputTexture[2] = renderTarget.isRoot ? -1 : 1;
      this._filterGlobalUniforms.update();
    }
    /**
     * Finds the correct resolution by looking back through the filter stack.
     * @param rootResolution - The fallback root resolution to use
     * @returns The resolution from the previous filter or root resolution
     */
    _findFilterResolution(rootResolution) {
      let currentIndex = this._filterStackIndex - 1;
      const filterStack = this._filterStack;
      while (currentIndex > 0 && filterStack[currentIndex].skip) {
        --currentIndex;
      }
      if (currentIndex <= 0) return rootResolution;
      const filterData = filterStack[currentIndex];
      return filterData.inputTexture ? filterData.inputTexture._source._resolution : rootResolution;
    }
    /**
     * Finds the offset from the previous non-skipped filter in the stack.
     * @returns The offset coordinates from the previous filter
     */
    _findPreviousFilterBounds() {
      let bounds = this.emptyBounds;
      let lastIndex = this._filterStackIndex;
      const filterStack = this._filterStack;
      while (lastIndex > 0) {
        lastIndex--;
        const prevFilterData = filterStack[lastIndex];
        if (!prevFilterData.skip) {
          bounds = prevFilterData.bounds;
          break;
        }
      }
      return bounds;
    }
    /**
     * Calculates the filter area bounds based on the instruction type.
     * @param instruction - The filter instruction
     * @param bounds - The bounds object to populate
     */
    _calculateFilterArea(instruction, bounds) {
      const filterEffect = instruction.filterEffect;
      const container = instruction.container;
      if (filterEffect.filterArea !== null) {
        bounds.clear();
        bounds.addRect(filterEffect.filterArea);
        container.checkWorldTransform();
        container.updateWorldTransform();
        bounds.applyMatrix(container._worldTransform);
      } else if (instruction.renderables) {
        getGlobalRenderableBounds(instruction.renderables, bounds);
      } else {
        container.getFastGlobalBounds(true, bounds);
      }
    }
    /**
     * Applies filters to a texture.
     * @param {FilterData} filterData - The filter data to apply
     * @param {number} clear - Whether to clear the output surface
     */
    _applyFiltersToTexture(filterData, clear) {
      const inputTexture = filterData.inputTexture;
      const bounds = filterData.bounds;
      const filters = filterData.filters;
      const inputTextureSource = inputTexture._source;
      const inputTextureStyle = inputTextureSource._style;
      const backTextureSource = filterData.backTexture._source;
      const globalFilterBindGroup = this._globalFilterBindGroup;
      const outputRenderSurface = filterData.outputRenderSurface;
      globalFilterBindGroup.setResource(inputTextureStyle, 2);
      globalFilterBindGroup.setResource(backTextureSource, 3);
      if (filters.length === 1) {
        filters[0].apply(this, inputTexture, outputRenderSurface, clear);
      } else {
        let flip = filterData.inputTexture;
        const tempTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          flip._source._resolution,
          false
        );
        let flop = tempTexture;
        let i = 0;
        for (i = 0; i < filters.length - 1; ++i) {
          const filter = filters[i];
          filter.apply(this, flip, flop, CLEAR.ALL);
          const t = flip;
          flip = flop;
          flop = t;
        }
        filters[i].apply(this, flip, outputRenderSurface, CLEAR.ALL);
        TexturePool.returnTexture(tempTexture);
      }
    }
    _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
      const bounds = filterData.bounds;
      const filters = filterData.filters;
      let resolution = Infinity;
      let padding = 0;
      let antialias = true;
      let blendRequired = false;
      let enabled = false;
      let clipToViewport = true;
      for (let i = 0; i < filters.length; i++) {
        const filter = filters[i];
        resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
        padding += filter.padding;
        if (filter.antialias === "off") {
          antialias = false;
        } else if (filter.antialias === "inherit") {
          antialias && (antialias = rootAntialias);
        }
        if (!filter.clipToViewport) {
          clipToViewport = false;
        }
        enabled = filter.enabled || enabled;
        blendRequired || (blendRequired = filter.blendRequired);
      }
      if (!enabled) {
        filterData.skip = true;
        return;
      }
      if (clipToViewport) {
        bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
      }
      bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
      if (!bounds.isPositive) {
        filterData.skip = true;
        return;
      }
      filterData.antialias = antialias;
      filterData.resolution = resolution;
      filterData.blendRequired = blendRequired;
    }
    /**
     * Pops a filter data from the filter stack.
     * @returns {FilterData}
     */
    _popFilterData() {
      return this._filterStack[--this._filterStackIndex];
    }
    /**
     * Gets the previous filter data from the filter stack.
     * @returns {FilterData}
     */
    _getPreviousFilterData() {
      let previousFilterData;
      let index = this._filterStackIndex - 1;
      const filterStack = this._filterStack;
      while (index > 0) {
        index--;
        previousFilterData = filterStack[index];
        if (!previousFilterData.skip) {
          break;
        }
      }
      return previousFilterData;
    }
    /**
     * Pushes a filter data onto the filter stack.
     * @returns {FilterData}
     */
    _pushFilterData() {
      const filterStack = this._filterStack;
      let filterData = filterStack[this._filterStackIndex];
      if (!filterData) {
        filterData = filterStack[this._filterStackIndex] = new FilterData();
      }
      this._filterStackIndex++;
      return filterData;
    }
  }
  FilterSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "filter"
  };
  extensions.add(FilterSystem);
  extensions.add(FilterPipe);

  "use strict";
  var CLEAR = /* @__PURE__ */ ((CLEAR2) => {
    CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
    CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
    CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
    CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
    CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
    CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
    CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
    CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
    return CLEAR2;
  })(CLEAR || {});

  "use strict";
  class SystemRunner {
    /**
     * @param name - The function name that will be executed on the listeners added to this Runner.
     */
    constructor(name) {
      this.items = [];
      this._name = name;
      this._count = 0;
    }
    /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
    /**
     * Dispatch/Broadcast Runner to all listeners added to the queue.
     * @param {...any} params - (optional) parameters to pass to each listener
     */
    /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
    emit(a0, a1, a2) {
      const name = this._name;
      const items = this.items;
      const count = this._count;
      if (count === 0) return;
      for (let i = 0; i < count; i++) {
        items[i][name](a0, a1, a2);
      }
      return this;
    }
    /**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * import { Runner } from 'pixi.js';
     *
     * const complete = new Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     * @param {any} item - The object that will be listening.
     */
    add(item) {
      if (item[this._name]) {
        if (this.items.add(item)) this._count += 1;
      }
      return this;
    }
    /**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listener that you would like to remove.
     */
    remove(item) {
      if (this.items.remove(item)) this._count -= 1;
      return this;
    }
    /**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */
    contains(item) {
      return this.items.indexOf(item) !== -1;
    }
    /** Remove all listeners from the Runner */
    removeAll() {
      this.items.length = 0;
      return this;
    }
    /** Remove all references, don't use after this. */
    destroy() {
      this.removeAll();
      this.items = null;
      this._name = null;
    }
    /**
     * `true` if there are no this Runner contains no listeners
     * @readonly
     */
    get empty() {
      return this.items.length === 0;
    }
    /**
     * The name of the runner.
     * @readonly
     */
    get name() {
      return this._name;
    }
  }

  "use strict";
  class AbstractRenderer extends EventEmitter {
    /**
     * Set up a system with a collection of SystemClasses and runners.
     * Systems are attached dynamically to this class when added.
     * @param config - the config for the system manager
     */
    constructor(config) {
      var _a;
      super();
      const defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      this._systemsHash = Object.create(null);
      this.runners = /* @__PURE__ */ Object.create(null);
      this.renderPipes = /* @__PURE__ */ Object.create(null);
      this._initOptions = {};
      this.type = config.type;
      this.name = config.name;
      this.config = config;
      const combinedRunners = [...defaultRunners, ...(_a = this.config.runners) != null ? _a : Array.empty];
      this._addRunners(...combinedRunners);
    }
    resetState() {
      this.runners.resetState.emit();
    }
    /**
     * Initialize the renderer.
     * @param options - The options to use to create the renderer.
     */
    async init(options = {}) {
      const config = this.config;
      const systems = config.systems;
      const renderPipes = config.renderPipes;
      const renderPipeAdaptors = config.renderPipeAdaptors;
      this._addSystems(systems);
      const systemsHash = this._systemsHash;
      for (const systemName in systemsHash) {
        const system = systemsHash[systemName];
        const defaultSystemOptions = system.constructor.defaultOptions;
        options = __spreadValues$G(__spreadValues$G({}, defaultSystemOptions), options);
      }
      options = __spreadValues$G(__spreadValues$G({}, AbstractRenderer.defaultOptions), options);
      this._systemsHash = null;
      this._roundPixels = options.roundPixels ? 1 : 0;
      const items = this.runners.init.items;
      for (let i = 0; i < items.length; i++) {
        await items[i].init(options);
      }
      this._addPipes(renderPipes, renderPipeAdaptors);
      this._initOptions = options;
    }
    render(options = {}) {
      const view = this.view;
      options.target || (options.target = view.renderTarget);
      if (options.target === view.renderTarget) {
        this._lastObjectRendered = options.container;
        options.clearColor = this.background._backgroundColor;
      }
      if (options.transform === void 0) {
        options.container.updateLocalTransform();
        options.transform = options.container.localTransform;
      }
      const runners = this.runners;
      runners.prerender.emit(options);
      runners.renderStart.emit(options);
      runners.render.emit(options);
      runners.renderEnd.emit(options);
      runners.postrender.emit(options);
    }
    /**
     * Resizes the WebGL view to the specified width and height.
     * @param desiredScreenWidth - The desired width of the screen.
     * @param desiredScreenHeight - The desired height of the screen.
     * @param resolution - The resolution / device pixel ratio of the renderer.
     */
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      const view = this.view;
      const screen = view.screen;
      const previousResolution = view.resolution;
      view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      this.emit("resize", screen.width, screen.height, view.resolution);
      if (resolution !== void 0 && resolution !== previousResolution) {
        this.runners.resolutionChange.emit(resolution);
      }
    }
    clear(options) {
      const renderTarget = this.renderTarget;
      const clear = options.clear || "clear";
      const clearColor = options.clearColor || this.background.colorRgba;
      const target = options.target || renderTarget.renderTarget;
      const color = Color.shared.setValue(clearColor);
      renderTarget.clear(target, clear, color);
    }
    /** The resolution / device pixel ratio of the renderer. */
    get resolution() {
      return this.view.resolution;
    }
    set resolution(value) {
      this.view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    /**
     * Same as view.width, actual number of pixels in the canvas by horizontal.
     * @member {number}
     * @readonly
     * @default 800
     */
    get width() {
      return this.view.texture.frame.width;
    }
    /**
     * Same as view.height, actual number of pixels in the canvas by vertical.
     * @default 600
     */
    get height() {
      return this.view.texture.frame.height;
    }
    // NOTE: this was `view` in v7
    /**
     * The canvas element that everything is drawn to.
     * @type {environment.ICanvas}
     */
    get canvas() {
      return this.view.canvas;
    }
    /**
     * the last object rendered by the renderer. Useful for other plugins like interaction managers
     * @readonly
     */
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    /**
     * Flag if we are rendering to the screen vs renderTexture
     * @readonly
     * @default true
     */
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    /**
     * Measurements of the screen. (0, 0, screenWidth, screenHeight).
     *
     * Its safe to use as filterArea or hitArea for the whole stage.
     */
    get screen() {
      return this.view.screen;
    }
    /**
     * Create a bunch of runners based of a collection of ids
     * @param runnerIds - the runner ids to add
     */
    _addRunners(...runnerIds) {
      const runners = this.runners;
      for (let i = 0; i < runnerIds.length; i++) {
        const runnerId = runnerIds[i];
        runners[runnerId] = new SystemRunner(runnerId);
      }
    }
    _addSystems(systems) {
      for (const val of systems) {
        this._addSystem(val.value, val.name);
      }
    }
    /**
     * Add a new system to the renderer.
     * @param ClassRef - Class reference
     * @param name - Property name for system, if not specified
     *        will use a static `name` property on the class itself. This
     *        name will be assigned as s property on the Renderer so make
     *        sure it doesn't collide with properties on Renderer.
     * @returns Return instance of renderer
     */
    _addSystem(ClassRef, name) {
      const system = new ClassRef(this);
      if (this[name]) {
        throw new Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = system;
      this._systemsHash[name] = system;
      const runners = this.runners;
      for (const i in runners) {
        runners[i].add(system);
      }
      return this;
    }
    _addPipes(pipes, pipeAdaptors) {
      const adaptors = {};
      for (let i = 0; i < pipeAdaptors.length; i++) {
        const adaptor = pipeAdaptors[i];
        adaptors[adaptor.name] = adaptor.value;
      }
      const renderPipes = this.renderPipes;
      for (let i = 0; i < pipes.length; i++) {
        const pipe = pipes[i];
        const name = pipe.name;
        const pipeClass = pipe.value;
        const adaptorClass = adaptors[name];
        const adaptor = adaptorClass ? new adaptorClass() : null;
        renderPipes[name] = new pipeClass(this, adaptor);
      }
    }
    destroy(options = false) {
      this.runners.destroy.items.reverse();
      this.runners.destroy.emit(options);
      Object.values(this.runners).forEach((runner) => {
        runner.destroy();
      });
      this.renderPipes = null;
    }
    /**
     * Generate a texture from a container.
     * @param options - options or container target to use when generating the texture
     * @returns a texture
     */
    generateTexture(options) {
      return this.textureGenerator.generateTexture(options);
    }
    /**
     * Whether the renderer will round coordinates to whole pixels when rendering.
     * Can be overridden on a per scene item basis.
     */
    get roundPixels() {
      return !!this._roundPixels;
    }
  };
  /** The default options for the renderer. */
  AbstractRenderer.defaultOptions = {
    /**
     * Default resolution / device pixel ratio of the renderer.
     * @default 1
     */
    resolution: 1,
    /**
     * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
     * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
     * performance issues when using WebGL.
     *
     * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
     * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
     * driver version blacklisted by the
     * browser.
     *
     * If your application requires high performance rendering, you may wish to set this to false.
     * We recommend one of two options if you decide to set this flag to false:
     *
     * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
     *    not supported.
     *
     * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
     *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
     *    device & browser combination does not support high performance WebGL.
     *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
     * @default false
     */
    failIfMajorPerformanceCaveat: false,
    /**
     * Should round pixels be forced when rendering?
     * @default false
     */
    roundPixels: false
  };

  "use strict";
  let _isWebGLSupported;
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat != null ? failIfMajorPerformanceCaveat : AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!globalThis.WebGLRenderingContext) {
          return false;
        }
        let canvas = document.createElement("canvas");
        let gl = canvas.getContext("webgl", contextOptions);
        const success = gl !== null;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        canvas.remove();
        canvas = null;
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }

  "use strict";
  let _isWebGPUSupported;
  async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = globalThis.navigator.gpu;
      if (!gpu) {
        return false;
      }
      let device = null;
      try {
        const adapter = await gpu.requestAdapter(options);
        device = await adapter.requestDevice();
        return true;
      } catch (e) {
        return false;
      } finally {
        if (device) {
          device.destroy();
        }
      }
    })();
    return _isWebGPUSupported;
  }

  "use strict";
  var __defProp$H = Object.defineProperty;
  var __getOwnPropSymbols$H = Object.getOwnPropertySymbols;
  var __hasOwnProp$H = Object.prototype.hasOwnProperty;
  var __propIsEnum$H = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$H = (obj, key, value) => key in obj ? __defProp$H(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$H = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$H.call(b, prop))
        __defNormalProp$H(a, prop, b[prop]);
    if (__getOwnPropSymbols$H)
      for (var prop of __getOwnPropSymbols$H(b)) {
        if (__propIsEnum$H.call(b, prop))
          __defNormalProp$H(a, prop, b[prop]);
      }
    return a;
  };
  const renderPriority = ["webgpu", "webgl"];
  async function autoDetectRenderer(options) {
    var _a;
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      for (let i = 0; i < renderPriority.length; i++) {
        const item = renderPriority[i];
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      }
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    let finalOptions = {};
    for (let i = 0; i < preferredOrder.length; i++) {
      const rendererType = preferredOrder[i];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer } = WebGPURenderer$1;
        RendererClass = WebGPURenderer;
        finalOptions = __spreadValues$H(__spreadValues$H({}, options), options.webgpu);
        break;
      } else if (rendererType === "webgl" && isWebGLSupported(
        (_a = options.failIfMajorPerformanceCaveat) != null ? _a : AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      )) {
        const { WebGLRenderer } = WebGLRenderer$1;
        RendererClass = WebGLRenderer;
        finalOptions = __spreadValues$H(__spreadValues$H({}, options), options.webgl);
        break;
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    Engine.renderer = renderer;
    await renderer.init(finalOptions);
    return renderer;
  }

  const VERSION = "8.12.0";

  "use strict";
  var __defProp$G = Object.defineProperty;
  var __getOwnPropSymbols$G = Object.getOwnPropertySymbols;
  var __hasOwnProp$G = Object.prototype.hasOwnProperty;
  var __propIsEnum$G = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$G = (obj, key, value) => key in obj ? __defProp$G(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$G = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$G.call(b, prop))
        __defNormalProp$G(a, prop, b[prop]);
    if (__getOwnPropSymbols$G)
      for (var prop of __getOwnPropSymbols$G(b)) {
        if (__propIsEnum$G.call(b, prop))
          __defNormalProp$G(a, prop, b[prop]);
      }
    return a;
  };

  function crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }

  "use strict";
  class Filter extends Shader {
    /**
     * @param options - The optional parameters of this filter.
     */
    constructor(options = Filter.defaultOptions) {
      super(options);
      /** If enabled is true the filter is applied, if false it will not. */
      this.enabled = true;
      /**
       * The gpu state the filter requires to render.
       * @internal
       * @ignore
       */
      this._state = State.for2d();
      this.blendMode = options.blendMode || Filter.defaultOptions.blendMode;
      this.padding = options.padding || Filter.defaultOptions.padding;
      if (typeof options.antialias === "boolean") {
        this.antialias = options.antialias ? "on" : "off";
      } else {
        this.antialias = options.antialias || Filter.defaultOptions.antialias;
      }
      this.resolution = options.resolution || Filter.defaultOptions.resolution;
      this.blendRequired = options.blendRequired || Filter.defaultOptions.blendRequired;
      this.clipToViewport = options.clipToViewport || Filter.defaultOptions.clipToViewport;
      this.addResource("uTexture", 0, 1);
    }
    /**
     * Applies the filter
     * @param filterManager - The renderer to retrieve the filter from
     * @param input - The input render target.
     * @param output - The target to output to.
     * @param clearMode - Should the output be cleared before rendering to it
     */
    apply(filterManager, input, output, clearMode) {
      filterManager.applyFilter(this, input, output, clearMode);
    }
    /**
     * Get the blend mode of the filter.
     * @default "normal"
     */
    get blendMode() {
      return this._state.blendMode;
    }
    /** Sets the blend mode of the filter. */
    set blendMode(value) {
      this._state.blendMode = value;
    }
    /**
     * A short hand function to create a filter based of a vertex and fragment shader src.
     * @param options
     * @returns A shiny new PixiJS filter!
     */
    static from(options) {
      const { gpu, gl } = options;
      let gpuProgram;
      let glProgram;
      if (gpu) {
        gpuProgram = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram = GlProgram.from(gl);
      }
      return new _Filter({
        gpuProgram,
        glProgram,
      });
    }
  };
  /**
   * The default filter settings
   * @static
   */
  Filter.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: false,
    clipToViewport: true,
    gpuProgram: null,
    glProgram: null
  };

  var blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uBlend;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(uBackTexture, vTextureCoord);\n    vec4 front = texture(uTexture, vTextureCoord);\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\n    \n    {MAIN}\n}\n";

  var blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  var blendTemplate = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(uBackTexture, uSampler, uv);\n   var front = textureSample(uTexture, uSampler, uv);\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";

  "use strict";
  var __defProp$z = Object.defineProperty;
  var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
  var __hasOwnProp$z = Object.prototype.hasOwnProperty;
  var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$z = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$z = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$z.call(b, prop))
        __defNormalProp$z(a, prop, b[prop]);
    if (__getOwnPropSymbols$z)
      for (var prop of __getOwnPropSymbols$z(b)) {
        if (__propIsEnum$z.call(b, prop))
          __defNormalProp$z(a, prop, b[prop]);
      }
    return a;
  };
  class BlendModeFilter extends Filter {
    constructor(options) {
      const gpuOptions = options.gpu;
      const gpuSource = compileBlendModeShader(__spreadValues$z({ source: blendTemplate }, gpuOptions));
      const gpuProgram = GpuProgram.from({
        vertex: {
          source: gpuSource,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: gpuSource,
          entryPoint: "mainFragment"
        }
      });
      const glOptions = options.gl;
      const glSource = compileBlendModeShader(__spreadValues$z({ source: blendTemplateFrag }, glOptions));
      const glProgram = GlProgram.from({
        vertex: blendTemplateVert,
        fragment: glSource
      });
      const uniformGroup = new UniformGroup({
        uBlend: {
          value: 1,
          type: "f32"
        }
      });
      super({
        gpuProgram,
        glProgram,
        blendRequired: true,
        resources: {
          blendUniforms: uniformGroup,
          uBackTexture: Texture.EMPTY
        }
      });
    }
  }
  function compileBlendModeShader(options) {
    const { source, functions, main } = options;
    return source.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
  }

  "use strict";
  const hslgl = `
    float getLuminosity(vec3 c) {
        return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
    }

    vec3 setLuminosity(vec3 c, float lum) {
        float modLum = lum - getLuminosity(c);
        vec3 color = c.rgb + vec3(modLum);

        // clip back into legal range
        modLum = getLuminosity(color);
        vec3 modLumVec = vec3(modLum);

        float cMin = min(color.r, min(color.g, color.b));
        float cMax = max(color.r, max(color.g, color.b));

        if(cMin < 0.0) {
            color = mix(modLumVec, color, modLum / (modLum - cMin));
        }

        if(cMax > 1.0) {
            color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
        }

        return color;
    }

    float getSaturation(vec3 c) {
        return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
    }

    vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
        vec3 colorSorted = cSorted;

        if(colorSorted.z > colorSorted.x) {
            colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
            colorSorted.z = s;
        }
        else {
            colorSorted.y = 0.0;
            colorSorted.z = 0.0;
        }

        colorSorted.x = 0.0;

        return colorSorted;
    }

    vec3 setSaturation(vec3 c, float s) {
        vec3 color = c;

        if(color.r <= color.g && color.r <= color.b) {
            if(color.g <= color.b) {
                color = setSaturationMinMidMax(color.rgb, s).rgb;
            }
            else {
                color = setSaturationMinMidMax(color.rbg, s).rbg;
            }
        }
        else if(color.g <= color.r && color.g <= color.b) {
            if(color.r <= color.b) {
                color = setSaturationMinMidMax(color.grb, s).grb;
            }
            else {
                color = setSaturationMinMidMax(color.gbr, s).gbr;
            }
        }
        else {
            // Using bgr for both fixes part of hue
            if(color.r <= color.g) {
                color = setSaturationMinMidMax(color.brg, s).brg;
            }
            else {
                color = setSaturationMinMidMax(color.bgr, s).bgr;
            }
        }

        return color;
    }
    `;

  "use strict";
  const hslgpu = `
    fn getLuminosity(c: vec3<f32>) -> f32
    {
        return 0.3*c.r + 0.59*c.g + 0.11*c.b;
    }

    fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
    {
        var modLum: f32 = lum - getLuminosity(c);
        var color: vec3<f32> = c.rgb + modLum;

        // clip back into legal range
        modLum = getLuminosity(color);
        let modLumVec = vec3<f32>(modLum);

        let cMin: f32 = min(color.r, min(color.g, color.b));
        let cMax: f32 = max(color.r, max(color.g, color.b));

        if(cMin < 0.0)
        {
            color = mix(modLumVec, color, modLum / (modLum - cMin));
        }

        if(cMax > 1.0)
        {
            color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
        }

        return color;
    }

    fn getSaturation(c: vec3<f32>) -> f32
    {
        return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
    }

    fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
    {
        var colorSorted = cSorted;

        if(colorSorted.z > colorSorted.x)
        {
            colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
            colorSorted.z = s;
        }
        else
        {
            colorSorted.y = 0;
            colorSorted.z = 0;
        }

        colorSorted.x = 0;

        return colorSorted;
    }

    fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
    {
        var color = c;

        if (color.r <= color.g && color.r <= color.b)
        {
            if (color.g <= color.b)
            {
                color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
            }
            else
            {
                color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
            }
        }
        else if (color.g <= color.r && color.g <= color.b)
        {
            if (color.r <= color.b)
            {
                color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
            }
            else
            {
                color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
            }
        }
        else
        {
            // Using bgr for both fixes part of hue
            if (color.r <= color.g)
            {
                color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
            }
            else
            {
                color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
            }
        }

        return color;
    }
    `;

  var vertex$2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  var fragment$4 = "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";

  var source$5 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";

  "use strict";

  class AlphaFilter extends Filter {
    constructor(options = AlphaFilter.defaultOptions) {
      const gpuProgram = GpuProgram.from({
        vertex: {
          source: source$5,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source$5,
          entryPoint: "mainFragment"
        }
      });
      const glProgram = GlProgram.from({
        vertex: vertex$2,
        fragment: fragment$4,
        name: "alpha-filter"
      });
      const alpha = options.alpha !== void 0 ? options.alpha : AlphaFilter.defaultOptions.alpha;
      const alphaUniforms = new UniformGroup({
        uAlpha: { value: alpha, type: "f32" }
      });
      options.gpuProgram = gpuProgram;
      options.glProgram = glProgram;
      options.resources = { alphaUniforms };
      super(options);
      this._uniforms = alphaUniforms.uniforms;
    }
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get alpha() {
      return this._uniforms.uAlpha;
    }
    set alpha(value) {
      this._uniforms.uAlpha = value;
    }
    reset() {
      this._uniforms.uAlpha = 1;
    }
  };
  /** Default filter options */
  AlphaFilter.defaultOptions = {
    /** Amount of alpha from 0 to 1, where 0 is transparent */
    alpha: 1
  };

  "use strict";
  const GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
  };

  "use strict";
  const fragTemplate = [
    "in vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uTexture;",
    "out vec4 finalColor;",
    "void main(void)",
    "{",
    "    finalColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join("\n");
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    let fragSource = fragTemplate;
    let blurLoop = "";
    const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let value;
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      value = i;
      if (i >= halfLength) {
        value = kernelSize - i - 1;
      }
      blur = blur.replace("%value%", kernel[value].toString());
      blurLoop += blur;
      blurLoop += "\n";
    }
    fragSource = fragSource.replace("%blur%", blurLoop);
    fragSource = fragSource.replace("%size%", kernelSize.toString());
    return fragSource;
  }

  "use strict";
  const vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function generateBlurVertSource(kernelSize, x) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate;
    let blurLoop = "";
    let template;
    if (x) {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
    } else {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    }
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
      blurLoop += blur;
      blurLoop += "\n";
    }
    vertSource = vertSource.replace("%blur%", blurLoop);
    vertSource = vertSource.replace("%size%", kernelSize.toString());
    vertSource = vertSource.replace("%dimension%", x ? "z" : "w");
    return vertSource;
  }

  "use strict";
  function generateBlurGlProgram(horizontal, kernelSize) {
    const vertex = generateBlurVertSource(kernelSize, horizontal);
    const fragment = generateBlurFragSource(kernelSize);
    return GlProgram.from({
      vertex,
      fragment,
      name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
    });
  }

  var source$4 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";

  "use strict";
  function generateBlurProgram(horizontal, kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    const blurStructSource = [];
    const blurOutSource = [];
    const blurSamplingSource = [];
    for (let i = 0; i < kernelSize; i++) {
      blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;
      if (horizontal) {
        blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;
      } else {
        blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;
      }
      const kernelIndex = i < halfLength ? i : kernelSize - i - 1;
      const kernelValue = kernel[kernelIndex].toString();
      blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;
    }
    const blurStruct = blurStructSource.join("\n");
    const blurOut = blurOutSource.join("\n");
    const blurSampling = blurSamplingSource.join("\n");
    const finalSource = source$4.replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
    return GpuProgram.from({
      vertex: {
        source: finalSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: finalSource,
        entryPoint: "mainFragment"
      }
    });
  }

  "use strict";
  var __defProp$x = Object.defineProperty;
  var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
  var __hasOwnProp$x = Object.prototype.hasOwnProperty;
  var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$x = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$x = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$x.call(b, prop))
        __defNormalProp$x(a, prop, b[prop]);
    if (__getOwnPropSymbols$x)
      for (var prop of __getOwnPropSymbols$x(b)) {
        if (__propIsEnum$x.call(b, prop))
          __defNormalProp$x(a, prop, b[prop]);
      }
    return a;
  };
  const _BlurFilterPass = class _BlurFilterPass extends Filter {
    /**
     * @param options
     * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
     * @param options.strength - The strength of the blur filter.
     * @param options.quality - The quality of the blur filter.
     * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */
    constructor(options) {
      options = __spreadValues$x(__spreadValues$x({}, _BlurFilterPass.defaultOptions), options);
      const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);
      const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);
      const blurUniforms = new UniformGroup({
        uStrength: { value: 0, type: "f32" }
      });
      super(__spreadValues$x({
        glProgram,
        gpuProgram,
        resources: {
          blurUniforms
        }
      }, options));
      this.horizontal = options.horizontal;
      this._quality = 0;
      this.quality = options.quality;
      this.blur = options.strength;
      this._uniforms = blurUniforms.uniforms;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - How to clear
     */
    apply(filterManager, input, output, clearMode) {
      this._uniforms.uStrength = this.strength / this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const tempTexture = TexturePool.getSameSizeTexture(input);
        let flip = input;
        let flop = tempTexture;
        const state = this._state;
        state.blend = false;
        const shouldClear = filterManager.renderer.type === RendererType.WEBGPU ? "clear" : "load";
        for (let i = 0; i < this.passes - 1; i++) {
          filterManager.applyFilter(this, flip, flop, i === 0 ? "clear" : shouldClear);
          const temp = flop;
          flop = flip;
          flip = temp;
        }
        state.blend = true;
        filterManager.applyFilter(this, flip, output, clearMode);
        TexturePool.returnTexture(tempTexture);
      }
    }
    /**
     * Sets the strength of both the blur.
     * @default 16
     */
    get blur() {
      return this.strength;
    }
    set blur(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    }
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quality blurring but the lower the performance.
     * @default 4
     */
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this._quality = value;
      this.passes = value;
    }
  };
  /** Default blur filter pass options */
  _BlurFilterPass.defaultOptions = {
    /** The strength of the blur filter. */
    strength: 8,
    /** The quality of the blur filter. */
    quality: 4,
    /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
    kernelSize: 5
  };
  let BlurFilterPass = _BlurFilterPass;

  "use strict";
  var __defProp$w = Object.defineProperty;
  var __defProps$g = Object.defineProperties;
  var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
  var __hasOwnProp$w = Object.prototype.hasOwnProperty;
  var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$w = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$w = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$w.call(b, prop))
        __defNormalProp$w(a, prop, b[prop]);
    if (__getOwnPropSymbols$w)
      for (var prop of __getOwnPropSymbols$w(b)) {
        if (__propIsEnum$w.call(b, prop))
          __defNormalProp$w(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
  var __objRest$e = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$w.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$w)
      for (var prop of __getOwnPropSymbols$w(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$w.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class BlurFilter extends Filter {
    constructor(...args) {
      var _a;
      let options = (_a = args[0]) != null ? _a : {};
      if (typeof options === "number") {
        deprecation(v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
        options = { strength: options };
        if (args[1] !== void 0)
          options.quality = args[1];
        if (args[2] !== void 0)
          options.resolution = args[2] || "inherit";
        if (args[3] !== void 0)
          options.kernelSize = args[3];
      }
      options = __spreadValues$w(__spreadValues$w({}, BlurFilterPass.defaultOptions), options);
      const _b = options, { strength, strengthX, strengthY, quality } = _b, rest = __objRest$e(_b, ["strength", "strengthX", "strengthY", "quality"]);
      super(__spreadProps$g(__spreadValues$w({}, rest), {
        resources: {}
      }));
      this._repeatEdgePixels = false;
      this.blurXFilter = new BlurFilterPass(__spreadValues$w({ horizontal: true }, options));
      this.blurYFilter = new BlurFilterPass(__spreadValues$w({ horizontal: false }, options));
      this.quality = quality;
      this.strengthX = strengthX != null ? strengthX : strength;
      this.strengthY = strengthY != null ? strengthY : strength;
      this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - How to clear
     */
    apply(filterManager, input, output, clearMode) {
      const xStrength = Math.abs(this.blurXFilter.strength);
      const yStrength = Math.abs(this.blurYFilter.strength);
      if (xStrength && yStrength) {
        const tempTexture = TexturePool.getSameSizeTexture(input);
        this.blurXFilter.blendMode = "normal";
        this.blurXFilter.apply(filterManager, input, tempTexture, true);
        this.blurYFilter.blendMode = this.blendMode;
        this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
        TexturePool.returnTexture(tempTexture);
      } else if (yStrength) {
        this.blurYFilter.blendMode = this.blendMode;
        this.blurYFilter.apply(filterManager, input, output, clearMode);
      } else {
        this.blurXFilter.blendMode = this.blendMode;
        this.blurXFilter.apply(filterManager, input, output, clearMode);
      }
    }
    updatePadding() {
      if (this._repeatEdgePixels) {
        this.padding = 0;
      } else {
        this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
      }
    }
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 8
     */
    get strength() {
      if (this.strengthX !== this.strengthY) {
        throw new Error("BlurFilter's strengthX and strengthY are different");
      }
      return this.strengthX;
    }
    set strength(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    /**
     * Sets the strength of horizontal blur
     * @default 8
     */
    get strengthX() {
      return this.blurXFilter.blur;
    }
    set strengthX(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the strength of the vertical blur
     * @default 8
     */
    get strengthY() {
      return this.blurYFilter.blur;
    }
    set strengthY(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strength
     */
    get blur() {
      deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
      return this.strength;
    }
    set blur(value) {
      deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
      this.strength = value;
    }
    /**
     * Sets the strength of the blurX property
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strengthX
     */
    get blurX() {
      deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
      return this.strengthX;
    }
    set blurX(value) {
      deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
      this.strengthX = value;
    }
    /**
     * Sets the strength of the blurY property
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strengthY
     */
    get blurY() {
      deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
      return this.strengthY;
    }
    set blurY(value) {
      deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
      this.strengthY = value;
    }
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    }
  }
  /** Default blur filter options */
  BlurFilter.defaultOptions = {
    /** The strength of the blur filter. */
    strength: 8,
    /** The quality of the blur filter. */
    quality: 4,
    /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
    kernelSize: 5
  };

  var fragment$3 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";

  var source$3 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";

  "use strict";
  var __defProp$v = Object.defineProperty;
  var __defProps$f = Object.defineProperties;
  var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
  var __hasOwnProp$v = Object.prototype.hasOwnProperty;
  var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$v = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$v = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$v.call(b, prop))
        __defNormalProp$v(a, prop, b[prop]);
    if (__getOwnPropSymbols$v)
      for (var prop of __getOwnPropSymbols$v(b)) {
        if (__propIsEnum$v.call(b, prop))
          __defNormalProp$v(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
  class ColorMatrixFilter extends Filter {
    constructor(options = {}) {
      const colorMatrixUniforms = new UniformGroup({
        uColorMatrix: {
          value: [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ],
          type: "f32",
          size: 20
        },
        uAlpha: {
          value: 1,
          type: "f32"
        }
      });
      const gpuProgram = GpuProgram.from({
        vertex: {
          source: source$3,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source$3,
          entryPoint: "mainFragment"
        }
      });
      const glProgram = GlProgram.from({
        vertex: vertex$2,
        fragment: fragment$3,
        name: "color-matrix-filter"
      });
      super(__spreadProps$f(__spreadValues$v({}, options), {
        gpuProgram,
        glProgram,
        resources: {
          colorMatrixUniforms
        }
      }));
      this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     * @param {number[]} matrix - 5x4 matrix
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(matrix, multiply = false) {
      let newMatrix = matrix;
      if (multiply) {
        this._multiply(newMatrix, this.matrix, matrix);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;
      this.resources.colorMatrixUniforms.update();
    }
    /**
     * Multiplies two mat5's
     * @private
     * @param out - 5x4 matrix the receiving matrix
     * @param a - 5x4 matrix the first operand
     * @param b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out, a, b) {
      out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
      out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
      out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
      out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
      out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
      out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
      out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
      out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
      out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
      out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
      out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
      out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
      out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
      out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
      out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
      out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
      out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
      out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
      out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
      out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
      return out;
    }
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     * @param {number[]} matrix - 5x4 matrix
     * @returns {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
      const m = new Float32Array(matrix);
      m[4] /= 255;
      m[9] /= 255;
      m[14] /= 255;
      m[19] /= 255;
      return m;
    }
    /**
     * Adjusts brightness
     * @param b - value of the brightness (0-1, where 0 is black)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(b, multiply) {
      const matrix = [
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Sets each channel on the diagonal of the color matrix.
     * This can be used to achieve a tinting effect on Containers similar to the tint field of some
     * display objects like Sprite, Text, Graphics, and Mesh.
     * @param color - Color of the tint. This is a hex value.
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    tint(color, multiply) {
      const [r, g, b] = Color.shared.setValue(color);
      const matrix = [
        r,
        0,
        0,
        0,
        0,
        0,
        g,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Set the matrices in grey scales
     * @param scale - value of the grey (0-1, where 0 is black)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(scale, multiply) {
      const matrix = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * for our american friends!
     * @param scale
     * @param multiply
     */
    grayscale(scale, multiply) {
      this.greyscale(scale, multiply);
    }
    /**
     * Set the black and white matrice.
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(multiply) {
      const matrix = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Set the hue property of the color
     * @param rotation - in degrees
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(rotation, multiply) {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);
      const sqrt = Math.sqrt;
      const w = 1 / 3;
      const sqrW = sqrt(w);
      const a00 = cosR + (1 - cosR) * w;
      const a01 = w * (1 - cosR) - sqrW * sinR;
      const a02 = w * (1 - cosR) + sqrW * sinR;
      const a10 = w * (1 - cosR) + sqrW * sinR;
      const a11 = cosR + w * (1 - cosR);
      const a12 = w * (1 - cosR) - sqrW * sinR;
      const a20 = w * (1 - cosR) - sqrW * sinR;
      const a21 = w * (1 - cosR) + sqrW * sinR;
      const a22 = cosR + w * (1 - cosR);
      const matrix = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     * @param amount - value of the contrast (0-1)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(amount, multiply) {
      const v = (amount || 0) + 1;
      const o = -0.5 * (v - 1);
      const matrix = [
        v,
        0,
        0,
        0,
        o,
        0,
        v,
        0,
        0,
        o,
        0,
        0,
        v,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     * @param amount - The saturation amount (0-1)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(amount = 0, multiply) {
      const x = amount * 2 / 3 + 1;
      const y = (x - 1) * -0.5;
      const matrix = [
        x,
        y,
        y,
        0,
        0,
        y,
        x,
        y,
        0,
        0,
        y,
        y,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /** Desaturate image (remove color) Call the saturate function */
    desaturate() {
      this.saturate(-1);
    }
    /**
     * Negative image (inverse of classic rgb matrix)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(multiply) {
      const matrix = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Sepia image
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(multiply) {
      const matrix = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(multiply) {
      const matrix = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Polaroid filter
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(multiply) {
      const matrix = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(multiply) {
      const matrix = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(multiply) {
      const matrix = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(multiply) {
      const matrix = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Vintage filter (thanks Dominic Szablewski)
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(multiply) {
      const matrix = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     * @param desaturation - Tone values.
     * @param toned - Tone values.
     * @param lightColor - Tone values, example: `0xFFE580`
     * @param darkColor - Tone values, example: `0xFFE580`
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
      desaturation = desaturation || 0.2;
      toned = toned || 0.15;
      lightColor = lightColor || 16770432;
      darkColor = darkColor || 3375104;
      const temp = Color.shared;
      const [lR, lG, lB] = temp.setValue(lightColor);
      const [dR, dG, dB] = temp.setValue(darkColor);
      const matrix = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Night effect
     * @param intensity - The intensity of the night effect.
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(intensity, multiply) {
      intensity = intensity || 0.1;
      const matrix = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new independent one
     * @param amount - how much the predator feels his future victim
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(amount, multiply) {
      const matrix = [
        // row 1
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        // row 2
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        // row 3
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * LSD effect
     *
     * Multiply the current matrix
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(multiply) {
      const matrix = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /** Erase the current matrix by setting the default one. */
    reset() {
      const matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, false);
    }
    /**
     * The matrix of the color matrix filter
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
      return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
    }
    set matrix(value) {
      this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;
    }
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     * @default 1
     */
    get alpha() {
      return this.resources.colorMatrixUniforms.uniforms.uAlpha;
    }
    set alpha(value) {
      this.resources.colorMatrixUniforms.uniforms.uAlpha = value;
    }
  }

  var fragment$2 = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";

  var vertex$1 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";

  var source$2 = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";

  "use strict";
  var __defProp$u = Object.defineProperty;
  var __defProps$e = Object.defineProperties;
  var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
  var __hasOwnProp$u = Object.prototype.hasOwnProperty;
  var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$u = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$u.call(b, prop))
        __defNormalProp$u(a, prop, b[prop]);
    if (__getOwnPropSymbols$u)
      for (var prop of __getOwnPropSymbols$u(b)) {
        if (__propIsEnum$u.call(b, prop))
          __defNormalProp$u(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
  var __objRest$d = (source2, exclude) => {
    var target = {};
    for (var prop in source2)
      if (__hasOwnProp$u.call(source2, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$u)
      for (var prop of __getOwnPropSymbols$u(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$u.call(source2, prop))
          target[prop] = source2[prop];
      }
    return target;
  };
  class DisplacementFilter extends Filter {
    constructor(...args) {
      let options = args[0];
      if (options instanceof Sprite) {
        if (args[1]) {
          deprecation(v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
        }
        options = { sprite: options, scale: args[1] };
      }
      const _a = options, { sprite, scale: scaleOption } = _a, rest = __objRest$d(_a, ["sprite", "scale"]);
      let scale = scaleOption != null ? scaleOption : 20;
      if (typeof scale === "number") {
        scale = new Point(scale, scale);
      }
      const filterUniforms = new UniformGroup({
        uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uScale: { value: scale, type: "vec2<f32>" },
        uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" }
      });
      const glProgram = GlProgram.from({
        vertex: vertex$1,
        fragment: fragment$2,
        name: "displacement-filter"
      });
      const gpuProgram = GpuProgram.from({
        vertex: {
          source: source$2,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source$2,
          entryPoint: "mainFragment"
        }
      });
      const textureSource = sprite._texture._source;
      super(__spreadProps$e(__spreadValues$u({}, rest), {
        gpuProgram,
        glProgram,
        resources: {
          filterUniforms,
          uMapTexture: textureSource,
          uMapSampler: textureSource._style
        }
      }));
      this._sprite = options.sprite;
      this._sprite.renderable = false;
      this._uniforms = filterUniforms.uniforms;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - clearMode.
     */
    apply(filterManager, input, output, clearMode) {
      const sprite = this._sprite;
      const uniforms = this._uniforms;
      filterManager.calculateSpriteMatrix(
        uniforms.uFilterMatrix,
        sprite
      );
      sprite.checkWorldTransform();
      sprite.updateWorldTransform();
      const wt = sprite._worldTransform;
      const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      const uRotation = uniforms.uRotation;
      if (lenX !== 0 && lenY !== 0) {
        uRotation[0] = wt.a / lenX;
        uRotation[1] = wt.b / lenX;
        uRotation[2] = wt.c / lenY;
        uRotation[3] = wt.d / lenY;
      }
      const texture = sprite._texture;
      const resources = this.groups[1].resources;
      resources.setResource(texture._source, 1);
      resources.setResource(texture._style, 2);
      filterManager.applyFilter(this, input, output, clearMode);
    }
    /** scaleX, scaleY for displacements */
    get scale() {
      return this._uniforms.uScale;
    }
  }

  var fragment$1 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";

  var source$1 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";

  "use strict";
  var __defProp$t = Object.defineProperty;
  var __defProps$d = Object.defineProperties;
  var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
  var __hasOwnProp$t = Object.prototype.hasOwnProperty;
  var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$t = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$t.call(b, prop))
        __defNormalProp$t(a, prop, b[prop]);
    if (__getOwnPropSymbols$t)
      for (var prop of __getOwnPropSymbols$t(b)) {
        if (__propIsEnum$t.call(b, prop))
          __defNormalProp$t(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
  var __objRest$c = (source2, exclude) => {
    var target = {};
    for (var prop in source2)
      if (__hasOwnProp$t.call(source2, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$t)
      for (var prop of __getOwnPropSymbols$t(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$t.call(source2, prop))
          target[prop] = source2[prop];
      }
    return target;
  };
  class NoiseFilter extends Filter {
    /**
     * @param options - The options of the noise filter.
     */
    constructor(options = {}) {
      options = __spreadValues$t(__spreadValues$t({}, NoiseFilter.defaultOptions), options);
      const gpuProgram = GpuProgram.from({
        vertex: {
          source: source$1,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source$1,
          entryPoint: "mainFragment"
        }
      });
      const glProgram = GlProgram.from({
        vertex: vertex$2,
        fragment: fragment$1,
        name: "noise-filter"
      });
      const noiseUniforms = new UniformGroup({
        uNoise: { value: 1, type: "f32" },
        uSeed: { value: 1, type: "f32" }
      });
      const _a = options, { noise, seed } = _a, rest = __objRest$c(_a, ["noise", "seed"]);
      super(__spreadProps$d(__spreadValues$t({}, rest), {
        gpuProgram,
        glProgram,
        resources: {
          noiseUniforms
        }
      }));
      this.noise = noise;
      this.localUniforms = noiseUniforms;
      this.seed = seed != null ? seed : Math.random();
    }
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get noise() {
      return this.localUniforms.uniforms.uNoise;
    }
    set noise(value) {
      this.localUniforms.uniforms.uNoise = value;
    }
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get seed() {
      return this.localUniforms.uniforms.uSeed;
    }
    set seed(value) {
      this.localUniforms.uniforms.uSeed = value;
    }
  };
  NoiseFilter.defaultOptions = {
    noise: 0.5
  };

  var fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";

  var vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";

  var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";

  "use strict";
  var __defProp$s = Object.defineProperty;
  var __defProps$c = Object.defineProperties;
  var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
  var __hasOwnProp$s = Object.prototype.hasOwnProperty;
  var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$s = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$s.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    if (__getOwnPropSymbols$s)
      for (var prop of __getOwnPropSymbols$s(b)) {
        if (__propIsEnum$s.call(b, prop))
          __defNormalProp$s(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
  var __objRest$b = (source2, exclude) => {
    var target = {};
    for (var prop in source2)
      if (__hasOwnProp$s.call(source2, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source2[prop];
    if (source2 != null && __getOwnPropSymbols$s)
      for (var prop of __getOwnPropSymbols$s(source2)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$s.call(source2, prop))
          target[prop] = source2[prop];
      }
    return target;
  };
  class MaskFilter extends Filter {
    constructor(options) {
      const _a = options, { sprite } = _a, rest = __objRest$b(_a, ["sprite"]);
      const textureMatrix = new TextureMatrix(sprite._texture);
      const filterUniforms = new UniformGroup({
        uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
        uAlpha: { value: 1, type: "f32" },
        uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
      });
      const gpuProgram = GpuProgram.from({
        vertex: {
          source,
          entryPoint: "mainVertex"
        },
        fragment: {
          source,
          entryPoint: "mainFragment"
        }
      });
      const glProgram = GlProgram.from({
        vertex,
        fragment,
        name: "mask-filter"
      });
      super(__spreadProps$c(__spreadValues$s({}, rest), {
        gpuProgram,
        glProgram,
        resources: {
          filterUniforms,
          uMaskTexture: sprite._texture._source
        }
      }));
      this.sprite = sprite;
      this._textureMatrix = textureMatrix;
      this._uniforms = filterUniforms.uniforms;
      this._uFilterMatrix = this._uniforms.uFilterMatrix;
    }
    set inverse(value) {
      this._uniforms.uInverse = value ? 1 : 0;
    }
    get inverse() {
      return this._uniforms.uInverse === 1;
    }
    apply(filterManager, input, output, clearMode) {
      const sprite = this.sprite;
      const texture = sprite._texture;
      const textureMatrix = this._textureMatrix;
      textureMatrix.texture = texture;
      filterManager.calculateSpriteMatrix(
        this._uFilterMatrix,
        sprite
      ).prepend(textureMatrix.mapCoord);
      this.groups[1].setResource(texture._source);
      filterManager.applyFilter(this, input, output, clearMode);
    }
  }

  var hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";

  "use strict";
  function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
    const v2x = x3 - x1;
    const v2y = y3 - y1;
    const v1x = x2 - x1;
    const v1y = y2 - y1;
    const v0x = px - x1;
    const v0y = py - y1;
    const dot00 = v2x * v2x + v2y * v2y;
    const dot01 = v2x * v1x + v2y * v1y;
    const dot02 = v2x * v0x + v2y * v0y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v0x + v1y * v0y;
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return u >= 0 && v >= 0 && u + v < 1;
  }

  "use strict";

  "use strict";

  "use strict";
  class Triangle {
    /**
     * @param x - The X coord of the first point.
     * @param y - The Y coord of the first point.
     * @param x2 - The X coord of the second point.
     * @param y2 - The Y coord of the second point.
     * @param x3 - The X coord of the third point.
     * @param y3 - The Y coord of the third point.
     */
    constructor(x = 0, y = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0) {
      /**
       * The type of the object, mainly used to avoid `instanceof` checks
       * @default 'triangle'
       */
      this.type = "triangle";
      this.x = x;
      this.y = y;
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this triangle
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @returns Whether the x/y coordinates are within this Triangle
     */
    contains(x, y) {
      const s = (this.x - this.x3) * (y - this.y3) - (this.y - this.y3) * (x - this.x3);
      const t = (this.x2 - this.x) * (y - this.y) - (this.y2 - this.y) * (x - this.x);
      if (s < 0 !== t < 0 && s !== 0 && t !== 0) {
        return false;
      }
      const d = (this.x3 - this.x2) * (y - this.y2) - (this.y3 - this.y2) * (x - this.x2);
      return d === 0 || d < 0 === s + t <= 0;
    }
    /**
     * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
     * @param pointX - The X coordinate of the point to test
     * @param pointY - The Y coordinate of the point to test
     * @param strokeWidth - The width of the line to check
     * @returns Whether the x/y coordinates are within this triangle
     */
    strokeContains(pointX, pointY, strokeWidth) {
      const halfStrokeWidth = strokeWidth / 2;
      const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;
      const { x, x2, x3, y, y2, y3 } = this;
      if (squaredDistanceToLineSegment(pointX, pointY, x, y, x2, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x2, y2, x3, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x, y) <= halfStrokeWidthSquared) {
        return true;
      }
      return false;
    }
    /**
     * Creates a clone of this Triangle
     * @returns a copy of the triangle
     */
    clone() {
      const triangle = new Triangle(
        this.x,
        this.y,
        this.x2,
        this.y2,
        this.x3,
        this.y3
      );
      return triangle;
    }
    /**
     * Copies another triangle to this one.
     * @param triangle - The triangle to copy from.
     * @returns Returns itself.
     */
    copyFrom(triangle) {
      this.x = triangle.x;
      this.y = triangle.y;
      this.x2 = triangle.x2;
      this.y2 = triangle.y2;
      this.x3 = triangle.x3;
      this.y3 = triangle.y3;
      return this;
    }
    /**
     * Copies this triangle to another one.
     * @param triangle - The triangle to copy to.
     * @returns Returns given parameter.
     */
    copyTo(triangle) {
      triangle.copyFrom(this);
      return triangle;
    }
    /**
     * Returns the framing rectangle of the triangle as a Rectangle object
     * @param out - optional rectangle to store the result
     * @returns The framing rectangle
     */
    getBounds(out) {
      out = out || new Rectangle();
      const minX = Math.min(this.x, this.x2, this.x3);
      const maxX = Math.max(this.x, this.x2, this.x3);
      const minY = Math.min(this.y, this.y2, this.y3);
      const maxY = Math.max(this.y, this.y2, this.y3);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    }
  }

  "use strict";
  var __defProp$r = Object.defineProperty;
  var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
  var __hasOwnProp$r = Object.prototype.hasOwnProperty;
  var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$r = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    if (__getOwnPropSymbols$r)
      for (var prop of __getOwnPropSymbols$r(b)) {
        if (__propIsEnum$r.call(b, prop))
          __defNormalProp$r(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest$a = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$r.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$r)
      for (var prop of __getOwnPropSymbols$r(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$r.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class Mesh extends ViewContainer {
    constructor(...args) {
      var _b;
      let options = args[0];
      if (options instanceof Geometry) {
        deprecation(v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
        options = {
          geometry: options,
          shader: args[1]
        };
        if (args[3]) {
          deprecation(v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
          options.geometry.topology = args[3];
        }
      }
      const _a = options, { geometry, shader, texture, roundPixels, state } = _a, rest = __objRest$a(_a, ["geometry", "shader", "texture", "roundPixels", "state"]);
      super(__spreadValues$r({
        label: "Mesh"
      }, rest));
      this.renderPipeId = "mesh";
      /** @ignore */
      this._shader = null;
      this.allowChildren = false;
      this.shader = shader != null ? shader : null;
      this.texture = (_b = texture != null ? texture : shader == null ? void 0 : shader.texture) != null ? _b : Texture.WHITE;
      this.state = state != null ? state : State.for2d();
      this._geometry = geometry;
      this._geometry.on("update", this.onViewUpdate, this);
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    /** Alias for {@link scene.Mesh#shader}. */
    get material() {
      deprecation(v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
      return this._shader;
    }
    /**
     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
     * Can be shared between multiple Mesh objects.
     */
    set shader(value) {
      if (this._shader === value)
        return;
      this._shader = value;
      this.onViewUpdate();
    }
    get shader() {
      return this._shader;
    }
    /**
     * Includes vertex positions, face indices, colors, UVs, and
     * custom attributes within buffers, reducing the cost of passing all
     * this data to the GPU. Can be shared between multiple Mesh objects.
     */
    set geometry(value) {
      var _a;
      if (this._geometry === value)
        return;
      (_a = this._geometry) == null ? void 0 : _a.off("update", this.onViewUpdate, this);
      value.on("update", this.onViewUpdate, this);
      this._geometry = value;
      this.onViewUpdate();
    }
    get geometry() {
      return this._geometry;
    }
    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value) return;
      if (this.shader) {
        this.shader.texture = value;
      }
      this._texture = value;
    }
    get texture() {
      return this._texture;
    }
    get batched() {
      if (this._shader)
        return false;
      if ((this.state.data & 12) !== 0)
        return false;
      if (this._geometry instanceof MeshGeometry) {
        if (this._geometry.batchMode === "auto") {
          return this._geometry.positions.length / 2 <= 100;
        }
        return this._geometry.batchMode === "batch";
      }
      return false;
    }
    /**
     * The local bounds of the mesh.
     * @type {rendering.Bounds}
     */
    get bounds() {
      return this._geometry.bounds;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      bounds.addBounds(this.geometry.bounds);
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const { x, y } = point;
      if (!this.bounds.containsPoint(x, y))
        return false;
      const vertices = this.geometry.getBuffer("aPosition").data;
      const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
      if (this.geometry.getIndex()) {
        const indices = this.geometry.getIndex().data;
        const len = indices.length;
        for (let i = 0; i + 2 < len; i += step) {
          const ind0 = indices[i] * 2;
          const ind1 = indices[i + 1] * 2;
          const ind2 = indices[i + 2] * 2;
          if (pointInTriangle(
            x,
            y,
            vertices[ind0],
            vertices[ind0 + 1],
            vertices[ind1],
            vertices[ind1 + 1],
            vertices[ind2],
            vertices[ind2 + 1]
          )) {
            return true;
          }
        }
      } else {
        const len = vertices.length / 2;
        for (let i = 0; i + 2 < len; i += step) {
          const ind0 = i * 2;
          const ind1 = (i + 1) * 2;
          const ind2 = (i + 2) * 2;
          if (pointInTriangle(
            x,
            y,
            vertices[ind0],
            vertices[ind0 + 1],
            vertices[ind1],
            vertices[ind1 + 1],
            vertices[ind2],
            vertices[ind2 + 1]
          )) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      if (this._geometry) {
        this._geometry.off("update", this.onViewUpdate, this);
        this._geometry.destroy(true);
      }
      this._texture = null;
      this._geometry = null;
      this._shader = null;
    }
  }
  "use strict";
  class Transform {
    /**
     * @param options - Options for the transform.
     * @param options.matrix - The matrix to use.
     * @param options.observer - The observer to use.
     */
    constructor({ matrix, observer } = {}) {
      this.dirty = true;
      this._matrix = matrix != null ? matrix : new Matrix();
      this.observer = observer;
      this.position = new ObservablePoint(this, 0, 0);
      this.scale = new ObservablePoint(this, 1, 1);
      this.pivot = new ObservablePoint(this, 0, 0);
      this.skew = new ObservablePoint(this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
    }
    /**
     * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
     * properties into a single matrix.
     * @readonly
     */
    get matrix() {
      const lt = this._matrix;
      if (!this.dirty) return lt;
      const scale = this.scale;
      const sx = scale._x;
      const sy = scale._y;
      const pivot = this.pivot;
      const px = pivot._x;
      const py = pivot._y;
      const position = this.position;
      const x = position._x;
      const y = position._y;
      lt.a = this._cx * sx;
      lt.b = this._sx * sx;
      lt.c = this._cy * sy;
      lt.d = this._sy * sy;
      lt.tx = x - (px * lt.a + py * lt.c);
      lt.ty = y - (px * lt.b + py * lt.d);
      this.dirty = false;
      return lt;
    }
    /**
     * Called when a value changes.
     * @param point
     * @internal
     * @private
     */
    _onUpdate(point) {
      this.dirty = true;
      if (point === this.skew) this.updateSkew();
      if (this.observer) this.observer._onUpdate(this);
    }
    /** Called when the skew or the rotation changes. */
    updateSkew() {
      const skew = this.skew;
      const sx = skew._x;
      const sy = skew._y;
      const rotation = this._rotation;
      this._cx = Math.cos(rotation + sy);
      this._sx = Math.sin(rotation + sy);
      this._cy = -Math.sin(rotation - sx);
      this._sy = Math.cos(rotation - sx);
      this.dirty = true;
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     * @param matrix - The matrix to decompose
     */
    setFromMatrix(matrix) {
      matrix.decompose(this);
      this.dirty = true;
    }
    /** The rotation of the object in radians. */
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this.skew);
      }
    }
  }


  "use strict";
  const RECURSION_LIMIT$1 = 8;
  const FLT_EPSILON$1 = 11920929e-14;
  const PATH_DISTANCE_EPSILON$1 = 1;
  const curveAngleToleranceEpsilon$1 = 0.01;
  const mAngleTolerance$1 = 0;
  const mCuspLimit = 0;
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness != null ? smoothness : GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON$1 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive$1(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT$1) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON$1 && d3 > FLT_EPSILON$1) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance$1 < curveAngleToleranceEpsilon$1) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance$1) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON$1) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance$1 < curveAngleToleranceEpsilon$1) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance$1) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON$1) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance$1 < curveAngleToleranceEpsilon$1) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance$1) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive$1(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive$1(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }


  "use strict";
  const identityMatrix = new Matrix();
  class BatchableGraphics {
    constructor() {
      this.packAsQuad = false;
      this.batcherName = "default";
      this.applyTransform = true;
      this.roundPixels = 0;
      this._batcher = null;
      this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      if (this.applyTransform) {
        return this.renderable.groupBlendMode;
      }
      return "normal";
    }
    get color() {
      const rgb = this.baseColor;
      const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
      const renderable = this.renderable;
      if (renderable) {
        return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
      }
      return bgr + (this.alpha * 255 << 24);
    }
    get transform() {
      var _a;
      return ((_a = this.renderable) == null ? void 0 : _a.groupTransform) || identityMatrix;
    }
    copyTo(gpuBuffer) {
      gpuBuffer.indexOffset = this.indexOffset;
      gpuBuffer.indexSize = this.indexSize;
      gpuBuffer.attributeOffset = this.attributeOffset;
      gpuBuffer.attributeSize = this.attributeSize;
      gpuBuffer.baseColor = this.baseColor;
      gpuBuffer.alpha = this.alpha;
      gpuBuffer.texture = this.texture;
      gpuBuffer.geometryData = this.geometryData;
    }
    reset() {
      this.applyTransform = true;
      this.renderable = null;
    }
  }
  const BatchableGraphicsPool = createPool("BatchableGraphicsPool", BatchableGraphics);

  "use strict";
  const RECURSION_LIMIT = 8;
  const FLT_EPSILON = 11920929e-14;
  const PATH_DISTANCE_EPSILON = 1;
  const curveAngleToleranceEpsilon = 0.01;
  const mAngleTolerance = 0;
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness != null ? smoothness : GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d > FLT_EPSILON) {
      if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }

  "use strict";
  function buildArc(points, x, y, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
    steps = Math.max(steps, 3);
    let f = dist / steps;
    let t = start;
    f *= clockwise ? -1 : 1;
    let pointSize = points.length;
    for (let i = 0; i < steps + 1; i++) {
      const cs = Math.cos(t);
      const sn = Math.sin(t);
      const nx = x + cs * radius;
      const ny = y + sn * radius;
      points[pointSize++] = nx;
      points[pointSize++] = ny;
      t += f;
    }
  }

  "use strict";
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }

  "use strict";
  const TAU = Math.PI * 2;
  const out = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  };
  const mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
    x *= rx;
    y *= ry;
    const xp = cosPhi * x - sinPhi * y;
    const yp = sinPhi * x + cosPhi * y;
    out2.x = xp + centerX;
    out2.y = yp + centerY;
    return out2;
  };
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a,
        y: y1 + x1 * a
      },
      {
        x: x2 + y2 * a,
        y: y2 - x2 * a
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  const vectorAngle = (ux, uy, vx, vy) => {
    const sign = ux * vy - uy * vx < 0 ? -1 : 1;
    let dot = ux * vx + uy * vy;
    if (dot > 1) {
      dot = 1;
    }
    if (dot < -1) {
      dot = -1;
    }
    return sign * Math.acos(dot);
  };
  const getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
    const rxSq = Math.pow(rx, 2);
    const rySq = Math.pow(ry, 2);
    const pxpSq = Math.pow(pxp, 2);
    const pypSq = Math.pow(pyp, 2);
    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rxSq * pypSq + rySq * pxpSq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    const centerXp = radicant * rx / ry * pyp;
    const centerYp = radicant * -ry / rx * pxp;
    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
    const vx1 = (pxp - centerXp) / rx;
    const vy1 = (pyp - centerYp) / ry;
    const vx2 = (-pxp - centerXp) / rx;
    const vy2 = (-pyp - centerYp) / ry;
    const ang1 = vectorAngle(1, 0, vx1, vy1);
    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }
    out2.centerX = centerX;
    out2.centerY = centerY;
    out2.ang1 = ang1;
    out2.ang2 = ang2;
  };
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i = 0; i < segments; i++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x,
        y
      );
      lastX = x;
      lastY = y;
      ang1 += ang2;
    }
  }
  const vecFrom = (p, pp) => {
    const x = pp.x - p.x;
    const y = pp.y - p.y;
    const len = Math.sqrt(x * x + y * y);
    const nx = x / len;
    const ny = y / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i, p) => {
    if (i === 0) {
      g.moveTo(p.x, p.y);
    } else {
      g.lineTo(p.x, p.y);
    }
  };
  "use strict";
  function roundedShapeArc(g, points, radius) {
    var _a;
    let p1 = points[points.length - 1];
    for (let i = 0; i < points.length; i++) {
      const p2 = points[i % points.length];
      const pRadius = (_a = p2.radius) != null ? _a : radius;
      if (pRadius <= 0) {
        sharpCorner(i, p2);
        p1 = p2;
        continue;
      }
      const p3 = points[(i + 1) % points.length];
      const v1 = vecFrom(p2, p1);
      const v2 = vecFrom(p2, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i, p2);
        p1 = p2;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i === 0) {
        g.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p2;
    }
  }
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t) => ({
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  });
  function roundedShapeQuadraticCurve(g, points, radius, smoothness) {
    var _a;
    const numPoints = points.length;
    for (let i = 0; i < numPoints; i++) {
      const thisPoint = points[(i + 1) % numPoints];
      const pRadius = (_a = thisPoint.radius) != null ? _a : radius;
      if (pRadius <= 0) {
        if (i === 0) {
          g.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i];
      const nextPoint = points[(i + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i === 0) {
        g.moveTo(start.x, start.y);
      } else {
        g.lineTo(start.x, start.y);
      }
      g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }


  var __defProp$Q = Object.defineProperty;
  var __getOwnPropSymbols$Q = Object.getOwnPropertySymbols;
  var __hasOwnProp$Q = Object.prototype.hasOwnProperty;
  var __propIsEnum$Q = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$Q = (obj, key, value) => key in obj ? __defProp$Q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$Q = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$Q.call(b, prop))
        __defNormalProp$Q(a, prop, b[prop]);
    if (__getOwnPropSymbols$Q)
      for (var prop of __getOwnPropSymbols$Q(b)) {
        if (__propIsEnum$Q.call(b, prop))
          __defNormalProp$Q(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest$i = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$Q.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$Q)
      for (var prop of __getOwnPropSymbols$Q(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$Q.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };

  const tempRectangle = new Rectangle();
  class ShapePath {
    constructor(graphicsPath2D) {
      /** The list of shape primitives that make up the path. */
      this.shapePrimitives = [];
      this._currentPoly = null;
      this._bounds = new Bounds();
      this._graphicsPath2D = graphicsPath2D;
    }
    /**
     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
     * @param x - The x-coordinate for the starting point.
     * @param y - The y-coordinate for the starting point.
     * @returns The instance of the current object for chaining.
     */
    moveTo(x, y) {
      this.startPoly(x, y);
      return this;
    }
    /**
     * Connects the current point to a new point with a straight line. This method updates the current path.
     * @param x - The x-coordinate of the new point to connect to.
     * @param y - The y-coordinate of the new point to connect to.
     * @returns The instance of the current object for chaining.
     */
    lineTo(x, y) {
      this._ensurePoly();
      const points = this._currentPoly.points;
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      if (fromX !== x || fromY !== y) {
        points.push(x, y);
      }
      return this;
    }
    /**
     * Adds an arc to the path. The arc is centered at (x, y)
     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
     * @param x - The x-coordinate of the arc's center.
     * @param y - The y-coordinate of the arc's center.
     * @param radius - The radius of the arc.
     * @param startAngle - The starting angle of the arc, in radians.
     * @param endAngle - The ending angle of the arc, in radians.
     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
     * @returns The instance of the current object for chaining.
     */
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
      this._ensurePoly(false);
      const points = this._currentPoly.points;
      buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);
      return this;
    }
    /**
     * Adds an arc to the path with the arc tangent to the line joining two specified points.
     * The arc radius is specified by `radius`.
     * @param x1 - The x-coordinate of the first point.
     * @param y1 - The y-coordinate of the first point.
     * @param x2 - The x-coordinate of the second point.
     * @param y2 - The y-coordinate of the second point.
     * @param radius - The radius of the arc.
     * @returns The instance of the current object for chaining.
     */
    arcTo(x1, y1, x2, y2, radius) {
      this._ensurePoly();
      const points = this._currentPoly.points;
      buildArcTo(points, x1, y1, x2, y2, radius);
      return this;
    }
    /**
     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
     * @param rx - The x-radius of the ellipse.
     * @param ry - The y-radius of the ellipse.
     * @param xAxisRotation - The rotation of the ellipse's x-axis relative
     * to the x-axis of the coordinate system, in degrees.
     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
     * @param x - The x-coordinate of the arc's end point.
     * @param y - The y-coordinate of the arc's end point.
     * @returns The instance of the current object for chaining.
     */
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      const points = this._currentPoly.points;
      buildArcToSvg(
        points,
        this._currentPoly.lastX,
        this._currentPoly.lastY,
        x,
        y,
        rx,
        ry,
        xAxisRotation,
        largeArcFlag,
        sweepFlag
      );
      return this;
    }
    /**
     * Adds a cubic Bezier curve to the path.
     * It requires three points: the first two are control points and the third one is the end point.
     * The starting point is the last point in the current path.
     * @param cp1x - The x-coordinate of the first control point.
     * @param cp1y - The y-coordinate of the first control point.
     * @param cp2x - The x-coordinate of the second control point.
     * @param cp2y - The y-coordinate of the second control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothness - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveBezier(
        this._currentPoly.points,
        currentPoly.lastX,
        currentPoly.lastY,
        cp1x,
        cp1y,
        cp2x,
        cp2y,
        x,
        y,
        smoothness
      );
      return this;
    }
    /**
     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
     * The starting point is the last point in the current path.
     * @param cp1x - The x-coordinate of the control point.
     * @param cp1y - The y-coordinate of the control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothing - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveQuadratic(
        this._currentPoly.points,
        currentPoly.lastX,
        currentPoly.lastY,
        cp1x,
        cp1y,
        x,
        y,
        smoothing
      );
      return this;
    }
    /**
     * Closes the current path by drawing a straight line back to the start.
     * If the shape is already closed or there are no points in the path, this method does nothing.
     * @returns The instance of the current object for chaining.
     */
    closePath() {
      this.endPoly(true);
      return this;
    }
    /**
     * Adds another path to the current path. This method allows for the combination of multiple paths into one.
     * @param path - The `GraphicsPath` object representing the path to add.
     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
     * @returns The instance of the current object for chaining.
     */
    addPath(path, transform) {
      this.endPoly();
      if (transform && !transform.isIdentity()) {
        path = path.clone(true);
        path.transform(transform);
      }
      for (let i = 0; i < path.instructions.length; i++) {
        const instruction = path.instructions[i];
        this[instruction.action](...instruction.data);
      }
      return this;
    }
    /**
     * Finalizes the drawing of the current path. Optionally, it can close the path.
     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
     */
    finish(closePath = false) {
      this.endPoly(closePath);
    }
    /**
     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
     * @param x - The x-coordinate of the top-left corner of the rectangle.
     * @param y - The y-coordinate of the top-left corner of the rectangle.
     * @param w - The width of the rectangle.
     * @param h - The height of the rectangle.
     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
     * @returns The instance of the current object for chaining.
     */
    rect(x, y, w, h, transform) {
      this.drawShape(new Rectangle(x, y, w, h), transform);
      return this;
    }
    /**
     * Draws a circle shape. This method adds a new circle path to the current drawing.
     * @param x - The x-coordinate of the center of the circle.
     * @param y - The y-coordinate of the center of the circle.
     * @param radius - The radius of the circle.
     * @param transform - An optional `Matrix` object to apply a transformation to the circle.
     * @returns The instance of the current object for chaining.
     */
    circle(x, y, radius, transform) {
      this.drawShape(new Circle(x, y, radius), transform);
      return this;
    }
    /**
     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
     * representing the x and y coordinates of the polygon's vertices, in sequence.
     * @param close - A boolean indicating whether to close the polygon path. True by default.
     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
     * @returns The instance of the current object for chaining.
     */
    poly(points, close, transform) {
      const polygon = new Polygon(points);
      polygon.closePath = close;
      this.drawShape(polygon, transform);
      return this;
    }
    /**
     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
     * @param x - The x-coordinate of the center of the polygon.
     * @param y - The y-coordinate of the center of the polygon.
     * @param radius - The radius of the circumscribed circle of the polygon.
     * @param sides - The number of sides of the polygon. Must be 3 or more.
     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
     * @returns The instance of the current object for chaining.
     */
    regularPoly(x, y, radius, sides, rotation = 0, transform) {
      sides = Math.max(sides | 0, 3);
      const startAngle = -1 * Math.PI / 2 + rotation;
      const delta = Math.PI * 2 / sides;
      const polygon = [];
      for (let i = 0; i < sides; i++) {
        const angle = i * delta + startAngle;
        polygon.push(
          x + radius * Math.cos(angle),
          y + radius * Math.sin(angle)
        );
      }
      this.poly(polygon, true, transform);
      return this;
    }
    /**
     * Draws a polygon with rounded corners.
     * Similar to `regularPoly` but with the ability to round the corners of the polygon.
     * @param x - The x-coordinate of the center of the polygon.
     * @param y - The y-coordinate of the center of the polygon.
     * @param radius - The radius of the circumscribed circle of the polygon.
     * @param sides - The number of sides of the polygon. Must be 3 or more.
     * @param corner - The radius of the rounding of the corners.
     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
     * @returns The instance of the current object for chaining.
     */
    roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {
      sides = Math.max(sides | 0, 3);
      if (corner <= 0) {
        return this.regularPoly(x, y, radius, sides, rotation);
      }
      const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
      corner = Math.min(corner, sideLength);
      const startAngle = -1 * Math.PI / 2 + rotation;
      const delta = Math.PI * 2 / sides;
      const internalAngle = (sides - 2) * Math.PI / sides / 2;
      for (let i = 0; i < sides; i++) {
        const angle = i * delta + startAngle;
        const x0 = x + radius * Math.cos(angle);
        const y0 = y + radius * Math.sin(angle);
        const a1 = angle + Math.PI + internalAngle;
        const a2 = angle - Math.PI - internalAngle;
        const x1 = x0 + corner * Math.cos(a1);
        const y1 = y0 + corner * Math.sin(a1);
        const x3 = x0 + corner * Math.cos(a2);
        const y3 = y0 + corner * Math.sin(a2);
        if (i === 0) {
          this.moveTo(x1, y1);
        } else {
          this.lineTo(x1, y1);
        }
        this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
      }
      return this.closePath();
    }
    /**
     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
     * A minimum of 3 points is required.
     * @param radius - The default radius for the corners.
     * This radius is applied to all corners unless overridden in `points`.
     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
     *  method instead of an arc method. Defaults to false.
     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
     * Higher values make the curve smoother.
     * @returns The instance of the current object for chaining.
     */
    roundShape(points, radius, useQuadratic = false, smoothness) {
      if (points.length < 3) {
        return this;
      }
      if (useQuadratic) {
        roundedShapeQuadraticCurve(this, points, radius, smoothness);
      } else {
        roundedShapeArc(this, points, radius);
      }
      return this.closePath();
    }
    /**
     * Draw Rectangle with fillet corners. This is much like rounded rectangle
     * however it support negative numbers as well for the corner radius.
     * @param x - Upper left corner of rect
     * @param y - Upper right corner of rect
     * @param width - Width of rect
     * @param height - Height of rect
     * @param fillet - accept negative or positive values
     */
    filletRect(x, y, width, height, fillet) {
      if (fillet === 0) {
        return this.rect(x, y, width, height);
      }
      const maxFillet = Math.min(width, height) / 2;
      const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
      const right = x + width;
      const bottom = y + height;
      const dir = inset < 0 ? -inset : 0;
      const size = Math.abs(inset);
      return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();
    }
    /**
     * Draw Rectangle with chamfer corners. These are angled corners.
     * @param x - Upper left corner of rect
     * @param y - Upper right corner of rect
     * @param width - Width of rect
     * @param height - Height of rect
     * @param chamfer - non-zero real number, size of corner cutout
     * @param transform
     */
    chamferRect(x, y, width, height, chamfer, transform) {
      if (chamfer <= 0) {
        return this.rect(x, y, width, height);
      }
      const inset = Math.min(chamfer, Math.min(width, height) / 2);
      const right = x + width;
      const bottom = y + height;
      const points = [
        x + inset,
        y,
        right - inset,
        y,
        right,
        y + inset,
        right,
        bottom - inset,
        right - inset,
        bottom,
        x + inset,
        bottom,
        x,
        bottom - inset,
        x,
        y + inset
      ];
      for (let i = points.length - 1; i >= 2; i -= 2) {
        if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
          points.splice(i - 1, 2);
        }
      }
      return this.poly(points, true, transform);
    }
    /**
     * Draws an ellipse at the specified location and with the given x and y radii.
     * An optional transformation can be applied, allowing for rotation, scaling, and translation.
     * @param x - The x-coordinate of the center of the ellipse.
     * @param y - The y-coordinate of the center of the ellipse.
     * @param radiusX - The horizontal radius of the ellipse.
     * @param radiusY - The vertical radius of the ellipse.
     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
     * @returns The instance of the current object for chaining.
     */
    ellipse(x, y, radiusX, radiusY, transform) {
      this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);
      return this;
    }
    /**
     * Draws a rectangle with rounded corners.
     * The corner radius can be specified to determine how rounded the corners should be.
     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
     * @param x - The x-coordinate of the top-left corner of the rectangle.
     * @param y - The y-coordinate of the top-left corner of the rectangle.
     * @param w - The width of the rectangle.
     * @param h - The height of the rectangle.
     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
     * @returns The instance of the current object for chaining.
     */
    roundRect(x, y, w, h, radius, transform) {
      this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);
      return this;
    }
    /**
     * Draws a given shape on the canvas.
     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
     * scaling, and translations.
     * @returns The instance of the current object for chaining.
     */
    drawShape(shape, matrix) {
      this.endPoly();
      this.shapePrimitives.push({ shape, transform: matrix });
      return this;
    }
    /**
     * Starts a new polygon path from the specified starting point.
     * This method initializes a new polygon or ends the current one if it exists.
     * @param x - The x-coordinate of the starting point of the new polygon.
     * @param y - The y-coordinate of the starting point of the new polygon.
     * @returns The instance of the current object for chaining.
     */
    startPoly(x, y) {
      let currentPoly = this._currentPoly;
      if (currentPoly) {
        this.endPoly();
      }
      currentPoly = new Polygon();
      currentPoly.points.push(x, y);
      this._currentPoly = currentPoly;
      return this;
    }
    /**
     * Ends the current polygon path. If `closePath` is set to true,
     * the path is closed by connecting the last point to the first one.
     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
     *  back to the starting point. False by default.
     * @returns The instance of the current object for chaining.
     */
    endPoly(closePath = false) {
      const shape = this._currentPoly;
      if (shape && shape.points.length > 2) {
        shape.closePath = closePath;
        this.shapePrimitives.push({ shape });
      }
      this._currentPoly = null;
      return this;
    }
    _ensurePoly(start = true) {
      if (this._currentPoly)
        return;
      this._currentPoly = new Polygon();
      if (start) {
        const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (lastShape) {
          let lx = lastShape.shape.x;
          let ly = lastShape.shape.y;
          if (lastShape.transform && !lastShape.transform.isIdentity()) {
            const t = lastShape.transform;
            const tempX = lx;
            lx = t.a * lx + t.c * ly + t.tx;
            ly = t.b * tempX + t.d * ly + t.ty;
          }
          this._currentPoly.points.push(lx, ly);
        } else {
          this._currentPoly.points.push(0, 0);
        }
      }
    }
    /** Builds the path. */
    buildPath() {
      const path = this._graphicsPath2D;
      this.shapePrimitives.length = 0;
      this._currentPoly = null;
      for (let i = 0; i < path.instructions.length; i++) {
        const instruction = path.instructions[i];
        this[instruction.action](...instruction.data);
      }
      this.finish();
    }
    /** Gets the bounds of the path. */
    get bounds() {
      const bounds = this._bounds;
      bounds.clear();
      const shapePrimitives = this.shapePrimitives;
      for (let i = 0; i < shapePrimitives.length; i++) {
        const shapePrimitive = shapePrimitives[i];
        const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
        if (shapePrimitive.transform) {
          bounds.addRect(boundsRect, shapePrimitive.transform);
        } else {
          bounds.addRect(boundsRect);
        }
      }
      return bounds;
    }
  }

  "use strict";
  class GraphicsPath {
    /**
     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
     * @param instructions - An SVG path string or an array of `PathInstruction` objects.
     */
    constructor(instructions) {
      this.instructions = [];
      /** unique id for this graphics path */
      this.uid = uid$1("graphicsPath");
      this._dirty = true;
      var _a;
      if (typeof instructions === "string") {
        SVGToGraphicsPath(instructions, this);
      } else if (instructions) {
        this.instructions.copy(instructions);
      }
    }
    /**
     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
     * @returns The `ShapePath` instance associated with this `GraphicsPath`.
     */
    get shapePath() {
      if (!this._shapePath) {
        this._shapePath = new ShapePath(this);
      }
      if (this._dirty) {
        this._dirty = false;
        this._shapePath.buildPath();
      }
      return this._shapePath;
    }
    /**
     * Adds another `GraphicsPath` to this path, optionally applying a transformation.
     * @param path - The `GraphicsPath` to add.
     * @param transform - An optional transformation to apply to the added path.
     * @returns The instance of the current object for chaining.
     */
    addPath(path, transform) {
      path = path.clone();
      this.instructions.push({ action: "addPath", data: [path, transform] });
      this._dirty = true;
      return this;
    }
    arc(...args) {
      this.instructions.push({ action: "arc", data: args });
      this._dirty = true;
      return this;
    }
    arcTo(...args) {
      this.instructions.push({ action: "arcTo", data: args });
      this._dirty = true;
      return this;
    }
    arcToSvg(...args) {
      this.instructions.push({ action: "arcToSvg", data: args });
      this._dirty = true;
      return this;
    }
    bezierCurveTo(...args) {
      this.instructions.push({ action: "bezierCurveTo", data: args });
      this._dirty = true;
      return this;
    }
    /**
     * Adds a cubic Bezier curve to the path.
     * It requires two points: the second control point and the end point. The first control point is assumed to be
     * The starting point is the last point in the current path.
     * @param cp2x - The x-coordinate of the second control point.
     * @param cp2y - The y-coordinate of the second control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothness - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {
      const last = this.instructions[this.instructions.length - 1];
      const lastPoint = this.getLastPoint(Point.empty);
      let cp1x = 0;
      let cp1y = 0;
      if (!last || last.action !== "bezierCurveTo") {
        cp1x = lastPoint.x;
        cp1y = lastPoint.y;
      } else {
        cp1x = last.data[2];
        cp1y = last.data[3];
        const currentX = lastPoint.x;
        const currentY = lastPoint.y;
        cp1x = currentX + (currentX - cp1x);
        cp1y = currentY + (currentY - cp1y);
      }
      this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });
      this._dirty = true;
      return this;
    }
    /**
     * Closes the current path by drawing a straight line back to the start.
     * If the shape is already closed or there are no points in the path, this method does nothing.
     * @returns The instance of the current object for chaining.
     */
    closePath() {
      this.instructions.push({ action: "closePath", data: [] });
      this._dirty = true;
      return this;
    }
    ellipse(...args) {
      this.instructions.push({ action: "ellipse", data: args });
      this._dirty = true;
      return this;
    }
    lineTo(...args) {
      this.instructions.push({ action: "lineTo", data: args });
      this._dirty = true;
      return this;
    }
    moveTo(...args) {
      this.instructions.push({ action: "moveTo", data: args });
      return this;
    }
    quadraticCurveTo(...args) {
      this.instructions.push({ action: "quadraticCurveTo", data: args });
      this._dirty = true;
      return this;
    }
    /**
     * Adds a quadratic curve to the path. It uses the previous point as the control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothness - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    quadraticCurveToShort(x, y, smoothness) {
      const last = this.instructions[this.instructions.length - 1];
      const lastPoint = this.getLastPoint(Point.empty);
      let cpx1 = 0;
      let cpy1 = 0;
      if (!last || last.action !== "quadraticCurveTo") {
        cpx1 = lastPoint.x;
        cpy1 = lastPoint.y;
      } else {
        cpx1 = last.data[0];
        cpy1 = last.data[1];
        const currentX = lastPoint.x;
        const currentY = lastPoint.y;
        cpx1 = currentX + (currentX - cpx1);
        cpy1 = currentY + (currentY - cpy1);
      }
      this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });
      this._dirty = true;
      return this;
    }
    /**
     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
     * @param x - The x-coordinate of the top-left corner of the rectangle.
     * @param y - The y-coordinate of the top-left corner of the rectangle.
     * @param w - The width of the rectangle.
     * @param h - The height of the rectangle.
     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
     * @returns The instance of the current object for chaining.
     */
    rect(x, y, w, h, transform) {
      this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });
      this._dirty = true;
      return this;
    }
    /**
     * Draws a circle shape. This method adds a new circle path to the current drawing.
     * @param x - The x-coordinate of the center of the circle.
     * @param y - The y-coordinate of the center of the circle.
     * @param radius - The radius of the circle.
     * @param transform - An optional `Matrix` object to apply a transformation to the circle.
     * @returns The instance of the current object for chaining.
     */
    circle(x, y, radius, transform) {
      this.instructions.push({ action: "circle", data: [x, y, radius, transform] });
      this._dirty = true;
      return this;
    }
    roundRect(...args) {
      this.instructions.push({ action: "roundRect", data: args });
      this._dirty = true;
      return this;
    }
    poly(...args) {
      this.instructions.push({ action: "poly", data: args });
      this._dirty = true;
      return this;
    }
    regularPoly(...args) {
      this.instructions.push({ action: "regularPoly", data: args });
      this._dirty = true;
      return this;
    }
    roundPoly(...args) {
      this.instructions.push({ action: "roundPoly", data: args });
      this._dirty = true;
      return this;
    }
    roundShape(...args) {
      this.instructions.push({ action: "roundShape", data: args });
      this._dirty = true;
      return this;
    }
    filletRect(...args) {
      this.instructions.push({ action: "filletRect", data: args });
      this._dirty = true;
      return this;
    }
    chamferRect(...args) {
      this.instructions.push({ action: "chamferRect", data: args });
      this._dirty = true;
      return this;
    }
    /**
     * Draws a star shape centered at a specified location. This method allows for the creation
     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
     * An optional transformation can be applied to scale, rotate, or translate the star as needed.
     * @param x - The x-coordinate of the center of the star.
     * @param y - The y-coordinate of the center of the star.
     * @param points - The number of points of the star.
     * @param radius - The outer radius of the star (distance from the center to the outer points).
     * @param innerRadius - Optional. The inner radius of the star
     * (distance from the center to the inner points between the outer points).
     * If not provided, defaults to half of the `radius`.
     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
     * Defaults to 0, meaning one point is directly upward.
     * @param transform - An optional `Matrix` object to apply a transformation to the star.
     * This can include rotations, scaling, and translations.
     * @returns The instance of the current object for chaining further drawing commands.
     */
    // eslint-disable-next-line max-len
    star(x, y, points, radius, innerRadius, rotation, transform) {
      innerRadius = innerRadius || radius / 2;
      const startAngle = -1 * Math.PI / 2 + rotation;
      const len = points * 2;
      const delta = Math.PI * 2 / len;
      const polygon = [];
      for (let i = 0; i < len; i++) {
        const r = i % 2 ? innerRadius : radius;
        const angle = i * delta + startAngle;
        polygon.push(
          x + r * Math.cos(angle),
          y + r * Math.sin(angle)
        );
      }
      this.poly(polygon, true, transform);
      return this;
    }
    /**
     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
     * do not affect the original `GraphicsPath` and vice versa.
     * @param deep - A boolean flag indicating whether the clone should be deep.
     * @returns A new `GraphicsPath` instance that is a clone of the current instance.
     */
    clone(deep = false) {
      const newGraphicsPath2D = new GraphicsPath();
      if (!deep) {
        newGraphicsPath2D.instructions = this.instructions.slice();
      } else {
        for (let i = 0; i < this.instructions.length; i++) {
          const instruction = this.instructions[i];
          newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
        }
      }
      return newGraphicsPath2D;
    }
    clear() {
      this.instructions.length = 0;
      this._dirty = true;
      return this;
    }
    /**
     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
     * This method enables the modification of the path's geometry according to the provided
     * transformation matrix, which can include translations, rotations, scaling, and skewing.
     *
     * Each drawing instruction in the path is updated to reflect the transformation,
     * ensuring the visual representation of the path is consistent with the applied matrix.
     *
     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
     * allowing for fine-grained control over the path's appearance.
     * @param matrix - A `Matrix` object representing the transformation to apply.
     * @returns The instance of the current object for chaining further operations.
     */
    transform(matrix) {
      if (matrix.isIdentity())
        return this;
      const a = matrix.a;
      const b = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let x = 0;
      let y = 0;
      let cpx1 = 0;
      let cpy1 = 0;
      let cpx2 = 0;
      let cpy2 = 0;
      let rx = 0;
      let ry = 0;
      for (let i = 0; i < this.instructions.length; i++) {
        const instruction = this.instructions[i];
        const data = instruction.data;
        switch (instruction.action) {
          case "moveTo":
          case "lineTo":
            x = data[0];
            y = data[1];
            data[0] = a * x + c * y + tx;
            data[1] = b * x + d * y + ty;
            break;
          case "bezierCurveTo":
            cpx1 = data[0];
            cpy1 = data[1];
            cpx2 = data[2];
            cpy2 = data[3];
            x = data[4];
            y = data[5];
            data[0] = a * cpx1 + c * cpy1 + tx;
            data[1] = b * cpx1 + d * cpy1 + ty;
            data[2] = a * cpx2 + c * cpy2 + tx;
            data[3] = b * cpx2 + d * cpy2 + ty;
            data[4] = a * x + c * y + tx;
            data[5] = b * x + d * y + ty;
            break;
          case "quadraticCurveTo":
            cpx1 = data[0];
            cpy1 = data[1];
            x = data[2];
            y = data[3];
            data[0] = a * cpx1 + c * cpy1 + tx;
            data[1] = b * cpx1 + d * cpy1 + ty;
            data[2] = a * x + c * y + tx;
            data[3] = b * x + d * y + ty;
            break;
          case "arcToSvg":
            x = data[5];
            y = data[6];
            rx = data[0];
            ry = data[1];
            data[0] = a * rx + c * ry;
            data[1] = b * rx + d * ry;
            data[5] = a * x + c * y + tx;
            data[6] = b * x + d * y + ty;
            break;
          case "circle":
            data[4] = adjustTransform(data[3], matrix);
            break;
          case "rect":
            data[4] = adjustTransform(data[4], matrix);
            break;
          case "ellipse":
            data[8] = adjustTransform(data[8], matrix);
            break;
          case "roundRect":
            data[5] = adjustTransform(data[5], matrix);
            break;
          case "addPath":
            data[0].transform(matrix);
            break;
          case "poly":
            data[2] = adjustTransform(data[2], matrix);
            break;
          default:
            Logger.warn("unknown transform action", instruction.action);
            break;
        }
      }
      this._dirty = true;
      return this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    /**
     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
     * This method is useful for operations that depend on the path's current endpoint,
     * such as connecting subsequent shapes or paths. It supports various drawing instructions,
     * ensuring the last point's position is accurately determined regardless of the path's complexity.
     *
     * If the last instruction is a `closePath`, the method iterates backward through the instructions
     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
     * the last point from the nested path.
     * @param out - A `Point` object where the last point's coordinates will be stored.
     * This object is modified directly to contain the result.
     * @returns The `Point` object containing the last point's coordinates.
     */
    getLastPoint(out) {
      let index = this.instructions.length - 1;
      let lastInstruction = this.instructions[index];
      if (!lastInstruction) {
        out.x = 0;
        out.y = 0;
        return out;
      }
      while (lastInstruction.action === "closePath") {
        index--;
        if (index < 0) {
          out.x = 0;
          out.y = 0;
          return out;
        }
        lastInstruction = this.instructions[index];
      }
      switch (lastInstruction.action) {
        case "moveTo":
        case "lineTo":
          out.x = lastInstruction.data[0];
          out.y = lastInstruction.data[1];
          break;
        case "quadraticCurveTo":
          out.x = lastInstruction.data[2];
          out.y = lastInstruction.data[3];
          break;
        case "bezierCurveTo":
          out.x = lastInstruction.data[4];
          out.y = lastInstruction.data[5];
          break;
        case "arc":
        case "arcToSvg":
          out.x = lastInstruction.data[5];
          out.y = lastInstruction.data[6];
          break;
        case "addPath":
          lastInstruction.data[0].getLastPoint(out);
          break;
      }
      return out;
    }
  }
  function adjustTransform(currentMatrix, transform) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform);
    }
    return transform.clone();
  }

  "use strict";
  var __defProp$U = Object.defineProperty;
  var __getOwnPropSymbols$U = Object.getOwnPropertySymbols;
  var __hasOwnProp$U = Object.prototype.hasOwnProperty;
  var __propIsEnum$U = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$U = (obj, key, value) => key in obj ? __defProp$U(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$U = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$U.call(b, prop))
        __defNormalProp$U(a, prop, b[prop]);
    if (__getOwnPropSymbols$U)
      for (var prop of __getOwnPropSymbols$U(b)) {
        if (__propIsEnum$U.call(b, prop))
          __defNormalProp$U(a, prop, b[prop]);
      }
    return a;
  };
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
    if (f1 && fillStyle) {
      fillStyle = __spreadValues$U(__spreadValues$U({}, fillStyle), f1);
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = __spreadValues$U(__spreadValues$U({}, strokeStyle), s1);
    } else if (s1) {
      strokeStyle = s1;
    }
    const context = session.context;
    context.fillStyle = fillStyle;
    context.strokeStyle = strokeStyle;
    let x;
    let y;
    let x1;
    let y1;
    let x2;
    let y2;
    let cx;
    let cy;
    let r;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d;
    let graphicsPath;
    let width;
    let height;
    let array;
    switch (svg.nodeName.toLowerCase()) {
      case "path":
        d = svg.getAttribute("d");
        graphicsPath = new GraphicsPath(d);
        context.path(graphicsPath);
        if (fillStyle)
          context.fill();
        if (strokeStyle)
          context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        r = parseFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r, r);
        if (fillStyle)
          context.fill();
        if (strokeStyle)
          context.stroke();
        break;
      case "rect":
        x = parseFloatAttribute(svg, "x", 0);
        y = parseFloatAttribute(svg, "y", 0);
        width = parseFloatAttribute(svg, "width", 0);
        height = parseFloatAttribute(svg, "height", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          context.roundRect(x, y, width, height, rx || ry);
        } else {
          context.rect(x, y, width, height);
        }
        if (fillStyle)
          context.fill();
        if (strokeStyle)
          context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        context.beginPath();
        context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          context.fill();
        if (strokeStyle)
          context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg, "x1", 0);
        y1 = parseFloatAttribute(svg, "y1", 0);
        x2 = parseFloatAttribute(svg, "x2", 0);
        y2 = parseFloatAttribute(svg, "y2", 0);
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        if (strokeStyle)
          context.stroke();
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        array = pointsString.match(RegExp.number);
        for (let i = 0; i < array.length; i++) {
          array[i] = parseInt(array[i], 10);
        }
        points = array;
        context.poly(points, true);
        if (fillStyle)
          context.fill();
        if (strokeStyle)
          context.stroke();
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        array = pointsString.match(RegExp.number);
        for (let i = 0; i < array.length; i++) {
          array[i] = parseInt(array[i], 10);
        }
        points = array;
        context.poly(points, false);
        if (strokeStyle)
          context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        Logger.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i = 0; i < children.length; i++) {
      renderChildren(children[i], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg, id, defaultValue) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue;
  }
  function parseStyle(svg) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style) {
      const styleParts = style.split(";");
      for (let i = 0; i < styleParts.length; i++) {
        const stylePart = styleParts[i];
        const [key, value] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value !== "none") {
              strokeStyle.color = Color.shared.setValue(value).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value);
            break;
          case "fill":
            if (value !== "none") {
              useFill = true;
              fillStyle.color = Color.shared.setValue(value).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value);
            break;
          case "opacity":
            fillStyle.alpha = Number(value);
            strokeStyle.alpha = Number(value);
            break;
        }
      }
    } else {
      const stroke = svg.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
      }
      const fill = svg.getAttribute("fill");
      if (fill && fill !== "none") {
        useFill = true;
        fillStyle.color = Color.shared.setValue(fill).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }

  "use strict";
  var __defProp$T = Object.defineProperty;
  var __getOwnPropSymbols$T = Object.getOwnPropertySymbols;
  var __hasOwnProp$T = Object.prototype.hasOwnProperty;
  var __propIsEnum$T = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$T = (obj, key, value) => key in obj ? __defProp$T(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$T = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$T.call(b, prop))
        __defNormalProp$T(a, prop, b[prop]);
    if (__getOwnPropSymbols$T)
      for (var prop of __getOwnPropSymbols$T(b)) {
        if (__propIsEnum$T.call(b, prop))
          __defNormalProp$T(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest$j = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$T.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$T)
      for (var prop of __getOwnPropSymbols$T(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$T.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function isColorLike(value) {
    return Color.isColorLike(value);
  }
  function isFillPattern(value) {
    return value instanceof FillPattern;
  }
  function isFillGradient(value) {
    return value instanceof FillGradient;
  }
  function handleColorLike(fill, value, defaultStyle) {
    const temp = Color.shared.setValue(value != null ? value : 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = Texture.WHITE;
    return __spreadValues$T(__spreadValues$T({}, defaultStyle), fill);
  }
  function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return __spreadValues$T(__spreadValues$T({}, defaultStyle), fill);
  }
  function handleFillGradient(fill, value, defaultStyle) {
    value.buildLinearGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return __spreadValues$T(__spreadValues$T({}, defaultStyle), fill);
  }
  function handleFillObject(value, defaultStyle) {
    var _a;
    const style = __spreadValues$T(__spreadValues$T({}, defaultStyle), value);
    if (style.texture) {
      const texture = style.texture;
      if (style.texture !== Texture.WHITE) {
        const m = ((_a = style.matrix) == null ? void 0 : _a.clone().invert()) || new Matrix();
        m.translate(texture.frame.x, texture.frame.y);
        m.scale(1 / texture._source.width, 1 / texture._source.height);
        style.matrix = m;
      }
      const sourceStyle = texture._source._style;
      if (sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
        sourceStyle.update();
      }
    }
    const color = Color.shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    style.matrix = style.matrix ? style.matrix.clone() : null;
    return style;
  }
  function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
      return handleColorLike(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
      return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
      return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value, defaultStyle) {
    const _a = defaultStyle, { width, alignment, miterLimit, cap, join } = _a, rest = __objRest$j(_a, ["width", "alignment", "miterLimit", "cap", "join"]);
    const fill = toFillStyle(value, rest);
    if (!fill) {
      return null;
    }
    return __spreadValues$T({
      width,
      alignment,
      miterLimit,
      cap,
      join
    }, fill);
  }

  const tmpPoint = new Point();
  const tempMatrix$3 = new Matrix();

  class GraphicsContext extends EventEmitter {
    constructor() {
      super(...arguments);
      /** unique id for this graphics context */
      this.uid = uid$1("graphicsContext");
      this.dirty = true;
      this.batchMode = "auto";
      this.instructions = [];
      this._activePath = new GraphicsPath();
      this._transform = new Matrix();
      this._fillStyle = Object.assign({}, GraphicsContext.defaultFillStyle);
      this._strokeStyle = Object.assign({}, GraphicsContext.defaultStrokeStyle);
      this._stateStack = [];
      this._tick = 0;
      this._bounds = new Bounds();
      this._boundsDirty = true;
    }
    /**
     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
     * including the current drawing state, transformations, styles, and instructions.
     * @returns A new GraphicsContext instance with the same properties and state as this one.
     */
    clone() {
      const clone = new GraphicsContext();
      clone.batchMode = this.batchMode;
      clone.instructions = this.instructions.slice();
      clone._activePath = this._activePath.clone();
      clone._transform = this._transform.clone();
      clone._fillStyle = Object.assign({}, this._fillStyle);
      clone._strokeStyle = Object.assign({}, this._strokeStyle);
      clone._stateStack = this._stateStack.slice();
      clone._bounds = this._bounds.clone();
      clone._boundsDirty = true;
      return clone;
    }
    /**
     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
     */
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(value) {
      this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);
    }
    /**
     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
     */
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(value) {
      this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
    }
    /**
     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
     * pattern, or a more complex style defined by a FillStyle object.
     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
     *                or a FillStyle or ConvertedFillStyle object.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    setFillStyle(style) {
      this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);
      return this;
    }
    /**
     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
     *                or a StrokeStyle or ConvertedStrokeStyle object.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    setStrokeStyle(style) {
      this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle);
      return this;
    }
    texture(texture, tint, dx, dy, dw, dh) {
      this.instructions.push({
        action: "texture",
        data: {
          image: texture,
          dx: dx || 0,
          dy: dy || 0,
          dw: dw || texture.frame.width,
          dh: dh || texture.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
        }
      });
      this.onUpdate();
      return this;
    }
    /**
     * Resets the current path. Any previous path and its commands are discarded and a new path is
     * started. This is typically called before beginning a new shape or series of drawing commands.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    beginPath() {
      this._activePath = new GraphicsPath();
      return this;
    }
    fill(style, alpha) {
      let path;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
        path = lastInstruction.data.path;
      } else {
        path = this._activePath.clone();
      }
      if (!path)
        return this;
      if (style != null) {
        if (alpha !== void 0 && typeof style === "number") {
          deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
          style = { color: style, alpha };
        }
        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);
      }
      this.instructions.push({
        action: "fill",
        // TODO copy fill style!
        data: { style: this.fillStyle, path }
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    _initNextPathLocation() {
      const { x, y } = this._activePath.getLastPoint(Point.empty);
      this._activePath.clear();
      this._activePath.moveTo(x, y);
    }
    /**
     * Strokes the current path with the current stroke style. This method can take an optional
     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    stroke(style) {
      let path;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
        path = lastInstruction.data.path;
      } else {
        path = this._activePath.clone();
      }
      if (!path)
        return this;
      if (style != null) {
        this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);
      }
      this.instructions.push({
        action: "stroke",
        // TODO copy fill style!
        data: { style: this.strokeStyle, path }
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    /**
     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
     * fail to cut correctly!
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    cut() {
      for (let i = 0; i < 2; i++) {
        const lastInstruction = this.instructions[this.instructions.length - 1 - i];
        const holePath = this._activePath.clone();
        if (lastInstruction) {
          if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
            if (lastInstruction.data.hole) {
              lastInstruction.data.hole.addPath(holePath);
            } else {
              lastInstruction.data.hole = holePath;
              break;
            }
          }
        }
      }
      this._initNextPathLocation();
      return this;
    }
    /**
     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
     * starting and ending angles, and direction.
     * @param x - The x-coordinate of the arc's center.
     * @param y - The y-coordinate of the arc's center.
     * @param radius - The arc's radius.
     * @param startAngle - The starting angle, in radians.
     * @param endAngle - The ending angle, in radians.
     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
      this._tick++;
      const t = this._transform;
      this._activePath.arc(
        t.a * x + t.c * y + t.tx,
        t.b * x + t.d * y + t.ty,
        radius,
        startAngle,
        endAngle,
        counterclockwise
      );
      return this;
    }
    /**
     * Adds an arc to the current path with the given control points and radius, connected to the previous point
     * by a straight line if necessary.
     * @param x1 - The x-coordinate of the first control point.
     * @param y1 - The y-coordinate of the first control point.
     * @param x2 - The x-coordinate of the second control point.
     * @param y2 - The y-coordinate of the second control point.
     * @param radius - The arc's radius.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    arcTo(x1, y1, x2, y2, radius) {
      this._tick++;
      const t = this._transform;
      this._activePath.arcTo(
        t.a * x1 + t.c * y1 + t.tx,
        t.b * x1 + t.d * y1 + t.ty,
        t.a * x2 + t.c * y2 + t.tx,
        t.b * x2 + t.d * y2 + t.ty,
        radius
      );
      return this;
    }
    /**
     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
     * @param rx - The x-radius of the ellipse.
     * @param ry - The y-radius of the ellipse.
     * @param xAxisRotation - The rotation of the ellipse's x-axis relative
     * to the x-axis of the coordinate system, in degrees.
     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
     * @param x - The x-coordinate of the arc's end point.
     * @param y - The y-coordinate of the arc's end point.
     * @returns The instance of the current object for chaining.
     */
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      this._tick++;
      const t = this._transform;
      this._activePath.arcToSvg(
        rx,
        ry,
        xAxisRotation,
        // should we rotate this with transform??
        largeArcFlag,
        sweepFlag,
        t.a * x + t.c * y + t.tx,
        t.b * x + t.d * y + t.ty
      );
      return this;
    }
    /**
     * Adds a cubic Bezier curve to the path.
     * It requires three points: the first two are control points and the third one is the end point.
     * The starting point is the last point in the current path.
     * @param cp1x - The x-coordinate of the first control point.
     * @param cp1y - The y-coordinate of the first control point.
     * @param cp2x - The x-coordinate of the second control point.
     * @param cp2y - The y-coordinate of the second control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothness - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
      this._tick++;
      const t = this._transform;
      this._activePath.bezierCurveTo(
        t.a * cp1x + t.c * cp1y + t.tx,
        t.b * cp1x + t.d * cp1y + t.ty,
        t.a * cp2x + t.c * cp2y + t.tx,
        t.b * cp2x + t.d * cp2y + t.ty,
        t.a * x + t.c * y + t.tx,
        t.b * x + t.d * y + t.ty,
        smoothness
      );
      return this;
    }
    /**
     * Closes the current path by drawing a straight line back to the start.
     * If the shape is already closed or there are no points in the path, this method does nothing.
     * @returns The instance of the current object for chaining.
     */
    closePath() {
      var _a;
      this._tick++;
      (_a = this._activePath) == null ? void 0 : _a.closePath();
      return this;
    }
    /**
     * Draws an ellipse at the specified location and with the given x and y radii.
     * An optional transformation can be applied, allowing for rotation, scaling, and translation.
     * @param x - The x-coordinate of the center of the ellipse.
     * @param y - The y-coordinate of the center of the ellipse.
     * @param radiusX - The horizontal radius of the ellipse.
     * @param radiusY - The vertical radius of the ellipse.
     * @returns The instance of the current object for chaining.
     */
    ellipse(x, y, radiusX, radiusY) {
      this._tick++;
      this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());
      return this;
    }
    /**
     * Draws a circle shape. This method adds a new circle path to the current drawing.
     * @param x - The x-coordinate of the center of the circle.
     * @param y - The y-coordinate of the center of the circle.
     * @param radius - The radius of the circle.
     * @returns The instance of the current object for chaining.
     */
    circle(x, y, radius) {
      this._tick++;
      this._activePath.circle(x, y, radius, this._transform.clone());
      return this;
    }
    /**
     * Adds another `GraphicsPath` to this path, optionally applying a transformation.
     * @param path - The `GraphicsPath` to add.
     * @returns The instance of the current object for chaining.
     */
    path(path) {
      this._tick++;
      this._activePath.addPath(path, this._transform.clone());
      return this;
    }
    /**
     * Connects the current point to a new point with a straight line. This method updates the current path.
     * @param x - The x-coordinate of the new point to connect to.
     * @param y - The y-coordinate of the new point to connect to.
     * @returns The instance of the current object for chaining.
     */
    lineTo(x, y) {
      this._tick++;
      const t = this._transform;
      this._activePath.lineTo(
        t.a * x + t.c * y + t.tx,
        t.b * x + t.d * y + t.ty
      );
      return this;
    }
    /**
     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
     * @param x - The x-coordinate for the starting point.
     * @param y - The y-coordinate for the starting point.
     * @returns The instance of the current object for chaining.
     */
    moveTo(x, y) {
      this._tick++;
      const t = this._transform;
      const instructions = this._activePath.instructions;
      const transformedX = t.a * x + t.c * y + t.tx;
      const transformedY = t.b * x + t.d * y + t.ty;
      if (instructions.length === 1 && instructions[0].action === "moveTo") {
        instructions[0].data[0] = transformedX;
        instructions[0].data[1] = transformedY;
        return this;
      }
      this._activePath.moveTo(
        transformedX,
        transformedY
      );
      return this;
    }
    /**
     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
     * The starting point is the last point in the current path.
     * @param cpx - The x-coordinate of the control point.
     * @param cpy - The y-coordinate of the control point.
     * @param x - The x-coordinate of the end point.
     * @param y - The y-coordinate of the end point.
     * @param smoothness - Optional parameter to adjust the smoothness of the curve.
     * @returns The instance of the current object for chaining.
     */
    quadraticCurveTo(cpx, cpy, x, y, smoothness) {
      this._tick++;
      const t = this._transform;
      this._activePath.quadraticCurveTo(
        t.a * cpx + t.c * cpy + t.tx,
        t.b * cpx + t.d * cpy + t.ty,
        t.a * x + t.c * y + t.tx,
        t.b * x + t.d * y + t.ty,
        smoothness
      );
      return this;
    }
    /**
     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
     * @param x - The x-coordinate of the top-left corner of the rectangle.
     * @param y - The y-coordinate of the top-left corner of the rectangle.
     * @param w - The width of the rectangle.
     * @param h - The height of the rectangle.
     * @returns The instance of the current object for chaining.
     */
    rect(x, y, w, h) {
      this._tick++;
      this._activePath.rect(x, y, w, h, this._transform.clone());
      return this;
    }
    /**
     * Draws a rectangle with rounded corners.
     * The corner radius can be specified to determine how rounded the corners should be.
     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
     * @param x - The x-coordinate of the top-left corner of the rectangle.
     * @param y - The y-coordinate of the top-left corner of the rectangle.
     * @param w - The width of the rectangle.
     * @param h - The height of the rectangle.
     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
     * @returns The instance of the current object for chaining.
     */
    roundRect(x, y, w, h, radius) {
      this._tick++;
      this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());
      return this;
    }
    /**
     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
     * rotated, or translated as needed.
     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
     * representing the x and y coordinates, of the polygon's vertices, in sequence.
     * @param close - A boolean indicating whether to close the polygon path. True by default.
     */
    poly(points, close) {
      this._tick++;
      this._activePath.poly(points, close, this._transform.clone());
      return this;
    }
    /**
     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
     * @param x - The x-coordinate of the center of the polygon.
     * @param y - The y-coordinate of the center of the polygon.
     * @param radius - The radius of the circumscribed circle of the polygon.
     * @param sides - The number of sides of the polygon. Must be 3 or more.
     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
     * @returns The instance of the current object for chaining.
     */
    regularPoly(x, y, radius, sides, rotation = 0, transform) {
      this._tick++;
      this._activePath.regularPoly(x, y, radius, sides, rotation, transform);
      return this;
    }
    /**
     * Draws a polygon with rounded corners.
     * Similar to `regularPoly` but with the ability to round the corners of the polygon.
     * @param x - The x-coordinate of the center of the polygon.
     * @param y - The y-coordinate of the center of the polygon.
     * @param radius - The radius of the circumscribed circle of the polygon.
     * @param sides - The number of sides of the polygon. Must be 3 or more.
     * @param corner - The radius of the rounding of the corners.
     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
     * @returns The instance of the current object for chaining.
     */
    roundPoly(x, y, radius, sides, corner, rotation) {
      this._tick++;
      this._activePath.roundPoly(x, y, radius, sides, corner, rotation);
      return this;
    }
    /**
     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
     * A minimum of 3 points is required.
     * @param radius - The default radius for the corners.
     * This radius is applied to all corners unless overridden in `points`.
     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
     *  method instead of an arc method. Defaults to false.
     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
     * Higher values make the curve smoother.
     * @returns The instance of the current object for chaining.
     */
    roundShape(points, radius, useQuadratic, smoothness) {
      this._tick++;
      this._activePath.roundShape(points, radius, useQuadratic, smoothness);
      return this;
    }
    /**
     * Draw Rectangle with fillet corners. This is much like rounded rectangle
     * however it support negative numbers as well for the corner radius.
     * @param x - Upper left corner of rect
     * @param y - Upper right corner of rect
     * @param width - Width of rect
     * @param height - Height of rect
     * @param fillet - accept negative or positive values
     */
    filletRect(x, y, width, height, fillet) {
      this._tick++;
      this._activePath.filletRect(x, y, width, height, fillet);
      return this;
    }
    /**
     * Draw Rectangle with chamfer corners. These are angled corners.
     * @param x - Upper left corner of rect
     * @param y - Upper right corner of rect
     * @param width - Width of rect
     * @param height - Height of rect
     * @param chamfer - non-zero real number, size of corner cutout
     * @param transform
     */
    chamferRect(x, y, width, height, chamfer, transform) {
      this._tick++;
      this._activePath.chamferRect(x, y, width, height, chamfer, transform);
      return this;
    }
    /**
     * Draws a star shape centered at a specified location. This method allows for the creation
     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
     * An optional transformation can be applied to scale, rotate, or translate the star as needed.
     * @param x - The x-coordinate of the center of the star.
     * @param y - The y-coordinate of the center of the star.
     * @param points - The number of points of the star.
     * @param radius - The outer radius of the star (distance from the center to the outer points).
     * @param innerRadius - Optional. The inner radius of the star
     * (distance from the center to the inner points between the outer points).
     * If not provided, defaults to half of the `radius`.
     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
     * Defaults to 0, meaning one point is directly upward.
     * @returns The instance of the current object for chaining further drawing commands.
     */
    star(x, y, points, radius, innerRadius = 0, rotation = 0) {
      this._tick++;
      this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());
      return this;
    }
    /**
     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
     * defined in SVG format to be drawn within the graphics context.
     * @param svg - The SVG string to be parsed and rendered.
     */
    svg(svg) {
      this._tick++;
      SVGParser(svg, this);
      return this;
    }
    /**
     * Restores the most recently saved graphics state by popping the top of the graphics state stack.
     * This includes transformations, fill styles, and stroke styles.
     */
    restore() {
      const state = this._stateStack.pop();
      if (state) {
        this._transform = state.transform;
        this._fillStyle = state.fillStyle;
        this._strokeStyle = state.strokeStyle;
      }
      return this;
    }
    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
    save() {
      this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: __spreadValues$S({}, this._fillStyle),
        strokeStyle: __spreadValues$S({}, this._strokeStyle)
      });
      return this;
    }
    /**
     * Returns the current transformation matrix of the graphics context.
     * @returns The current transformation matrix.
     */
    getTransform() {
      return this._transform;
    }
    /**
     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    resetTransform() {
      this._transform.identity();
      return this;
    }
    /**
     * Applies a rotation transformation to the graphics context around the current origin.
     * @param angle - The angle of rotation in radians.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    rotate(angle) {
      this._transform.rotate(angle);
      return this;
    }
    /**
     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
     * @param x - The scale factor in the horizontal direction.
     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    scale(x, y = x) {
      this._transform.scale(x, y);
      return this;
    }
    setTransform(a, b, c, d, dx, dy) {
      if (a instanceof Matrix) {
        this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);
        return this;
      }
      this._transform.set(a, b, c, d, dx, dy);
      return this;
    }
    transform(a, b, c, d, dx, dy) {
      if (a instanceof Matrix) {
        this._transform.append(a);
        return this;
      }
      tempMatrix$3.set(a, b, c, d, dx, dy);
      this._transform.append(tempMatrix$3);
      return this;
    }
    /**
     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
     * @param x - The amount to translate in the horizontal direction.
     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    translate(x, y = x) {
      this._transform.translate(x, y);
      return this;
    }
    /**
     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
     * and optionally resetting transformations to the identity matrix.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    clear() {
      this._activePath.clear();
      this.instructions.length = 0;
      this.resetTransform();
      this.onUpdate();
      return this;
    }
    onUpdate() {
      if (this.dirty)
        return;
      this.emit("update", this, 16);
      this.dirty = true;
      this._boundsDirty = true;
    }
    /** The bounds of the graphic shape. */
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      const bounds = this._bounds;
      bounds.clear();
      for (let i = 0; i < this.instructions.length; i++) {
        const instruction = this.instructions[i];
        const action = instruction.action;
        if (action === "fill") {
          const data = instruction.data;
          bounds.addBounds(data.path.bounds);
        } else if (action === "texture") {
          const data = instruction.data;
          bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
        }
        if (action === "stroke") {
          const data = instruction.data;
          const alignment = data.style.alignment;
          const padding = (data.style.width * (1 - alignment));
          const _bounds = data.path.bounds;
          bounds.addFrame(
            _bounds.minX - padding,
            _bounds.minY - padding,
            _bounds.maxX + padding,
            _bounds.maxY + padding
          );
        }
      }
      this._boundsDirty = false;
      return bounds;
    }
    /**
     * Check to see if a point is contained within this geometry.
     * @param point - Point to check if it's contained.
     * @returns {boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point) {
      var _a;
      if (!this.bounds.containsPoint(point.x, point.y))
        return false;
      const instructions = this.instructions;
      let hasHit = false;
      for (let k = 0; k < instructions.length; k++) {
        const instruction = instructions[k];
        const data = instruction.data;
        const path = data.path;
        if (!instruction.action || !path)
          continue;
        const style = data.style;
        const shapes = path.shapePath.shapePrimitives;
        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i].shape;
          if (!style || !shape)
            continue;
          const transform = shapes[i].transform;
          const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
          if (instruction.action === "fill") {
            hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
          } else {
            hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);
          }
          const holes = data.hole;
          if (holes) {
            const holeShapes = (_a = holes.shapePath) == null ? void 0 : _a.shapePrimitives;
            if (holeShapes) {
              for (let j = 0; j < holeShapes.length; j++) {
                if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {
                  hasHit = false;
                }
              }
            }
          }
          if (hasHit) {
            return true;
          }
        }
      }
      return hasHit;
    }
    /**
     * Destroys the GraphicsData object.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
     */
    destroy(options = false) {
      this._stateStack.length = 0;
      this._transform = null;
      this.emit("destroy", this);
      this.removeAllListeners();
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        if (this._fillStyle.texture) {
          this._fillStyle.texture.destroy(destroyTextureSource);
        }
        if (this._strokeStyle.texture) {
          this._strokeStyle.texture.destroy(destroyTextureSource);
        }
      }
      const gpuContext = this._gpuData;
      if (gpuContext) {
        if (!gpuContext.isBatchable) {
          if (this._graphicsData) {
            GraphicsContextRenderDataPool.return(this._graphicsData);
            this._graphicsData = null;
          }
        }
        if (gpuContext.batches) {
          const batches = gpuContext.batches;
          for (let i = 0; i < batches.length; i++) {
            BatchableGraphicsPool.return(batches[i]);
          }
        }
        GpuGraphicsContextPool.return(this._gpuData);
      }
      this._gpuData = null;
      this._fillStyle = null;
      this._strokeStyle = null;
      this.instructions = null;
      this._activePath = null;
      this._bounds = null;
      this._stateStack = null;
      this.customShader = null;
      this._transform = null;
    }
  };
  /** The default fill style to use when none is provided. */
  GraphicsContext.defaultFillStyle = {
    /** The color to use for the fill. */
    color: 16777215,
    /** The alpha value to use for the fill. */
    alpha: 1,
    /** The texture to use for the fill. */
    texture: Texture.WHITE,
    /** The matrix to apply. */
    matrix: null,
    /** The fill pattern to use. */
    fill: null
  };
  /** The default stroke style to use when none is provided. */
  GraphicsContext.defaultStrokeStyle = {
    /** The width of the stroke. */
    width: 1,
    /** The color to use for the stroke. */
    color: 16777215,
    /** The alpha value to use for the stroke. */
    alpha: 1,
    /** The alignment of the stroke. */
    alignment: 0.5,
    /** The miter limit to use. */
    miterLimit: 10,
    /** The line cap style to use. */
    cap: "butt",
    /** The line join style to use. */
    join: "miter",
    /** The texture to use for the fill. */
    texture: Texture.WHITE,
    /** The matrix to apply. */
    matrix: null,
    /** The fill pattern to use. */
    fill: null
  };

  class Graphics extends ViewContainer {
    /**
     * @param options - Options for the Graphics.
     */
    constructor(options) {
      if (options instanceof GraphicsContext) {
        options = { context: options };
      }
      const _a = options || {}, { context, roundPixels } = _a, rest = __objRest$i(_a, ["context", "roundPixels"]);
      super(__spreadValues$Q({
        label: "Graphics"
      }, rest));
      this.renderPipeId = "graphics";
      if (!context) {
        this._context = this._ownedContext = new GraphicsContext();
      } else {
        this._context = context;
      }
      this._context.on("update", this.onViewUpdate, this);
      this.allowChildren = false;
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    set context(context) {
      if (context === this._context)
        return;
      this._context.off("update", this.onViewUpdate, this);
      this._context = context;
      this._context.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    get context() {
      return this._context;
    }
    /**
     * The local bounds of the graphic.
     * @type {rendering.Bounds}
     */
    get bounds() {
      return this._context.bounds;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      bounds.addBounds(this._context.bounds);
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      return this._context.containsPoint(point);
    }
    /**
     * Destroys this graphics renderable and optionally its context.
     * @param options - Options parameter. A boolean will act as if all options
     *
     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
     * then the context will still be destroyed.
     *
     * If you want to explicitly not destroy this context that this graphics created,
     * then you should pass destroy({ context: false })
     *
     * If the context was passed in as an argument to the constructor then it will not be destroyed
     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
     * @param {boolean} [options.context=false] - Should destroy the context
     */
    destroy(options) {
      if (this._ownedContext && !options) {
        this._ownedContext.destroy(options);
      } else if (options === true || (options == null ? void 0 : options.context) === true) {
        this._context.destroy(options);
      }
      if (this._gpuData) {
        for (let i = 0; i < this._gpuData.length; i++) {
          BatchableGraphicsPool.return(this._gpuData[i]);
        }
        this._gpuData = null;
      }
      this._ownedContext = null;
      this._context = null;
      super.destroy(options);
    }
    _callContextMethod(method, args) {
      this.context[method](...args);
      return this;
    }
    // --------------------------------------- GraphicsContext methods ---------------------------------------
    /**
     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
     * pattern, or a more complex style defined by a FillStyle object.
     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
     * pattern object, or a FillStyle or ConvertedFillStyle object.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    setFillStyle(...args) {
      return this._callContextMethod("setFillStyle", args);
    }
    /**
     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
     * or a StrokeStyle or ConvertedStrokeStyle object.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    setStrokeStyle(...args) {
      return this._callContextMethod("setStrokeStyle", args);
    }
    fill(...args) {
      return this._callContextMethod("fill", args);
    }
    /**
     * Strokes the current path with the current stroke style. This method can take an optional
     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
     * complex style object. If omitted, uses the current stroke style.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    stroke(...args) {
      return this._callContextMethod("stroke", args);
    }
    texture(...args) {
      return this._callContextMethod("texture", args);
    }
    /**
     * Resets the current path. Any previous path and its commands are discarded and a new path is
     * started. This is typically called before beginning a new shape or series of drawing commands.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    /**
     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
     * fail to cut correctly!
     */
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...args) {
      return this._callContextMethod("arc", args);
    }
    arcTo(...args) {
      return this._callContextMethod("arcTo", args);
    }
    arcToSvg(...args) {
      return this._callContextMethod("arcToSvg", args);
    }
    bezierCurveTo(...args) {
      return this._callContextMethod("bezierCurveTo", args);
    }
    /**
     * Closes the current path by drawing a straight line back to the start.
     * If the shape is already closed or there are no points in the path, this method does nothing.
     * @returns The instance of the current object for chaining.
     */
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...args) {
      return this._callContextMethod("ellipse", args);
    }
    circle(...args) {
      return this._callContextMethod("circle", args);
    }
    path(...args) {
      return this._callContextMethod("path", args);
    }
    lineTo(...args) {
      return this._callContextMethod("lineTo", args);
    }
    moveTo(...args) {
      return this._callContextMethod("moveTo", args);
    }
    quadraticCurveTo(...args) {
      return this._callContextMethod("quadraticCurveTo", args);
    }
    rect(...args) {
      return this._callContextMethod("rect", args);
    }
    roundRect(...args) {
      return this._callContextMethod("roundRect", args);
    }
    poly(...args) {
      return this._callContextMethod("poly", args);
    }
    regularPoly(...args) {
      return this._callContextMethod("regularPoly", args);
    }
    roundPoly(...args) {
      return this._callContextMethod("roundPoly", args);
    }
    roundShape(...args) {
      return this._callContextMethod("roundShape", args);
    }
    filletRect(...args) {
      return this._callContextMethod("filletRect", args);
    }
    chamferRect(...args) {
      return this._callContextMethod("chamferRect", args);
    }
    star(...args) {
      return this._callContextMethod("star", args);
    }
    svg(...args) {
      return this._callContextMethod("svg", args);
    }
    restore(...args) {
      return this._callContextMethod("restore", args);
    }
    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
    save() {
      return this._callContextMethod("save", []);
    }
    /**
     * Returns the current transformation matrix of the graphics context.
     * @returns The current transformation matrix.
     */
    getTransform() {
      return this.context.getTransform();
    }
    /**
     * Resets the current transformation matrix to the identity matrix, effectively removing
     * any transformations (rotation, scaling, translation) previously applied.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...args) {
      return this._callContextMethod("rotate", args);
    }
    scaleTransform(...args) {
      return this._callContextMethod("scale", args);
    }
    setTransform(...args) {
      return this._callContextMethod("setTransform", args);
    }
    transform(...args) {
      return this._callContextMethod("transform", args);
    }
    translateTransform(...args) {
      return this._callContextMethod("translate", args);
    }
    /**
     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
     * and optionally resetting transformations to the identity matrix.
     * @returns The instance of the current GraphicsContext for method chaining.
     */
    clear() {
      return this._callContextMethod("clear", []);
    }
    /**
     * The fill style to use.
     * @type {ConvertedFillStyle}
     */
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(value) {
      this._context.fillStyle = value;
    }
    /**
     * The stroke style to use.
     * @type {ConvertedStrokeStyle}
     */
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(value) {
      this._context.strokeStyle = value;
    }
    /**
     * Creates a new Graphics object.
     * Note that only the context of the object is cloned, not its transform (position,scale,etc)
     * @param deep - Whether to create a deep clone of the graphics object. If false, the context
     * will be shared between the two objects (default false). If true, the context will be
     * cloned (recommended if you need to modify the context in any way).
     * @returns - A clone of the graphics object
     */
    clone(deep = false) {
      if (deep) {
        return new Graphics(this._context.clone());
      }
      this._ownedContext = null;
      const clone = new Graphics(this._context);
      return clone;
    }
    // -------- v7 deprecations ---------
    /**
     * @param width
     * @param color
     * @param alpha
     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
     */
    lineStyle(width, color, alpha) {
      deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const strokeStyle = {};
      width && (strokeStyle.width = width);
      color && (strokeStyle.color = color);
      alpha && (strokeStyle.alpha = alpha);
      this.context.strokeStyle = strokeStyle;
      return this;
    }
    /**
     * @param color
     * @param alpha
     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
     */
    beginFill(color, alpha) {
      deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const fillStyle = {};
      color && (fillStyle.color = color);
      alpha && (fillStyle.alpha = alpha);
      this.context.fillStyle = fillStyle;
      return this;
    }
    /**
     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
     */
    endFill() {
      deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      this.context.fill();
      const strokeStyle = this.context.strokeStyle;
      if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
        this.context.stroke();
      }
      return this;
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
     */
    drawCircle(...args) {
      deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
      return this._callContextMethod("circle", args);
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
     */
    drawEllipse(...args) {
      deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
      return this._callContextMethod("ellipse", args);
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
     */
    drawPolygon(...args) {
      deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
      return this._callContextMethod("poly", args);
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
     */
    drawRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
      return this._callContextMethod("rect", args);
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
     */
    drawRoundedRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
      return this._callContextMethod("roundRect", args);
    }
    /**
     * @param {...any} args
     * @deprecated since 8.0.0 Use {@link Graphics#star} instead
     */
    drawStar(...args) {
      deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
      return this._callContextMethod("star", args);
    }
  }


  "use strict";
  class GpuGraphicsContext {
    constructor() {
      this.batches = [];
      this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  const GpuGraphicsContextPool = createPool("GpuGraphicsContextPool", GpuGraphicsContext);
  class GraphicsContextRenderData {
    constructor() {
      this.batcher = new DefaultBatcher();
      this.instructions = new InstructionSet();
    }
    init() {
      this.instructions.reset();
    }
    /**
     * @deprecated since version 8.0.0
     * Use `batcher.geometry` instead.
     * @see {Batcher#geometry}
     */
    get geometry() {
      deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
      return this.batcher.geometry;
    }
  }
  const GraphicsContextRenderDataPool = createPool("GraphicsContextRenderDataPool", GraphicsContextRenderData);
  const _GraphicsContextSystem = class _GraphicsContextSystem {
    constructor(renderer) {
      this.renderer = renderer;
    }
    /**
     * Runner init called, update the default options
     * @ignore
     */
    init(options) {
      var _a;
      _GraphicsContextSystem.defaultOptions.bezierSmoothness = (_a = options == null ? void 0 : options.bezierSmoothness) != null ? _a : _GraphicsContextSystem.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(context) {
      return context._graphicsData || this._initContextRenderData(context);
    }
    // Context management functions
    updateGpuContext(context) {
      let gpuContext = context._gpuData || this._initContext(context);
      if (context.dirty) {
        if (gpuContext) {
          this._cleanGraphicsContextData(context);
        } else {
          gpuContext = this._initContext(context);
        }
        buildContextBatches(context, gpuContext);
        const batchMode = context.batchMode;
        if (context.customShader || batchMode === "no-batch") {
          gpuContext.isBatchable = false;
        } else if (batchMode === "auto") {
          gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
        }
        context.dirty = false;
      }
      return gpuContext;
    }
    getGpuContext(context) {
      return context._gpuData || this._initContext(context);
    }
    _initContextRenderData(context) {
      const graphicsData = GraphicsContextRenderDataPool.get();
      const gpuContext = context._gpuData;
      const batches = gpuContext.batches;
      const geometryData = gpuContext.geometryData;
      const vertexSize = geometryData.vertices.length;
      const indexSize = geometryData.indices.length;
      for (let i = 0; i < batches.length; i++) {
        batches[i].applyTransform = false;
      }
      const batcher = graphicsData.batcher;
      batcher.ensureAttributeBuffer(vertexSize);
      batcher.ensureIndexBuffer(indexSize);
      batcher.begin();
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        batcher.add(batch);
      }
      batcher.finish(graphicsData.instructions);
      const geometry = batcher.geometry;
      geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
      geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
      const drawBatches = batcher.batches;
      for (let i = 0; i < drawBatches.length; i++) {
        const batch = drawBatches[i];
        const batchTexture = batch.textures;
        batch.bindGroup = getTextureBatchBindGroup(batchTexture.textures, batchTexture.count);
      }
      context._graphicsData = graphicsData;
      return graphicsData;
    }
    _initContext(context) {
      const gpuContext = GpuGraphicsContextPool.get();
      gpuContext.context = context;
      context._gpuData = gpuContext;
      return gpuContext;
    }
    destroy() {
      this.renderer = null;
    }
  };
  /** @ignore */
  _GraphicsContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "graphicsContext"
  };
  /** The default options for the GraphicsContextSystem. */
  _GraphicsContextSystem.defaultOptions = {
    /**
     * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
     * @default 0.5
     */
    bezierSmoothness: 0.5
  };
  let GraphicsContextSystem = _GraphicsContextSystem;


  "use strict";
  const shapeBuilders = {};

  const tempRect$1 = new Rectangle();
  function buildContextBatches(context, gpuContext) {
    const geometryData = gpuContext.geometryData;
    const batches = gpuContext.batches;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    const instructions = context.instructions;
    for (let i = 0; i < instructions.length; i++) {
      const instruction = instructions[i];
      const data = instruction.data;
      if (instruction.action === "texture") {
        addTextureToGeometryData(data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = data.path.shapePath;
        const style = data.style;
        const hole = data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect$1;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs[0],
      textureUvs[1],
      textureUvs[2],
      textureUvs[3],
      textureUvs[6],
      textureUvs[7],
      textureUvs[4],
      textureUvs[5],
    );
    const graphicsBatch = BatchableGraphicsPool.get();
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    const shapePrimitives = shapePath.shapePrimitives;
    for (let i = 0; i < shapePrimitives.length; i++) {
      const shapeObj = shapePrimitives[i];
      const shape = shapeObj.shape;
      const matrix = shapeObj.transform;
      var _a;
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = shapeBuilders[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i) {
          if (lastIndex !== 0) {
            Logger.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          const pointsSize = otherPoints.length / 2;
          for (let k = 0; j < holeArrays.length; k++) {
            const holePoints = holeArrays[i];
            holeIndices.push(pointsSize);
            otherPoints.push(...holePoints);
          }
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = (_a = shape.closePath) != null ? _a : true;
        const lineStyle = style;
        buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = style.matrix;
        if (textureMatrix) {
          if (matrix) {
            textureMatrix.append(matrix.clone().invert());
          }
          buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        }
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BatchableGraphicsPool.get();
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    };
  }
  function getHoleArrays(shape) {
    if (!shape)
      return [];
    const holePrimitives = shape.shapePrimitives;
    const holeArrays = [];
    for (let k = 0; k < holePrimitives.length; k++) {
      const holePrimitive = holePrimitives[k].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }

  "use strict";
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = earcut$1(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i = 0; i < triangles.length; i += 3) {
      indices[indicesOffset++] = triangles[i] + verticesOffset;
      indices[indicesOffset++] = triangles[i + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i = 0; i < points.length; i += 2) {
      vertices[index] = points[i];
      vertices[index + 1] = points[i + 1];
      index += verticesStride;
    }
  }

  "use strict";
  const emptyArray = [];
  const buildPolygon = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "polygon"
    },
    build(shape, points) {
      for (let i = 0; i < shape.points.length; i++) {
        points[i] = shape.points[i];
      }
      return points;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
    }
  };

  "use strict";
  const buildRectangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "rectangle"
    },
    build(shape, points) {
      const rectData = shape;
      const x = rectData.x;
      const y = rectData.y;
      const width = rectData.width;
      const height = rectData.height;
      if (!(width >= 0 && height >= 0)) {
        return points;
      }
      points[0] = x;
      points[1] = y;
      points[2] = x + width;
      points[3] = y;
      points[4] = x + width;
      points[5] = y + height;
      points[6] = x;
      points[7] = y + height;
      return points;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count] = points[0];
      vertices[verticesOffset + count + 1] = points[1];
      count += verticesStride;
      vertices[verticesOffset + count] = points[2];
      vertices[verticesOffset + count + 1] = points[3];
      count += verticesStride;
      vertices[verticesOffset + count] = points[6];
      vertices[verticesOffset + count + 1] = points[7];
      count += verticesStride;
      vertices[verticesOffset + count] = points[4];
      vertices[verticesOffset + count + 1] = points[5];
      count += verticesStride;
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 3;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };

  "use strict";
  const buildTriangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "triangle"
    },
    build(shape, points) {
      points[0] = shape.x;
      points[1] = shape.y;
      points[2] = shape.x2;
      points[3] = shape.y2;
      points[4] = shape.x3;
      points[5] = shape.y3;
      return points;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count] = points[0];
      vertices[verticesOffset + count + 1] = points[1];
      count += verticesStride;
      vertices[verticesOffset + count] = points[2];
      vertices[verticesOffset + count + 1] = points[3];
      count += verticesStride;
      vertices[verticesOffset + count] = points[4];
      vertices[verticesOffset + count + 1] = points[5];
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };

  var earcut$2 = { exports: {} };
  'use strict';

  earcut$2.exports = earcut;
  earcut$2.exports.default = earcut;

  function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
      outerLen = hasHoles ? holeIndices[0] * dim : data.length,
      outerNode = linkedList(data, 0, outerLen, dim, true),
      triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      // minX, minY and invSize are later used to transform coords into integers for z-order calculation
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
  }

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
      for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }

    return last;
  }

  // eliminate colinear or duplicate points
  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
      again;
    do {
      again = false;

      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;

      } else {
        p = p.next;
      }
    } while (again || p !== end);

    return end;
  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
      prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;

      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        // cut off the triangle
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);

        removeNode(ear);

        // skipping the next vertex leads to less sliver triangles
        ear = next.next;
        stop = next.next;

        continue;
      }

      ear = next;

      // if we looped through the whole remaining polygon and can't find any more ears
      if (ear === stop) {
        // try filtering points and slicing again
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

          // if this didn't work, try curing all small self-intersections locally
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

          // as a last resort, try splitting the remaining polygon into two
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }

        break;
      }
    }
  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear) {
    var a = ear.prev,
      b = ear,
      c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
      y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
      x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
      y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
        pointInTriangle$1(ax, ay, bx, by, cx, cy, p.x, p.y) &&
        area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }

    return true;
  }

  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
      b = ear,
      c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
      y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
      x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
      y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
      maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
      n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
        pointInTriangle$1(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;

      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
        pointInTriangle$1(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
        pointInTriangle$1(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
        pointInTriangle$1(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    return true;
  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
      var a = p.prev,
        b = p.next.next;

      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);

        // remove two nodes involved
        removeNode(p);
        removeNode(p.next);

        p = start = b;
      }
      p = p.next;
    } while (p !== start);

    return filterPoints(p);
  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          // split the polygon in two by the diagonal
          var c = splitPolygon(a, b);

          // filter colinear points around the cuts
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);

          // run earcut on each half
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
      i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
  }

  function compareX(a, b) {
    return a.x - b.x;
  }

  // find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
        }
      }
      p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;

    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x &&
        pointInTriangle$1(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

        if (locallyInside(p, hole) &&
          (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);

    return m;
  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }

  // interlink polygon nodes in z-order
  function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
      if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
      inSize = 1;

    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;

      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        qSize = inSize;

        while (pSize > 0 || (qSize > 0 && q)) {

          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }

          if (tail) tail.nextZ = e;
          else list = e;

          e.prevZ = tail;
          tail = e;
        }

        p = q;
      }

      tail.nextZ = null;
      inSize *= 2;

    } while (numMerges > 1);

    return list;
  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
  }

  // find the leftmost node of a polygon ring
  function getLeftmost(start) {
    var p = start,
      leftmost = start;
    do {
      if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
      p = p.next;
    } while (p !== start);

    return leftmost;
  }

  // check if a point lies within a convex triangle
  function pointInTriangle$1(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
      (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
      (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  }

  // signed area of a triangle
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }

  // check if two points are equal
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }

  // check if two segments intersect
  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }

  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a, b) {
    var p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
        intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);

    return false;
  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
      area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
      area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a, b) {
    var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;
    do {
      if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
        (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
        inside = !inside;
      p = p.next;
    } while (p !== a);

    return inside;
  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
      p.prev = p;
      p.next = p;

    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }

  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }

  function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
  }

  // return a percentage difference between the polygon area and its triangulation area;
  // used to verify correctness of triangulation
  earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs(
        (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
        (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
      Math.abs((trianglesArea - polygonArea) / polygonArea);
  };

  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }

  // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
  earcut.flatten = function (data) {
    var dim = data[0][0].length,
      result = { vertices: [], holes: [], dimensions: dim },
      holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var earcutExports = earcut$2.exports;
  var earcut$1 = /*@__PURE__*/getDefaultExportFromCjs(earcutExports);

  function buildGeometryFromPath(options) {
    if (options instanceof GraphicsPath) {
      options = {
        path: options,
        textureMatrix: null,
        out: null
      };
    }
    const vertices = [];
    const uvs = [];
    const indices = [];
    const shapePath = options.path.shapePath;
    const textureMatrix = options.textureMatrix;
    const shapePrimitives = shapePath.shapePrimitives;
    for (let i = 0; i < shapePrimitives.length; i++) {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const shapeObj = shapePrimitives[i];
      const shape = shapeObj.shape;
      const matrix = shapeObj.transform;
      const build = buildMap[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      const uvsOffset = uvs.length / 2;
      if (textureMatrix) {
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
    };
    const out = options.out;
    if (out) {
      out.positions = new Float32Array(vertices);
      out.uvs = new Float32Array(uvs);
      out.indices = new Uint32Array(indices);
      return out;
    }
    const geometry = new MeshGeometry({
      positions: new Float32Array(vertices),
      uvs: new Float32Array(uvs),
      indices: new Uint32Array(indices)
    });
    return geometry;
  }


  "use strict";
  function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x - nx * innerWeight;
    const iy = y - ny * innerWeight;
    const ox = x + nx * outerWeight;
    const oy = y + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }


  function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i = 1; i < length - 1; ++i) {
      x0 = points[(i - 1) * 2];
      y0 = points[(i - 1) * 2 + 1];
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
      x0 = verts[i * 2];
      y0 = verts[i * 2 + 1];
      x1 = verts[(i + 1) * 2];
      y1 = verts[(i + 1) * 2 + 1];
      x2 = verts[(i + 2) * 2];
      y2 = verts[(i + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i, i + 1, i + 2);
    }
  }
  "use strict";
  var __defProp$W = Object.defineProperty;
  var __defProps$o = Object.defineProperties;
  var __getOwnPropDescs$o = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$W = Object.getOwnPropertySymbols;
  var __hasOwnProp$W = Object.prototype.hasOwnProperty;
  var __propIsEnum$W = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$W = (obj, key, value) => key in obj ? __defProp$W(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$W = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$W.call(b, prop))
        __defNormalProp$W(a, prop, b[prop]);
    if (__getOwnPropSymbols$W)
      for (var prop of __getOwnPropSymbols$W(b)) {
        if (__propIsEnum$W.call(b, prop))
          __defNormalProp$W(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$o = (a, b) => __defProps$o(a, __getOwnPropDescs$o(b));
  const buildCircle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "circle"
    },
    build(shape, points) {
      let x;
      let y;
      let dx;
      let dy;
      let rx;
      let ry;
      if (shape.type === "circle") {
        const circle = shape;
        x = circle.x;
        y = circle.y;
        rx = ry = circle.radius;
        dx = dy = 0;
      } else if (shape.type === "ellipse") {
        const ellipse = shape;
        x = ellipse.x;
        y = ellipse.y;
        rx = ellipse.halfWidth;
        ry = ellipse.halfHeight;
        dx = dy = 0;
      } else {
        const roundedRect = shape;
        const halfWidth = roundedRect.width / 2;
        const halfHeight = roundedRect.height / 2;
        x = roundedRect.x + halfWidth;
        y = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx = halfWidth - rx;
        dy = halfHeight - ry;
      }
      if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
        return points;
      }
      const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
      const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
      if (m === 0) {
        return points;
      }
      if (n === 0) {
        points[0] = points[6] = x + dx;
        points[1] = points[3] = y + dy;
        points[2] = points[4] = x - dx;
        points[5] = points[7] = y - dy;
        return points;
      }
      let j1 = 0;
      let j2 = n * 4 + (dx ? 2 : 0) + 2;
      let j3 = j2;
      let j4 = m;
      let x0 = dx + rx;
      let y0 = dy;
      let x1 = x + x0;
      let x2 = x - x0;
      let y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        const y22 = y - y0;
        points[j3++] = x2;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
      for (let i = 1; i < n; i++) {
        const a = Math.PI / 2 * (i / n);
        const x02 = dx + Math.cos(a) * rx;
        const y02 = dy + Math.sin(a) * ry;
        const x12 = x + x02;
        const x22 = x - x02;
        const y12 = y + y02;
        const y22 = y - y02;
        points[j1++] = x12;
        points[j1++] = y12;
        points[--j2] = y12;
        points[--j2] = x22;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x12;
      }
      x0 = dx;
      y0 = dy + ry;
      x1 = x + x0;
      x2 = x - x0;
      y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
      return points;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      if (points.length === 0) {
        return;
      }
      let centerX = 0;
      let centerY = 0;
      for (let i = 0; i < points.length; i += 2) {
        centerX += points[i];
        centerY += points[i + 1];
      }
      centerX /= points.length / 2;
      centerY /= points.length / 2;
      let count = verticesOffset;
      vertices[count * verticesStride] = centerX;
      vertices[count * verticesStride + 1] = centerY;
      const centerIndex = count++;
      for (let i = 0; i < points.length; i += 2) {
        vertices[count * verticesStride] = points[i];
        vertices[count * verticesStride + 1] = points[i + 1];
        if (i > 0) {
          indices[indicesOffset++] = count;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count - 1;
        }
        count++;
      }
      indices[indicesOffset++] = centerIndex + 1;
      indices[indicesOffset++] = centerIndex;
      indices[indicesOffset++] = count - 1;
    }
  };
  const buildEllipse = __spreadProps$o(__spreadValues$W({}, buildCircle), { extension: __spreadProps$o(__spreadValues$W({}, buildCircle.extension), { name: "ellipse" }) });
  const buildRoundedRectangle = __spreadProps$o(__spreadValues$W({}, buildCircle), { extension: __spreadProps$o(__spreadValues$W({}, buildCircle.extension), { name: "roundedRectangle" }) });

  const buildMap = {
    rectangle: buildRectangle,
    polygon: buildPolygon,
    triangle: buildTriangle,
    circle: buildCircle,
    ellipse: buildCircle,
    roundedRectangle: buildCircle
  };

  extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
  extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);

  class GraphicsPipe {
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init(renderer);
    }
    validateRenderable(graphics) {
      const context = graphics.context;
      const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);
      if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
        return true;
      }
      return false;
    }
    addRenderable(graphics, instructionSet) {
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      if (graphics.didViewUpdate) {
        this._rebuild(graphics);
      }
      if (gpuContext.isBatchable) {
        this._addToBatcher(graphics, instructionSet);
      } else {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(graphics);
      }
    }
    updateRenderable(graphics) {
      const batches = this._graphicsBatchesHash[graphics.uid];
      if (batches) {
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          batch._batcher.updateElement(batch);
        }
      }
    }
    execute(graphics) {
      if (!graphics._visible) return;
      const renderer = this.renderer;
      const context = graphics.context;
      const contextSystem = renderer.graphicsContext;
      if (!contextSystem.getGpuContext(context).batches.length) {
        return;
      }
      this.state.blendMode = graphics.groupBlendMode;
      const localUniforms = this._adaptor.localUniforms.uniforms;
      localUniforms.uTransformMatrix = graphics.groupTransform;
      localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
      color32BitToUniform(
        graphics.groupColorAlpha,
        localUniforms.uColor,
        0
      );
      this._adaptor.execute(this, graphics);
    }
    _rebuild(graphics) {
      const wasBatched = graphics._gpuData !== null;
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      if (wasBatched) {
        for (let i = 0; i < graphics._gpuData.length; i++) {
          BatchableGraphicsPool.return(graphics._gpuData[i]);
        }
        graphics._gpuData = null;
      }
      if (gpuContext.isBatchable) {
        this._initBatchesForRenderable(graphics);
      }
      graphics.batched = gpuContext.isBatchable;
    }
    _addToBatcher(graphics, instructionSet) {
      const batchPipe = this.renderer.renderPipes.batch;
      const batches = this._getBatchesForRenderable(graphics);
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        batchPipe.addToBatch(batch, instructionSet);
      }
    }
    _getBatchesForRenderable(graphics) {
      return graphics._gpuData || this._initBatchesForRenderable(graphics);
    }
    _initBatchesForRenderable(graphics) {
      const context = graphics.context;
      const gpuContext = this.renderer.graphicsContext.getGpuContext(context);
      const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
      const batches = [];
      for (let i = 0; i < gpuContext.batches.length; i++) {
        const batch = gpuContext.batches[i];
        const batchClone = BatchableGraphicsPool.get();
        batch.copyTo(batchClone);
        batchClone.renderable = graphics;
        batchClone.roundPixels = roundPixels;
        batches[i] = batchClone;
      }
      graphics._gpuData = batches;
      return batches;
    }
    destroy() {
      this.renderer = null;
      this._adaptor.destroy();
      this._adaptor = null;
      this.state = null;
    }
  }
  /** @ignore */
  GraphicsPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "graphics"
  };

  extensions.add(GraphicsPipe);
  extensions.add(GraphicsContextSystem);

  "use strict";
  class GlGraphicsAdaptor {
    init(renderer) {
      const uniforms = new UniformGroup({
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uRound: { value: 0, type: "f32" }
      });
      const maxTextures = renderer.limits.maxBatchableTextures;
      const glProgram = compileHighShaderGlProgram(
        [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          localUniformBitGl,
          roundPixelsBitGl
        ],
        "graphics"
      );
      this.shader = new Shader({
        glProgram,
        resources: {
          localUniforms: uniforms,
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
      this.localUniforms = uniforms;
    }
    execute(graphicsPipe, renderable) {
      const context = renderable.context;
      const shader = context.customShader || this.shader;
      const renderer = graphicsPipe.renderer;
      const contextSystem = renderer.graphicsContext;
      const contextData = contextSystem.getContextRenderData(context);
      const batcher = contextData.batcher;
      const instructions = contextData.instructions
      shader.groups[0] = renderer.globalUniforms.bindGroup;
      renderer.state.set(graphicsPipe.state);
      renderer.shader.bind(shader);
      renderer.geometry.bind(batcher.geometry, shader.glProgram);
      const batches = instructions.instructions;
      const textureSystem = renderer.texture;
      for (let i = 0; i < instructions.instructionSize; i++) {
        const batch = batches[i];
        if (batch.size) {
          const batchTexture = batch.textures;
          const textureCount = batchTexture.count;
          const textureArray = batchTexture.textures;
          for (let j = 0; j < textureCount; j++) {
            textureSystem.bind(textureArray[j], j);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(true);
      this.shader = null;
    }
  }
  /** @ignore */
  GlGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "graphics"
  };


  "use strict";
  class GpuGraphicsAdaptor {
    init(renderer) {
      const localUniforms = new UniformGroup({
        uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 0, type: "f32" }
      });
      const maxTextures = renderer.limits.maxBatchableTextures;
      const gpuProgram = compileHighShaderGpuProgram(
        [
          colorBit,
          generateTextureBatchBit(maxTextures),
          localUniformBitGroup2,
          roundPixelsBit
        ],
        "graphics"
      );
      this.shader = new Shader({
        gpuProgram,
        resources: {
          // added on the fly!
          localUniforms
        }
      });
      this.localUniforms = localUniforms;
    }
    execute(graphicsPipe, renderable) {
      const context = renderable.context;
      const shader = context.customShader || this.shader;
      const renderer = graphicsPipe.renderer;
      const contextSystem = renderer.graphicsContext;
      const {
        batcher,
        instructions
      } = contextSystem.getContextRenderData(context);
      const encoder = renderer.encoder;
      encoder.setPipelineFromGeometryProgramAndState(
        batcher.geometry,
        shader.gpuProgram,
        graphicsPipe.state
      );
      const bindGroup = renderer.bindGroup;
      encoder.setGeometry(batcher.geometry, shader.gpuProgram);
      const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
      encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram, bindGroup);
      const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(this.localUniforms, true);
      encoder.setBindGroup(2, localBindGroup, shader.gpuProgram, bindGroup);
      const batches = instructions.instructions;
      for (let i = 0; i < instructions.instructionSize; i++) {
        const batch = batches[i];
        shader.groups[1] = batch.bindGroup;
        if (!batch.gpuBindGroup) {
          const textureBatch = batch.textures;
          // batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
            textureBatch.bindGroup,
            shader.gpuProgram,
            1
          );
        }
        encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram, bindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
    }
    destroy() {
      this.shader.destroy(true);
      this.shader = null;
    }
  }
  /** @ignore */
  GpuGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "graphics"
  };
  "use strict";
  const repetitionMap = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };

  "use strict";
  class FillGradient {
    constructor(x0, y0, x1, y1) {
      /** unique id for this fill gradient */
      this.uid = uid$1("fillGradient");
      this.type = "linear";
      this.gradientStops = [];
      this._styleKey = null;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
      this.pool = Zaun.Core.Pool.PoolCache["CanvasPool"];
    }
    addColorStop(offset, color) {
      this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexWithAlpha() });
      this._styleKey = null;
      return this;
    }
    // TODO move to the system!
    buildLinearGradient() {
      if (this.texture) return;
      const defaultSize = FillGradient.defaultTextureSize;
      const { gradientStops } = this;
      const canvasObj = this.pool.get(defaultSize);
      const canvas = canvasObj.canvas;
      const ctx = canvasObj.context;
      const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);
      for (let i = 0; i < gradientStops.length; i++) {
        const stop = gradientStops[i];
        gradient.addColorStop(stop.offset, stop.color);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, defaultSize, defaultSize);
      const source = new TextureSource();
      source.setupOptions({
        resource: canvas
      });
      source.addressModeU = "clamp-to-edge";
      source.addressModeV = "repeat";
      source.uploadMethodId = "image";
      this.texture = new Texture({
        source
      });
      const { x0, y0, x1, y1 } = this;
      const m = new Matrix();
      const dx = x1 - x0;
      const dy = y1 - y0;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      m.translate(-x0, -y0)
        .scale(1 / defaultSize, 1 / defaultSize)
        .rotate(-angle)
        .scale(256 / dist, 1);
      this.transform = m;
      this._styleKey = null;
      this.pool.return(canvasObj);
    }
    get styleKey() {
      if (this._styleKey) {
        return this._styleKey;
      }
      const gradientStops = this.gradientStops;
      let stops = "";
      for (let i = 0; i < gradientStops.length; i++) {
        const stop = gradientStops[i];
        stops += `${stop.offset}-${stop.color}`;
      }
      const texture = this.texture.uid;
      const transform = this.transform.toArray().join("-");
      return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
    }
  };
  FillGradient.defaultTextureSize = 256;

  var parseSvgPath = parse;

  /**
   * expected argument lengths
   * @type {Object}
   */

  var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };

  /**
   * segment pattern
   * @type {RegExp}
   */

  var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

  /**
   * parse an svg path data string. Generates an Array
   * of commands where each command is an Array of the
   * form `[command, arg1, arg2, ...]`
   *
   * @param {String} path
   * @return {Array}
   */

  function parse(path) {
    var data = [];
    path.replace(segment, function (_, command, args) {
      var type = command.toLowerCase();
      args = parseValues(args);

      // overloaded moveTo
      if (type == 'm' && args.length > 2) {
        data.push([command].concat(args.splice(0, 2)));
        type = 'l';
        command = command == 'm' ? 'l' : 'L';
      }

      while (true) {
        if (args.length == length[type]) {
          args.unshift(command);
          return data.push(args)
        }
        if (args.length < length[type]) throw new Error('malformed path data')
        data.push([command].concat(args.splice(0, length[type])));
      }
    });
    return data
  }

  var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

  function parseValues(args) {
    var numbers = args.match(number);
    return numbers ? numbers.map(Number) : []
  }

  var parse$1 = /*@__PURE__*/getDefaultExportFromCjs(parseSvgPath);


  class FillPattern {
    constructor(texture, repetition) {
      /** unique id for this fill pattern */
      this.uid = uid$1("fillPattern");
      this.transform = new Matrix();
      this._styleKey = null;
      this.texture = texture;
      const frame = texture.frame;
      const style = texture._source._style;
      const map = repetitionMap[repetition];
      this.transform.scale(
        1 / frame.width,
        1 / frame.height
      );
      if (repetition) {
        style.addressModeU = map.addressModeU;
        style.addressModeV = map.addressModeV;
      }
    }
    setTransform(transform) {
      const frame = this.texture.frame;
      this.transform.copyFrom(transform)
        .invert()
        .scale(
          1 / frame.width,
          1 / frame.height
        );
      this._styleKey = null;
    }
    get styleKey() {
      if (this._styleKey)
        return this._styleKey;
      this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
      return this._styleKey;
    }
  }


  "use strict";
  const tempPath = [];
  function SVGToGraphicsPath(svgPath, path) {
    const commands = parse$1(svgPath);
    const subpaths = tempPath.clear();
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i = 0; i < commands.length; i++) {
      const command = commands[i];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path.bezierCurveTo(
            data[1],
            data[2],
            data[3],
            data[4],
            lastX,
            lastY
          );
          break;
        case "c":
          path.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4],
            lastX + data[5],
            lastY + data[6]
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path.bezierCurveToShort(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "s":
          path.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path.quadraticCurveTo(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "q":
          path.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "Z":
        case "z":
          path.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          Logger.warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path;
  }

  class TilingSprite extends ViewContainer {
    constructor(options = TilingSprite.defaultOptions) {
      super();
      this.renderPipeId = "tilingSprite";
      this.batched = true;
      this._anchor = new ObservablePoint(
        {
          _onUpdate: () => {
            this._onAnchorUpdate();
          }
        }
      );
      const texture = options.texture || Texture.EMPTY;
      const orig = texture.orig;
      const width = options.width != null ? options.width : orig.width;
      const height = options.height != null ? options.height : orig.height;
      this._textureMatrix = new TextureMatrix();
      this.texture = texture;
      this._width = width;
      this._height = height;
      this._tileTransform = new Transform();
      if (options.tilePosition) this.tilePosition = options.tilePosition;
      if (options.tileScale) this.tileScale = options.tileScale;
      if (options.tileRotation) this.tileRotation = options.tileRotation;
      this.roundPixels = options.roundPixels != null ? options.roundPixels : false;
    }
    _onAnchorUpdate() {
      this._updateBounds();
    }
    /**
     * Changes frame clamping in corresponding textureMatrix
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get clampMargin() {
      return this._textureMatrix.clampMargin;
    }
    set clampMargin(value) {
      this._textureMatrix.clampMargin = value;
    }
    /**
     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the sprite's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * import { TilingSprite } from 'pixi.js';
     *
     * const sprite = new TilingSprite({texture: Texture.WHITE});
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /** The offset of the image that is being tiled. */
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(value) {
      this._tileTransform.position.copyFrom(value);
    }
    /** The scaling of the image that is being tiled. */
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(value) {
      typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
    }
    set tileRotation(value) {
      this._tileTransform.rotation = value;
    }
    /** The rotation of the image that is being tiled. */
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    /** The transform of the image that is being tiled. */
    get tileTransform() {
      return this._tileTransform;
    }
    /**
     * The local bounds of the sprite.
     * @type {rendering.Bounds}
     */
    get bounds() {
      return this._bounds;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value) return;
      this._texture = value;
      this._textureMatrix.texture = value;
    }
    /** The texture that the sprite is using. */
    get texture() {
      return this._texture;
    }
    /** The width of the tiling area. */
    set width(value) {
      this._width = value;
      this._updateBounds();
    }
    get width() {
      return this._width;
    }
    set height(value) {
      this._height = value;
      this._updateBounds();
    }
    /** The height of the tiling area. */
    get height() {
      return this._height;
    }
    /**
     * Sets the size of the TilingSprite to the specified width and height.
     * This is faster than setting the width and height separately.
     * @param value - This can be either a number or a [Size]{@link Size} object.
     * @param height - The height to set. Defaults to the value of `width` if not provided.
     */
    setSize(value, height) {
      this._width = value;
      this._height = height != null ? height : value;
      this._updateBounds();
    }
    _updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const width = this._width;
      const height = this._height;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      const _bounds = this._bounds;
      bounds.addFrame(
        _bounds.minX,
        _bounds.minY,
        _bounds.maxX,
        _bounds.maxY
      );
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const width = this._width;
      const height = this._height;
      const x1 = -width * this._anchor._x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width) {
        y1 = -height * this._anchor._y;
        if (point.y >= y1 && point.y <= y1 + height)
          return true;
      }
      return false;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options = false) {
      super.destroy(options);
      this._anchor = null;
      this._tileTransform = null;
      this._bounds = null;
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
    }
  };
  /** default options for the TilingSprite */
  TilingSprite.defaultOptions = {
    /** The texture to use for the sprite. */
    texture: Texture.EMPTY,
    /** The anchor point of the sprite */
    anchor: { x: 0, y: 0 },
    /** The offset of the image that is being tiled. */
    tilePosition: { x: 0, y: 0 },
    /** Scaling of the image that is being tiled. */
    tileScale: { x: 1, y: 1 },
    /** The rotation of the image that is being tiled. */
    tileRotation: 0,
    /** TODO */
    applyAnchorToTexture: false
  };

  "use strict";
  class GlBatchAdaptor {
    constructor() {
      this._tempState = State.for2d();
      this._didUploadHash = Object.create(null);
    }
    init(batcherPipe) {
      batcherPipe.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUploadHash = Object.create(null);
    }
    start(batchPipe, geometry, shader) {
      const renderer = batchPipe.renderer;
      const uid = shader.uid;
      const didUpload = this._didUploadHash[uid];
      const shaderSystem = renderer.shader;
      shaderSystem.bind(shader, didUpload);
      if (!didUpload) {
        this._didUploadHash[uid] = true;
      }
      shader.updateGlUniformGroup(shaderSystem, renderer);
      renderer.geometry.bind(geometry, shader.glProgram);
    }
    execute(batchPipe, batch) {
      const renderer = batchPipe.renderer;
      this._tempState.blendMode = batch.blendMode;
      renderer.state.set(this._tempState);
      const textureArray = batch.textures;
      const count = textureArray.count;
      const textures = textureArray.textures;
      const textureSystem = renderer.texture;
      for (let i = 0; i < count; i++) {
        textureSystem.bind(textures[i], i);
      }
      renderer.geometry.draw("triangle-list", batch.size, batch.start);
    }
  }
  /** @ignore */
  GlBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "batch"
  };

  "use strict";
  function generateGPULayout(maxTextures) {
    const gpuLayout = [];
    let bindIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      gpuLayout[bindIndex] = {
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
      gpuLayout[bindIndex] = {
        sampler: {
          type: "filtering"
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
    }
    return gpuLayout;
  }

  "use strict";
  function generateLayout(maxTextures) {
    const layout = {};
    let bindIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      layout[`textureSource${i + 1}`] = bindIndex++;
      layout[`textureSampler${i + 1}`] = bindIndex++;
    }
    return layout;
  }

  "use strict";
  const tempState = State.for2d();
  class GpuBatchAdaptor {
    start(batchPipe, geometry, shader) {
      const renderer = batchPipe.renderer;
      const encoder = renderer.encoder;
      const program = shader.gpuProgram;
      this._shader = shader;
      this._geometry = geometry;
      encoder.setGeometry(geometry, program);
      tempState.blendMode = "normal";
      renderer.pipeline.getPipeline(
        geometry,
        program,
        tempState
      );
      shader.updateGpuUniformGroup(encoder, renderer, program);
    }
    execute(batchPipe, batch) {
      const program = this._shader.gpuProgram;
      const renderer = batchPipe.renderer;
      const encoder = renderer.encoder;
      const renderPassEncoder = encoder.renderPassEncoder;
      tempState.blendMode = batch.blendMode;
      const bindGroup = batch.textures.bindGroup;
      const gpuBindGroup = renderer.bindGroup.getBindGroup(
        bindGroup,
        program,
        1
      );
      const pipeline = renderer.pipeline.getPipeline(
        this._geometry,
        program,
        tempState
      );
      encoder.setPipeline(pipeline);
      renderPassEncoder.setBindGroup(1, gpuBindGroup);
      renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
    }
  }
  /** @ignore */
  GpuBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "batch"
  };

  "use strict";
  class BatcherCache {
    static batcherClassConsturtorCache = Object.create(null);
    static registerBatcher(batcherName, batcherClass) {
      this.batcherClassConsturtorCache[batcherName] = batcherClass;
    }
    static createBatcher(batcherName) {
      const classConstructor = this.batcherClassConsturtorCache[batcherName];
      if (classConstructor === void 0) {
        const errorMessage = "can`t find batcher constructor in cache\n please use BatcherCache#registerBatcher register your batcher first"
        Logger.error(errorMessage);
        throw new TypeError("batcher name is valid");
      }
      return new classConstructor();
    }
    constructor() {
      this.batchers = [];
      this.batcherNames = Object.create(null);
      this.batcherCount = 0;
      this.batcherNames["default"] = this.batcherCount++;
      this.batchers[0] = new DefaultBatcher();
    }
    addToBatcher(batcherName) {
      let batcherIndex = this.batcherNames[batcherName];
      let batcher = this.batchers[batcherIndex];
      if (batcherIndex === void 0) {
        const index = this.batcherCount++;
        this.batcherNames[batcherName] = index;
        batcher = BatcherCache.createBatcher(batcherName);
        this.batchers[index] = batcher;
        batcher.begin();
      }
      return batcher;
    }
    begin() {
      const batchers = this.batchers;
      for (let i = 0; i < this.batcherCount; i++) {
        batchers[i].begin();
      }
    }
    end() {
      const batchers = this.batchers;
      for (let i = 0; i < this.batcherCount; i++) {
        const batcher = batchers[i];
        const geometry = batcher.geometry;
        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, false);
      }
    }
    upload() {
      const batchers = this.batchers;
      for (let i = 0; i < this.batcherCount; i++) {
        const batcher = batchers[i];
        if (!batcher.dirty) continue;
        batcher.dirty = false;
        const geometry = batcher.geometry;
        geometry.buffers[0].update(batcher.attributeSize * 4);
      }
    }
    getBatcherByName(batcherName) {
      const batcherIndex = this.batcherNames[batcherName];
      return this.batchers[batcherIndex];
    }
    destroy() {
      const batchers = this.batchers;
      for (let i = 0; i < this.batcherCount; i++) {
        batchers[i].destroy();
      }
      this.batchers.clear();
      this.batcherCount = 0;
      this.batcherNames = null;
    }
  }

  class BatcherPipe {
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
      /** A record of all active batchers, keyed by their names */
      this._activeBatches = /* @__PURE__ */ Object.create(null);
      var _a, _b;
      this.renderer = renderer;
      this._adaptor = adaptor;
      (_b = (_a = this._adaptor).init) == null ? void 0 : _b.call(_a, this);
    }
    buildStart(instructionSet) {
      const uid = instructionSet.uid;
      let batchers = this._batchersByInstructionSet[uid];
      if (!batchers) {
        batchers = this._batchersByInstructionSet[uid] = new BatcherCache();
      }
      this._activeBatches = batchers;
      this._activeBatch = batchers.getBatcherByName("default");
      batchers.begin();
    }
    addToBatch(batchableObject, instructionSet) {
      const batcherName = batchableObject.batcherName;
      const activeBatch = this._activeBatch;
      let batcher = activeBatch;
      if (activeBatch.name !== batcherName) {
        activeBatch.break(instructionSet);
        const activeBatches = this._activeBatches;
        batcher = activeBatches.addToBatcher(batcherName);
        this._activeBatch = batcher;
      }
      batcher.add(batchableObject);
    }
    break(instructionSet) {
      this._activeBatch.break(instructionSet);
    }
    buildEnd(instructionSet) {
      this._activeBatch.break(instructionSet);
      this._activeBatches.end();
    }
    upload(instructionSet) {
      this._batchersByInstructionSet[instructionSet.uid].upload();
    }
    execute(batch) {
      const adaptor = this._adaptor;
      if (batch.action === "startBatch") {
        const batcher = batch.batcher;
        const geometry = batcher.geometry;
        const shader = batcher.shader;
        adaptor.start(this, geometry, shader);
      }
      adaptor.execute(this, batch);
    }
    destroy() {
      this.state = null;
      this.renderer = null;
      this._adaptor = null;
      for (const i in this._activeBatches) {
        this._activeBatches[i].destroy();
      }
      this._activeBatches = null;
    }
  };
  /** @ignore */
  BatcherPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "batch"
  };

  "use strict";
  const shaderFormatRegex = /([\n{}])/g;
  function formatShader(shader) {
    let indent = "", indentLine = "";
    const lines = shader.split(shaderFormatRegex);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.length) {
        if (line === "{") {
          indent += "    ";
        } else if (line === "}") {
          indent = indent.substring(0, indent.length - 4);
        }
        indentLine = indent + line + "\n";
      }
    }
    return indentLine;
  }

  "use strict";
  const textureBit = {
    name: "texture-bit",
    vertex: {
      header: (
        /* wgsl */
        `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
      ),
      main: (
        /* wgsl */
        `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
      )
    },
    fragment: {
      header: (
        /* wgsl */
        `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
      ),
      main: (
        /* wgsl */
        `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
      )
    }
  };
  const textureBitGl = {
    name: "texture-bit",
    vertex: {
      header: (
        /* glsl */
        `
            uniform mat3 uTextureMatrix;
        `
      ),
      main: (
        /* glsl */
        `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
      )
    },
    fragment: {
      header: (
        /* glsl */
        `
        uniform sampler2D uTexture;

         
        `
      ),
      main: (
        /* glsl */
        `
            outColor = texture(uTexture, vUV);
        `
      )
    }
  };
  "use strict";
  const tempBounds$1 = new Bounds();
  class AlphaMaskEffect extends FilterEffect {
    constructor() {
      super();
      this.filters = [new MaskFilter({
        sprite: new Sprite(Texture.EMPTY),
        inverse: false,
        resolution: "inherit",
        antialias: "inherit"
      })];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(value) {
      this.filters[0].sprite = value;
    }
    get inverse() {
      return this.filters[0].inverse;
    }
    set inverse(value) {
      this.filters[0].inverse = value;
    }
  }
  const AlphaMaskEffectPool = createPool("AlphaMaskEffectPool", AlphaMaskEffect);
  class MaskStage {
    constructor() {
      this.reset();
    }
    reset() {
      this.filterEffect = null;
      this.maskedContainer = null;
      this.filterTexture = null;
    }
    mask(filterEffect, container, texture) {
      this.filterEffect = filterEffect;
      this.maskedContainer = container;
      this.filterTexture = texture;
    }
  }
  const MaskStagePool = createPool("MaskStagePool", MaskStage);
  class MaskOffset {
    constructor() {
      this.reset();
    }
    reset() {
      this.offset = null;
      this.worldColor = 4294967295;
    }
    set(offset) {
      this.offset = offset;
    }
  }
  class AlphaMaskSet {
    constructor() {
      this.reset();
    }
    reset() {
      this.renderPipeId = "alphaMask";
      this.action = "pushMaskEnd";
      this.mask = null;
      this.maskedContainer = null;
      this.inverse = false;
      this.canBundle = false;
    }
  }
  const AlphaMaskSetPool = createPool("AlphaMaskSetPool", AlphaMaskSet);
  class AlphaMaskPipe {
    constructor(renderer) {
      this._activeMaskStage = [];
      this._filterSet = FilterSetPool.get();
      this._renderer = renderer;
      this._offset = new MaskOffset();
    }
    push(mask, maskedContainer, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const set = AlphaMaskSetPool.get();
      set.mask = mask;
      set.inverse = maskedContainer._maskOptions.inverse;
      set.maskedContainer = maskedContainer;
      set.canBundle = false;
      set.action = "pushMaskBegin";
      instructionSet.add(set);
      mask.inverse = set, inverse;
      if (mask.renderMaskToTexture) {
        const maskContainer = mask.mask;
        maskContainer.includeInBuild = true;
        maskContainer.collectRenderables(
          instructionSet,
          renderer,
          null
        )
        maskContainer.includeInBuild = false;
      }
      renderer.renderPipes.batch.break(instructionSet);
      const maskEnd = AlphaMaskSetPool.get();
      maskEnd.mask = mask;
      maskEnd.maskedContainer = maskedContainer;
      maskEnd.inverse = maskedContainer._maskOptions.inverse;
      maskEnd.canBundle = false;
      maskEnd.action = "pushMaskEnd";
      instructionSet.add(maskEnd);
    }
    pop(mask, _maskedContainer, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const maskPop = AlphaMaskSetPool.get();
      maskPop.mask = mask;
      maskPop.inverse = _maskedContainer._maskOptions.inverse;
      maskPop.canBundle = false;
      maskPop.action = "popMaskEnd";
      instructionSet.add(maskPop);
    }
    execute(instruction) {
      const renderer = this._renderer;
      const renderMask = instruction.mask.renderMaskToTexture;
      const activeMaskStage = this._activeMaskStage;
      if (instruction.action === "pushMaskBegin") {
        const filterEffect = AlphaMaskEffectPool.get();
        filterEffect.inverse = instruction.inverse;
        if (renderMask) {
          instruction.mask.mask.measurable = true;
          const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds$1);
          instruction.mask.mask.measurable = false;
          bounds.ceil();
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTextures[0];
          const filterTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            colorTextureSource._resolution,
            colorTextureSource.antialias
          );
          renderer.renderTarget.push(filterTexture, true);
          const maskOffset = this._offset;
          maskOffset.bounds = bounds;
          maskOffset.worldColor = 4294967295;
          renderer.globalUniforms.push(maskOffset);
          const sprite = filterEffect.sprite;
          sprite.texture = filterTexture;
          sprite.checkWorldTransform();
          sprite.updateWorldTransform();
          const wt = sprite._worldTransform;
          wt.tx = bounds.minX;
          wt.ty = bounds.minY;
          const maskStage = MaskStagePool.get();
          maskStage.mask(filterEffect, instruction.maskedContainer, filterTexture);
          activeMaskStage[activeMaskStage.length] = maskStage;
        } else {
          filterEffect.sprite = instruction.mask.mask;
          const maskStage = MaskStagePool.get();
          maskStage.mask(filterEffect, instruction.maskedContainer, null);
          activeMaskStage[activeMaskStage.length] = maskStage;
        }
      } else if (instruction.action === "pushMaskEnd") {
        const maskData = activeMaskStage[this._activeMaskStage.length - 1];
        if (renderMask) {
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
          renderer.renderTarget.pop();
          renderer.globalUniforms.pop();
        }
        const filterSet = this._filterSet;
        filterSet.push(maskData.maskedContainer, maskData.filterEffect);
        renderer.filter.push(filterSet);
      } else if (instruction.action === "popMaskEnd") {
        renderer.filter.pop();
        const maskData = this._activeMaskStage.pop();
        if (renderMask) {
          TexturePool.returnTexture(maskData.filterTexture);
        }
        AlphaMaskEffectPool.return(maskData.filterEffect);
        MaskStagePool.return(maskData);
      }
    }
    destroy() {
      this._renderer = null;
      this._activeMaskStage = null;
    }
  }
  /** @ignore */
  AlphaMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "alphaMask"
  };

  "use strict";
  class ColorMaskSet {
    constructor() {
      this.reset();
    }
    reset() {
      this.renderPipeId = "colorMask",
        this.colorMask = 0;
      this.canBundle = false;
    }
    set(colorMask) {
      this.colorMask = colorMask;
    }
  }
  const ColorMaskSetPool = createPool("ColorMaskSetPool", ColorMaskSet);
  class ColorMaskPipe {
    constructor(renderer) {
      this._colorStack = [];
      this._colorStackIndex = 0;
      this._currentColor = 0;
      this._renderer = renderer;
    }
    buildStart() {
      this._colorStack[0] = 15;
      this._colorStackIndex = 1;
      this._currentColor = 15;
    }
    push(mask, _container, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const colorStack = this._colorStack;
      colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
      const currentColor = this._colorStack[this._colorStackIndex];
      if (currentColor !== this._currentColor) {
        this._currentColor = currentColor;
        const maskSet = ColorMaskSetPool.get();
        maskSet.set(currentColor);
        instructionSet.add(maskSet);
      }
      this._colorStackIndex++;
    }
    pop(_mask, _container, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const colorStack = this._colorStack;
      this._colorStackIndex--;
      const currentColor = colorStack[this._colorStackIndex - 1];
      if (currentColor !== this._currentColor) {
        this._currentColor = currentColor;
        const maskSet = ColorMaskSetPool.get();
        maskSet.set(currentColor);
        instructionSet.add(maskSet);
      }
    }
    execute(instruction) {
      const renderer = this._renderer;
      renderer.colorMask.setMask(instruction.colorMask);
    }
    destroy() {
      this._colorStack = null;
    }
  }
  /** @ignore */
  ColorMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "colorMask"
  };

  const filterSetHash = {
    "filter": FilterSetPool,
    "colorMask": ColorMaskSetPool,
    "alphaMask": AlphaMaskSetPool,
    __proto__: null
  }
  "use strict";
  class ScissorMask {
    constructor(mask) {
      this.priority = 0;
      this.pipe = "scissorMask";
      this.mask = mask;
      this.mask.renderable = false;
      this.mask.measurable = false;
    }
    addBounds(bounds, skipUpdateTransform) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    reset() {
      this.mask.measurable = true;
      this.mask = null;
    }
    destroy() {
      this.reset();
    }
  }

  "use strict";
  class StencilMaskPipe {
    constructor(renderer) {
      // used when building and also when executing..
      this._maskStackHash = {};
      this._maskHash = /* @__PURE__ */ new WeakMap();
      this._renderer = renderer;
    }
    push(mask, _container, instructionSet) {
      var _a, _b;
      const effect = mask;
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "pushMaskBegin",
        mask,
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const maskContainer = effect.mask;
      maskContainer.includeInBuild = true;
      if (!this._maskHash.has(effect)) {
        this._maskHash.set(effect, {
          instructionsStart: 0,
          instructionsLength: 0
        });
      }
      const maskData = this._maskHash.get(effect);
      maskData.instructionsStart = instructionSet.instructionSize;
      maskContainer.collectRenderables(
        instructionSet,
        renderer,
        null
      );
      maskContainer.includeInBuild = false;
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "pushMaskEnd",
        mask,
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
      maskData.instructionsLength = instructionsLength;
      const renderTargetUid = renderer.renderTarget.renderTarget.uid;
      (_b = (_a = this._maskStackHash)[renderTargetUid]) != null ? _b : _a[renderTargetUid] = 0;
    }
    pop(mask, _container, instructionSet) {
      const effect = mask;
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "popMaskBegin",
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const maskData = this._maskHash.get(mask);
      for (let i = 0; i < maskData.instructionsLength; i++) {
        instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
      }
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "popMaskEnd",
        canBundle: false
      });
    }
    execute(instruction) {
      var _a, _b;
      const renderer = this._renderer;
      const renderTargetUid = renderer.renderTarget.renderTarget.uid;
      let maskStackIndex = (_b = (_a = this._maskStackHash)[renderTargetUid]) != null ? _b : _a[renderTargetUid] = 0;
      if (instruction.action === "pushMaskBegin") {
        renderer.renderTarget.ensureDepthStencil();
        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
        maskStackIndex++;
        renderer.colorMask.setMask(0);
      } else if (instruction.action === "pushMaskEnd") {
        if (instruction.inverse) {
          renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
        } else {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
        }
        renderer.colorMask.setMask(15);
      } else if (instruction.action === "popMaskBegin") {
        renderer.colorMask.setMask(0);
        if (maskStackIndex !== 0) {
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
        } else {
          renderer.renderTarget.clear(null, CLEAR.STENCIL);
          renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
        }
        maskStackIndex--;
      } else if (instruction.action === "popMaskEnd") {
        if (instruction.inverse) {
          renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
        } else {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
        }
        renderer.colorMask.setMask(15);
      }
      this._maskStackHash[renderTargetUid] = maskStackIndex;
    }
    destroy() {
      this._renderer = null;
      this._maskStackHash = null;
      this._maskHash = null;
    }
  }
  StencilMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "stencilMask"
  };

  "use strict";
  var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
    BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    return BUFFER_TYPE2;
  })(BUFFER_TYPE || {});

  "use strict";
  class GlBuffer {
    constructor(buffer, type) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.type = type;
      this._lastBindBaseLocation = -1;
      this._lastBindCallId = -1;
    }
  }

  "use strict";
  class GlBufferSystem {
    /**
     * @param {Renderer} renderer - The renderer this System works for.
     */
    constructor(renderer) {
      /** Cache keeping track of the base bound buffer bases */
      this._boundBufferBases = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._minBaseLocation = 0;
      this._maxBindings = 0;
      this._nextBindBaseIndex = this._minBaseLocation;
      this._bindCallId = 0;
      //this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    resetState() {
      const cache = this._boundBufferBases;
      for (const key in cache) {
        cache[key] = null;
      }
    }
    /**
     * @ignore
     */
    destroy() {
      this._renderer = null;
      this._gl = null;
      this._boundBufferBases = null;
    }
    /** Sets up the renderer context and necessary buffers. */
    contextChange() {
      this._gl = this._renderer.gl;
      this._maxBindings = this._renderer.limits.maxUniformBindings;
    }
    getGlBuffer(buffer) {
      return buffer._gpuBuffer || this.createGLBuffer(buffer);
    }
    /**
     * This binds specified buffer. On first run, it will create the webGL buffers for the context too
     * @param buffer - the buffer to bind to the renderer
     */
    bind(buffer) {
      const gl = this._gl;
      const glBuffer = this.getGlBuffer(buffer);
      gl.bindBuffer(glBuffer.type, glBuffer.buffer);
    }
    /**
     * Binds an uniform buffer to at the given index.
     *
     * A cache is used so a buffer will not be bound again if already bound.
     * @param glBuffer - the glBuffer to bind 
     * @param index - the base index to bind it to.
     */
    bindBufferBase(glBuffer, index) {
      const gl = this._gl;
      if (this._boundBufferBases[index] !== glBuffer) {
        const glBuffer = this.getGlBuffer(buffer);
        this._boundBufferBases[index] = glBuffer;
        glBuffer._lastBindBaseLocation = index;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
      }
    }
    nextBindBase(hasTransformFeedback) {
      this._bindCallId++;
      this._minBaseLocation = 0;
      if (hasTransformFeedback) {
        this._boundBufferBases[0] = null;
        this._minBaseLocation = 1;
        if (this._nextBindBaseIndex < 1) {
          this._nextBindBaseIndex = 1;
        }
      }
    }
    freeLocationForBufferBase(glBuffer) {
      let freeIndex = this.getLastBindBaseLocation(glBuffer);
      // check if it is already bound..
      if (freeIndex >= this._minBaseLocation) {
        glBuffer._lastBindCallId = this._bindCallId;
        return freeIndex;
      }
      let loop = 0;
      let nextIndex = this._nextBindBaseIndex;
      while (loop < 2) {
        if (nextIndex >= this._maxBindings) {
          nextIndex = this._minBaseLocation;
          loop++;
        }
        const curBuf = this._boundBufferBases[nextIndex];
        if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
          nextIndex++;
          continue;
        }
        break;
      }
      freeIndex = nextIndex;
      this._nextBindBaseIndex = nextIndex + 1;
      if (loop >= 2) {
        // TODO: error
        return -1;
      }
      glBuffer._lastBindCallId = this._bindCallId;
      this._boundBufferBases[freeIndex] = null;
      return freeIndex;
    }
    getLastBindBaseLocation(glBuffer) {
      const index = glBuffer._lastBindBaseLocation;
      if (this._boundBufferBases[index] === glBuffer) {
        return index;
      }
      return -1;
    }
    /**
     * Binds a buffer whilst also binding its range.
     * This will make the buffer start from the offset supplied rather than 0 when it is read.
     * @param glBuffer - the buffer to bind
     * @param index - the base index to bind at, defaults to 0
     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
     * @@param size - the size to bind at (this is blocks of 256).
     */
    bindBufferRange(glBuffer, index, offset, size) {
      const gl = this._gl;
      offset = offset || 0;
      index = index || 0;
      this._boundBufferBases[index] = null;
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
    }
    /**
     * Will ensure the data in the buffer is uploaded to the GPU.
     * @param {Buffer} buffer - the buffer to update
     */
    updateBuffer(buffer) {
      const gl = this._gl;
      const glBuffer = this.getGlBuffer(buffer);
      if (buffer._updateID === glBuffer.updateID) {
        return glBuffer;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      const data = buffer._data;
      const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      if (data) {
        if (glBuffer.byteLength >= data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
        } else {
          glBuffer.byteLength = data.byteLength;
          gl.bufferData(glBuffer.type, data, drawType);
        }
      } else {
        glBuffer.byteLength = buffer.descriptor.size;
        gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
      }
      return glBuffer;
    }
    /** dispose all WebGL resources of all managed buffers */
    destroyAll() {
      //
    }
    /**
     * Disposes buffer
     * @param {Buffer} buffer - buffer with data
     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */
    onBufferDestroy(buffer, contextLost) {
      const glBuffer = buffer._gpuBuffer
      const gl = this._gl;
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      buffer._gpuBuffer = null;
    }
    /**
     * creates and attaches a GLBuffer object tied to the current context.
     * @param buffer
     * @protected
     */
    createGLBuffer(buffer) {
      const gl = this._gl;
      let type = BUFFER_TYPE.ARRAY_BUFFER;
      if (buffer.descriptor.usage & BufferUsage.INDEX) {
        type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
        type = BUFFER_TYPE.UNIFORM_BUFFER;
      }
      const glBuffer = new GlBuffer(gl.createBuffer(), type);
      buffer._gpuBuffer = glBuffer;
      buffer.on("destroy", this.onBufferDestroy, this);
      return glBuffer;
    }
  }
  /** @ignore */
  GlBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "buffer"
  };

  "use strict";
  var __defProp$n = Object.defineProperty;
  var __defProps$a = Object.defineProperties;
  var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
  var __hasOwnProp$n = Object.prototype.hasOwnProperty;
  var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$n = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    if (__getOwnPropSymbols$n)
      for (var prop of __getOwnPropSymbols$n(b)) {
        if (__propIsEnum$n.call(b, prop))
          __defNormalProp$n(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
  class GlContextSystem {
    /** @param renderer - The renderer this System works for. */
    constructor(renderer) {
      /**
       * Features supported by current renderer.
       * @type {object}
       * @readonly
       */
      this.supports = {
        /** Support for 32-bit indices buffer. */
        uint32Indices: true,
        /** Support for UniformBufferObjects */
        uniformBufferObject: true,
        /** Support for VertexArrayObjects */
        vertexArrayObject: true,
        /** Support for SRGB texture format */
        srgbTextures: true,
        /** Support for wrapping modes if a texture is non-power of two */
        nonPowOf2wrapping: true,
        /** Support for MSAA (antialiasing of dynamic textures) */
        msaa: true,
        /** Support for mipmaps if a texture is non-power of two */
        nonPowOf2mipmaps: true
      };
      this._renderer = renderer;
      this.extensions = /* @__PURE__ */ Object.create(null);
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    /**
     * `true` if the context is lost
     * @readonly
     */
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    /**
     * Handles the context change event.
     * @param {WebGLRenderingContext} gl - New WebGL context.
     */
    contextChange(gl) {
      this.gl = gl;
      this._renderer.gl = gl;
    }
    init(options) {
      var _a, _b;
      options = __spreadValues$n(__spreadValues$n({}, GlContextSystem.defaultOptions), options);
      this.canvas = this._renderer.view.canvas;
      const alpha = this._renderer.background.alpha < 1;
      const premultipliedAlpha = (_a = options.premultipliedAlpha) != null ? _a : true;
      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
      this.createContext(options.preferWebGLVersion, {
        alpha,
        premultipliedAlpha,
        antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: (_b = options.powerPreference) != null ? _b : "default"
      });
    }
    ensureCanvasSize(targetCanvas) {
      const canvas = this.canvas;
      if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
        canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
        canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
      }
    }
    /**
     * Initializes the context.
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initFromContext(gl) {
      this.gl = gl;
      this.getExtensions();
      this.validateContext(gl);
      this._renderer.runners.contextChange.emit(gl);
      const element = this._renderer.view.canvas;
      element.addEventListener("webglcontextlost", this.handleContextLost, false);
      element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    /**
     * Initialize from context options
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param preferWebGLVersion
     * @param {object} options - context attributes
     */
    createContext(preferWebGLVersion, options) {
      let gl;
      const canvas = this.canvas;
      if (preferWebGLVersion === 2) {
        gl = canvas.getContext("webgl2", options);
        this.webGLVersion = 2;
        glUploadImageResource.upload = webgl2Upload;
      }
      if (!gl) {
        gl = canvas.getContext("webgl", options);
        this.webGLVersion = 1;
        glUploadImageResource.upload = webgl1Upload;
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.initFromContext(this.gl);
    }
    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
    getExtensions() {
      const gl = this.gl;
      const common = {
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        // eslint-disable-line camelcase
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc"),
        bptc: gl.getExtension("EXT_texture_compression_bptc"),
        rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
        loseContext: gl.getExtension("WEBGL_lose_context")
      };
      if (this.webGLVersion === 1) {
        this.extensions = __spreadProps$a(__spreadValues$n({}, common), {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          // Floats and half-floats
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
          vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
          srgb: gl.getExtension("EXT_sRGB")
        });
      } else {
        this.extensions = __spreadProps$a(__spreadValues$n({}, common), {
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
        const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
        if (provokeExt) {
          provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
        }
      }
    }
    /**
     * Handles a lost webgl context
     * @param {WebGLContextEvent} event - The context lost event.
     */
    handleContextLost(event) {
      event.preventDefault();
      if (this._contextLossForced) {
        this._contextLossForced = false;
        setTimeout(() => {
          var _a;
          if (this.gl.isContextLost()) {
            (_a = this.extensions.loseContext) == null ? void 0 : _a.restoreContext();
          }
        }, 0);
      }
    }
    /** Handles a restored webgl context. */
    handleContextRestored() {
      this.getExtensions();
      this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      var _a;
      const element = this._renderer.view.canvas;
      this._renderer = null;
      element.removeEventListener("webglcontextlost", this.handleContextLost);
      element.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      (_a = this.extensions.loseContext) == null ? void 0 : _a.loseContext();
    }
    /**
     * this function can be called to force a webGL context loss
     * this will release all resources on the GPU.
     * Useful if you need to put Pixi to sleep, and save some GPU memory
     *
     * As soon as render is called - all resources will be created again.
     */
    forceContextLoss() {
      var _a;
      (_a = this.extensions.loseContext) == null ? void 0 : _a.loseContext();
      this._contextLossForced = true;
    }
    /**
     * Validate context.
     * @param {WebGLRenderingContext} gl - Render context.
     */
    validateContext(gl) {
      const attributes = gl.getContextAttributes();
      if (attributes && !attributes.stencil) {
        Logger.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      const supports = this.supports;
      const isWebGl2 = this.webGLVersion === 2;
      const extensions = this.extensions;
      supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;
      supports.uniformBufferObject = isWebGl2;
      supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;
      supports.srgbTextures = isWebGl2 || !!extensions.srgb;
      supports.nonPowOf2wrapping = isWebGl2;
      supports.nonPowOf2mipmaps = isWebGl2;
      supports.msaa = isWebGl2;
      if (!supports.uint32Indices) {
        Logger.warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
      }
    }
  };
  /** @ignore */
  GlContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "context"
  };
  /** The default options for the system. */
  GlContextSystem.defaultOptions = {
    /**
     * {@link WebGLOptions.context}
     * @default null
     */
    context: null,
    /**
     * {@link WebGLOptions.premultipliedAlpha}
     * @default true
     */
    premultipliedAlpha: true,
    /**
     * {@link WebGLOptions.preserveDrawingBuffer}
     * @default false
     */
    preserveDrawingBuffer: false,
    /**
     * {@link WebGLOptions.powerPreference}
     * @default default
     */
    powerPreference: void 0,
    /**
     * {@link WebGLOptions.webGLVersion}
     * @default 2
     */
    preferWebGLVersion: 2,
  };
  "use strict";
  function ensureAttributes(geometry, extractedData) {
    var _a, _b, _c;
    for (const i in geometry.attributes) {
      const attribute = geometry.attributes[i];
      const attributeData = extractedData[i];
      if (attributeData) {
        (_a = attribute.format) != null ? _a : attribute.format = attributeData.format;
        (_b = attribute.offset) != null ? _b : attribute.offset = attributeData.offset;
        (_c = attribute.instance) != null ? _c : attribute.instance = attributeData.instance;
      } else {
        Logger.warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    var _a, _b;
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j in buffers) {
      const buffer = buffers[j];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      (_a = attribute.stride) != null ? _a : attribute.stride = tempStride[attribute.buffer.uid];
      (_b = attribute.start) != null ? _b : attribute.start = tempStart[attribute.buffer.uid];
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }

  "use strict";
  var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
    GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
    GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
    GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
    GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
    GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return GL_FORMATS2;
  })(GL_FORMATS || {});
  var GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    return GL_TARGETS2;
  })(GL_TARGETS || {});
  var GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {
    GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
    GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
    GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    return GL_WRAP_MODES2;
  })(GL_WRAP_MODES || {});
  var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
    GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
    GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
    GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
    GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
    GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return GL_TYPES2;
  })(GL_TYPES || {});

  "use strict";
  const infoMap = {
    uint8x2: GL_TYPES.UNSIGNED_BYTE,
    uint8x4: GL_TYPES.UNSIGNED_BYTE,
    sint8x2: GL_TYPES.BYTE,
    sint8x4: GL_TYPES.BYTE,
    unorm8x2: GL_TYPES.UNSIGNED_BYTE,
    unorm8x4: GL_TYPES.UNSIGNED_BYTE,
    snorm8x2: GL_TYPES.BYTE,
    snorm8x4: GL_TYPES.BYTE,
    uint16x2: GL_TYPES.UNSIGNED_SHORT,
    uint16x4: GL_TYPES.UNSIGNED_SHORT,
    sint16x2: GL_TYPES.SHORT,
    sint16x4: GL_TYPES.SHORT,
    unorm16x2: GL_TYPES.UNSIGNED_SHORT,
    unorm16x4: GL_TYPES.UNSIGNED_SHORT,
    snorm16x2: GL_TYPES.SHORT,
    snorm16x4: GL_TYPES.SHORT,
    float16x2: GL_TYPES.HALF_FLOAT,
    float16x4: GL_TYPES.HALF_FLOAT,
    float32: GL_TYPES.FLOAT,
    float32x2: GL_TYPES.FLOAT,
    float32x3: GL_TYPES.FLOAT,
    float32x4: GL_TYPES.FLOAT,
    uint32: GL_TYPES.UNSIGNED_INT,
    uint32x2: GL_TYPES.UNSIGNED_INT,
    uint32x3: GL_TYPES.UNSIGNED_INT,
    uint32x4: GL_TYPES.UNSIGNED_INT,
    sint32: GL_TYPES.INT,
    sint32x2: GL_TYPES.INT,
    sint32x3: GL_TYPES.INT,
    sint32x4: GL_TYPES.INT
  };
  function getGlTypeFromFormat(format) {
    var _a;
    return (_a = infoMap[format]) != null ? _a : infoMap.float32;
  }

  "use strict";
  const topologyToGlMap = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
  };
  class GlGeometrySystem {
    /** @param renderer - The renderer this System works for. */
    constructor(renderer) {
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      //this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
    }
    /** Sets up the renderer context and necessary buffers. */
    contextChange() {
      const gl = this.gl = this._renderer.gl;
      if (!this._renderer.context.supports.vertexArrayObject) {
        throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
      }
      const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      }
      const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
      if (nativeInstancedExtension) {
        gl.drawArraysInstanced = (a, b, c, d) => {
          nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);
        };
        gl.drawElementsInstanced = (a, b, c, d, e) => {
          nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);
        };
        gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
      }
      this._activeGeometry = null;
      this._activeVao = null;
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    }
    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     * @param geometry - Instance of geometry to bind.
     * @param program - Instance of program to use vao for.
     */
    bind(geometry, program) {
      const gl = this.gl;
      this._activeGeometry = geometry;
      const vao = this.getVao(geometry, program);
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        gl.bindVertexArray(vao);
      }
      this.updateBuffers();
    }
    /** Reset and unbind any active VAO and geometry. */
    resetState() {
      this.unbind();
    }
    /** Update buffers of the currently bound geometry. */
    updateBuffers() {
      const geometry = this._activeGeometry;
      const bufferSystem = this._renderer.buffer;
      const buffers = geometry.buffers;
      for (let i = 0; i < buffers.length; i++) {
        bufferSystem.updateBuffer(buffers[i]);
      }
    }
    /**
     * Check compatibility between a geometry and a program
     * @param geometry - Geometry instance.
     * @param program - Program instance.
     */
    checkCompatibility(geometry, program) {
      const geometryAttributes = geometry.attributes;
      const shaderAttributes = program._attributeData;
      for (const j in shaderAttributes) {
        if (!geometryAttributes[j]) {
          throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
        }
      }
    }
    /**
     * Takes a geometry and program and generates a unique signature for them.
     * @param geometry - To get signature from.
     * @param program - To test geometry against.
     * @returns - Unique signature of the geometry and program
     */
    getSignature(geometry, program) {
      const attribs = geometry.attributes;
      const shaderAttributes = program._attributeData;
      const strings = ["g", geometry.uid];
      for (const i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i, shaderAttributes[i].location);
        }
      }
      return strings.join("-");
    }
    getVao(geometry, program) {
      const uid = geometry.uid;
      const key = program._key;
      const hash = this._geometryVaoHash;
      const vaoHash = hash[uid];
      if (vaoHash !== void 0) {
        return vaoHash[key] || this.initGeometryVao(geometry, program);
      }
      return this.initGeometryVao(geometry, program);
    }
    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
     * attribute locations.
     * @param geometry - Instance of geometry to to generate Vao for.
     * @param program
     * @param _incRefCount - Increment refCount of all geometry buffers.
     */
    initGeometryVao(geometry, program, _incRefCount = true) {
      const gl = this._renderer.gl;
      const bufferSystem = this._renderer.buffer;
      this._renderer.shader._getProgramData(program);
      this.checkCompatibility(geometry, program);
      const signature = this.getSignature(geometry, program);
      const uid = geometry.uid;
      let vaoObjectHash = this._geometryVaoHash[uid];
      if (vaoObjectHash === void 0) {
        vaoObjectHash = /* @__PURE__ */ Object.create(null);
        vaoObjectHash = this._geometryVaoHash[uid] = vaoObjectHash;
        geometry.on("destroy", this.onGeometryDestroy, this);
      }
      let vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program._key] = vao;
        return vao;
      }
      ensureAttributes(geometry, program._attributeData);
      const buffers = geometry.buffers;
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        bufferSystem.bind(buffer);
      }
      this.activateVao(geometry, program);
      vaoObjectHash[program._key] = vao;
      vaoObjectHash[signature] = vao;
      gl.bindVertexArray(null);
      return vao;
    }
    /**
     * Disposes geometry.
     * @param geometry - Geometry with buffers. Only VAO will be disposed
     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */
    onGeometryDestroy(geometry, contextLost) {
      const vaoObjectHash = this._geometryVaoHash[geometry.uid];
      const gl = this.gl;
      if (vaoObjectHash) {
        if (contextLost) {
          for (const i in vaoObjectHash) {
            if (this._activeVao !== vaoObjectHash[i]) {
              this.unbind();
            }
            gl.deleteVertexArray(vaoObjectHash[i]);
          }
        }
        this._geometryVaoHash[geometry.uid] = null;
      }
    }
    /**
     * Dispose all WebGL resources of all managed geometries.
     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
     */
    destroyAll(contextLost = false) {
      const gl = this.gl;
      const geometryVaoHash = this._geometryVaoHash;
      for (const i in geometryVaoHash) {
        if (contextLost) {
          for (const j in geometryVaoHash[i]) {
            const vaoObjectHash = geometryVaoHash[i];
            if (this._activeVao !== vaoObjectHash) {
              this.unbind();
            }
            gl.deleteVertexArray(vaoObjectHash[j]);
          }
        }
        geometryVaoHash[i] = null;
      }
    }
    /**
     * Activate vertex array object.
     * @param geometry - Geometry instance.
     * @param program - Shader program instance.
     */
    activateVao(geometry, program) {
      var _a, _b;
      const gl = this._renderer.gl;
      const bufferSystem = this._renderer.buffer;
      const attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      let lastBuffer = null;
      for (const j in attributes) {
        const attribute = attributes[j];
        const buffer = attribute.buffer;
        const glBuffer = bufferSystem.getGlBuffer(buffer);
        const programAttrib = program._attributeData[j];
        if (programAttrib) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          const location = programAttrib.location;
          gl.enableVertexAttribArray(location);
          const attributeInfo = getAttributeInfoFromFormat(attribute.format);
          const type = getGlTypeFromFormat(attribute.format);
          if (((_a = programAttrib.format) == null ? void 0 : _a.substring(1, 4)) === "int") {
            gl.vertexAttribIPointer(
              location,
              attributeInfo.size,
              type,
              attribute.stride,
              attribute.offset
            );
          } else {
            gl.vertexAttribPointer(
              location,
              attributeInfo.size,
              type,
              attributeInfo.normalised,
              attribute.stride,
              attribute.offset
            );
          }
          if (attribute.instance) {
            if (this.hasInstance) {
              const divisor = (_b = attribute.divisor) != null ? _b : 1;
              gl.vertexAttribDivisor(location, divisor);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    }
    /**
     * Draws the currently bound geometry.
     * @param topology - The type primitive to render.
     * @param size - The number of elements to be rendered. If not specified, all vertices after the
     *  starting vertex will be drawn.
     * @param start - The starting vertex in the geometry to start drawing from. If not specified,
     *  drawing will start from the first vertex.
     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
     *  all instances will be drawn.
     */
    draw(topology, size, start, instanceCount) {
      const gl = this._renderer.gl;
      const geometry = this._activeGeometry;
      const glTopology = topologyToGlMap[geometry.topology || topology];
      instanceCount || (instanceCount = geometry.instanceCount);
      if (geometry.indexBuffer) {
        const indexBuffer = geometry.indexBuffer;
        const byteSize = indexBuffer._data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (instanceCount > 1) {
          gl.drawElementsInstanced(glTopology, size || indexBuffer._data.length, glType, (start || 0) * byteSize, instanceCount);
        } else {
          gl.drawElements(glTopology, size || indexBuffer._data.length, glType, (start || 0) * byteSize);
        }
      } else if (instanceCount > 1) {
        gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
      } else {
        gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
      }
      return this;
    }
    /** Unbind/reset everything. */
    unbind() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    }
    destroy() {
      this._renderer = null;
      this.gl = null;
      this._activeVao = null;
      this._activeGeometry = null;
    }
  }
  /** @ignore */
  GlGeometrySystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "geometry"
  };

  "use strict";
  var __defProp$m = Object.defineProperty;
  var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
  var __hasOwnProp$m = Object.prototype.hasOwnProperty;
  var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$m = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    if (__getOwnPropSymbols$m)
      for (var prop of __getOwnPropSymbols$m(b)) {
        if (__propIsEnum$m.call(b, prop))
          __defNormalProp$m(a, prop, b[prop]);
      }
    return a;
  };
  const bigTriangleGeometry = new Geometry({
    attributes: {
      aPosition: [
        -1,
        -1,
        // Bottom left corner
        3,
        -1,
        // Bottom right corner, extending beyond right edge
        -1,
        3
        // Top left corner, extending beyond top edge
      ]
    }
  });
  const GL_BACK_BUFFER_DRAW_OPTIONS = {
    geometry: null,
    shader: null,
    state: null
  }
  class GlBackBufferSystem {
    constructor(renderer) {
      /** if true, the back buffer is used */
      this.useBackBuffer = false;
      this._useBackBufferThisRender = false;
      this._renderer = renderer;
    }
    init(options = {}) {
      const { useBackBuffer, antialias } = __spreadValues$m(__spreadValues$m({}, GlBackBufferSystem.defaultOptions), options);
      this.useBackBuffer = useBackBuffer;
      this._antialias = antialias;
      if (!this._renderer.context.supports.msaa) {
        Logger.warn("antialiasing, is not supported on when using the back buffer");
        this._antialias = false;
      }
      this._state = State.for2d();
      const bigTriangleProgram = new GlProgram({
        vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
        fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
        name: "big-triangle"
      });
      this._bigTriangleShader = new Shader({
        glProgram: bigTriangleProgram,
        resources: {
          uTexture: Texture.WHITE._source
        }
      });
    }
    /**
     * This is called before the RenderTargetSystem is started. This is where
     * we replace the target with the back buffer if required.
     * @param options - The options for this render.
     */
    renderStart(options) {
      const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
      this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
      if (this._useBackBufferThisRender) {
        const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
        this._targetTexture = renderTarget2.colorTextures[0];
        options.target = this._getBackBufferTexture(this._targetTexture);
      }
    }
    renderEnd() {
      this._presentBackBuffer();
    }
    _presentBackBuffer() {
      const renderer = this._renderer;
      renderer.renderTarget.finishRenderPass();
      if (!this._useBackBufferThisRender)
        return;
      renderer.renderTarget.bind(this._targetTexture, "load");
      this._bigTriangleShader.groups[99].setResource(this._backBufferTexture._source, 0);
      GL_BACK_BUFFER_DRAW_OPTIONS.geometry = bigTriangleGeometry;
      GL_BACK_BUFFER_DRAW_OPTIONS.shader = this._bigTriangleShader;
      GL_BACK_BUFFER_DRAW_OPTIONS.state = this._state;
      renderer.encoder.draw(GL_BACK_BUFFER_DRAW_OPTIONS);
    }
    _getBackBufferTexture(targetSourceTexture) {
      let backBufferTexture = this._backBufferTexture;
      if (backBufferTexture === void 0) {
        backBufferTexture = this._backBufferTexture || new Texture({
          source: (new TextureSource()).setupOptions({
            width: targetSourceTexture.width,
            height: targetSourceTexture.height,
            resolution: targetSourceTexture._resolution,
            antialias: this._antialias
          })
        });
      }
      const source = backBufferTexture._source;
      source.resize(
        targetSourceTexture.width,
        targetSourceTexture.height,
        targetSourceTexture._resolution
      );
      return backBufferTexture;
    }
    /** destroys the back buffer */
    destroy() {
      if (this._backBufferTexture) {
        this._backBufferTexture.destroy();
        this._backBufferTexture = null;
      }
    }
  };
  /** @ignore */
  GlBackBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "backBuffer",
    priority: 1
  };
  /** default options for the back buffer system */
  GlBackBufferSystem.defaultOptions = {
    /** if true will use the back buffer where required */
    useBackBuffer: false
  };

  "use strict";
  class GlColorMaskSystem {
    constructor(renderer) {
      this._colorMaskCache = 15;
      this._renderer = renderer;
    }
    setMask(colorMask) {
      if (this._colorMaskCache === colorMask)
        return;
      this._colorMaskCache = colorMask;
      this._renderer.gl.colorMask(
        !!(colorMask & 8),
        !!(colorMask & 4),
        !!(colorMask & 2),
        !!(colorMask & 1)
      );
    }
  }
  /** @ignore */
  GlColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "colorMask"
  };

  "use strict";
  class GlEncoderSystem {
    constructor(renderer) {
      this._renderer = renderer;
    }
    onRenderStart() {
    }
    setGeometry(geometry, shader) {
      this._renderer.geometry.bind(geometry, shader.glProgram);
    }
    finishRenderPass() {
    }
    draw(options) {
      const renderer = this._renderer;
      const geometry = options.geometry;
      const shader = options.shader;
      const state = options.state;
      const skipSync = options.skipSync;
      const type = options.topology;
      const size = options.size;
      const start = options.start;
      const instanceCount = options.instanceCount;
      const shaderSystem = renderer.shader;
      const geometrySystem = renderer.geometry;
      shaderSystem.bind(shader, skipSync);
      geometrySystem.bind(geometry, shaderSystem._activeProgram);
      if (state) {
        renderer.state.set(state);
      }
      geometrySystem.draw(type, size, start, instanceCount != null ? instanceCount : geometry.instanceCount);
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  GlEncoderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "encoder"
  };

  "use strict";
  class GlRenderTarget {
    constructor() {
      this.width = -1;
      this.height = -1;
      this.msaa = false;
      this.msaaRenderBuffer = [];
    }
  }

  "use strict";
  const GpuStencilModesToPixi = [];
  GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
  GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
    stencilFront: {
      compare: "equal",
      passOp: "increment-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "increment-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
    stencilFront: {
      compare: "equal",
      passOp: "decrement-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "decrement-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "equal",
      passOp: "keep"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "not-equal",
      passOp: "replace"
    },
    stencilBack: {
      compare: "not-equal",
      passOp: "replace"
    }
  };

  "use strict";
  class GlStencilSystem {
    constructor(renderer) {
      this._stencilCache = {
        enabled: false,
        stencilReference: 0,
        stencilMode: STENCIL_MODES.NONE
      };
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(gl) {
      this._gl = gl;
      this._comparisonFuncMapping = {
        always: gl.ALWAYS,
        never: gl.NEVER,
        equal: gl.EQUAL,
        "not-equal": gl.NOTEQUAL,
        less: gl.LESS,
        "less-equal": gl.LEQUAL,
        greater: gl.GREATER,
        "greater-equal": gl.GEQUAL
      };
      this._stencilOpsMapping = {
        keep: gl.KEEP,
        zero: gl.ZERO,
        replace: gl.REPLACE,
        invert: gl.INVERT,
        "increment-clamp": gl.INCR,
        "decrement-clamp": gl.DECR,
        "increment-wrap": gl.INCR_WRAP,
        "decrement-wrap": gl.DECR_WRAP
      };
      this.resetState();
    }
    resetState() {
      const stencilCache = this._stencilCache;
      stencilCache.enabled = false;
      stencilCache.stencilMode = STENCIL_MODES.NONE;
      stencilCache.stencilReference = 0;
    }
    onRenderTargetChange(renderTarget) {
      if (this._activeRenderTarget === renderTarget)
        return;
      this._activeRenderTarget = renderTarget;
      const uid = renderTarget.uid;
      const renderTargetStencilState = this._renderTargetStencilState;
      let stencilState = renderTargetStencilState[uid];
      if (!stencilState) {
        stencilState = renderTargetStencilState[uid] = {
          stencilMode: STENCIL_MODES.DISABLED,
          stencilReference: 0
        };
      }
      this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
    }
    setStencilMode(stencilMode, stencilReference) {
      const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
      const gl = this._gl;
      const mode = GpuStencilModesToPixi[stencilMode];
      const _stencilCache = this._stencilCache;
      stencilState.stencilMode = stencilMode;
      stencilState.stencilReference = stencilReference;
      if (stencilMode === STENCIL_MODES.DISABLED) {
        if (this._stencilCache.enabled) {
          this._stencilCache.enabled = false;
          gl.disable(gl.STENCIL_TEST);
        }
        return;
      }
      if (!this._stencilCache.enabled) {
        this._stencilCache.enabled = true;
        gl.enable(gl.STENCIL_TEST);
      }
      if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
        _stencilCache.stencilMode = stencilMode;
        _stencilCache.stencilReference = stencilReference;
        gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
      }
    }
  }
  /** @ignore */
  GlStencilSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "stencil"
  };

  "use strict";
  class UboSystem {
    constructor(adaptor) {
      /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */
      this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
      this._adaptor = adaptor;
    }
    ensureUniformGroup(uniformGroup) {
      const uniformData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
        data: new Float32Array(uniformData.layout.size / 4),
        usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
      }));
    }
    getUniformGroupData(uniformGroup) {
      return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
    }
    _initUniformGroup(uniformGroup) {
      const uniformGroupSignature = uniformGroup._signature;
      let uniformData = this._syncFunctionHash[uniformGroupSignature];
      if (!uniformData) {
        const elements = [];
        let index = 0;
        const uniformStructures = uniformGroup.uniformStructures;
        for (const key in uniformStructures) {
          elements[index++] = uniformStructures[key];
        }
        const layout = this._adaptor.createUboElements(elements);
        const syncFunction = this._generateUboSync(layout.uboElements);
        uniformData = this._syncFunctionHash[uniformGroupSignature] = {
          layout,
          syncFunction
        };
      }
      return this._syncFunctionHash[uniformGroupSignature];
    }
    _generateUboSync(uboElements) {
      return this._adaptor.generateUboSync(uboElements);
    }
    syncUniformGroup(uniformGroup, data, offset) {
      const uniformGroupData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
        data: new Float32Array(uniformGroupData.layout.size / 4),
        usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
      }));
      const buffer = uniformGroup.buffer;
      let dataInt32 = null;
      if (!data) {
        data = buffer._data;
        dataInt32 = buffer.dataInt32;
      }
      offset || (offset = 0);
      uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
      return true;
    }
    updateUniformGroup(uniformGroup) {
      if (uniformGroup.isStatic && !uniformGroup._dirtyId)
        return false;
      uniformGroup._dirtyId = 0;
      const synced = this.syncUniformGroup(uniformGroup);
      uniformGroup.buffer.update();
      return synced;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  }

  "use strict";
  const WGSL_TO_STD40_SIZE = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    'vec2<i32>': 8,
    'vec3<i32>': 12,
    'vec4<i32>': 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
    // TODO - not essential for now but support these in the future
    // int:      4,
    // ivec2:    8,
    // ivec3:    12,
    // ivec4:    16,
    // uint:     4,
    // uvec2:    8,
    // uvec3:    12,
    // uvec4:    16,
    // bool:     4,
    // bvec2:    8,
    // bvec3:    12,
    // bvec4:    16,
    // mat2:     16 * 2,
    // mat3:     16 * 3,
    // mat4:     16 * 4,
  };
  function createUboElementsSTD40(uniformData) {
    const uboElements = [];
    for (let i = 0; i < uniformData.length; i++) {
      const data = uniformData[i];
      uboElements[i] = {
        data,
        offset: 0,
        size: 0
      };
    }
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      const data = uboElement.data;
      const type = data.type;
      size = WGSL_TO_STD40_SIZE[type];
      if (!size) {
        throw new Error(`Unknown type ${type}`);
      }
      if (data.size > 1) {
        size = Math.max(size, chunkSize) * data.size;
      }
      const boundary = size === 12 ? 16 : size;
      uboElement.size = size;
      const curOffset = offset % chunkSize;
      if (curOffset > 0 && chunkSize - curOffset < boundary) {
        offset += (chunkSize - curOffset) % 16;
      } else {
        offset += (size - (curOffset % size)) % size;
      }
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }

  "use strict";
  const uniformParsers = [
    // uploading pixi matrix object to mat3
    {
      type: "mat3x3<f32>",
      test: (data) => {
        const value = data.value;
        return value.a !== void 0;
      },
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    },
    // uploading a pixi rectangle as a vec4
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    },
    // uploading a pixi point as a vec2
    {
      type: "vec2<f32>",
      test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    },
    // uploading a pixi color as a vec4
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    },
    // uploading a pixi color as a vec3
    {
      type: "vec3<f32>",
      test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }
  ];

  "use strict";
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j = 0; j < uniformParsers.length; j++) {
        const uniformParser = uniformParsers[j];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name}";`,
            `offset += ${offset - prev};`,
            uniformParser[parserCode] || uniformParser.ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            /* wgsl */
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      'dataInt32',
      "offset",
      fragmentSrc
    );
  }

  "use strict";
  var __defProp$l = Object.defineProperty;
  var __defProps$9 = Object.defineProperties;
  var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
  var __hasOwnProp$l = Object.prototype.hasOwnProperty;
  var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$l = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    if (__getOwnPropSymbols$l)
      for (var prop of __getOwnPropSymbols$l(b)) {
        if (__propIsEnum$l.call(b, prop))
          __defNormalProp$l(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  const uboSyncFunctionsSTD40 = {
    f32: `
        data[offset] = v;`,
    i32: `
        dataInt32[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    'vec2<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
    'vec3<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
    'vec4<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": loopMatrix(3, 2),
    "mat4x2<f32>": loopMatrix(4, 2),
    "mat2x3<f32>": loopMatrix(2, 3),
    "mat4x3<f32>": loopMatrix(4, 3),
    "mat2x4<f32>": loopMatrix(2, 4),
    "mat3x4<f32>": loopMatrix(3, 4)
  };
  const uboSyncFunctionsWGSL = __spreadProps$9(__spreadValues$l({}, uboSyncFunctionsSTD40), {
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
  });

  "use strict";
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const uboData = uboElement.data;
    const dataSize = uboData.size;
    const type = uboData.type;
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[type] / 16, 1);
    const elementSize = uboData.value.length / dataSize;
    const remainder = (4 - elementSize % 4) % 4;
    const data = type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';
    return `
        v = uv.${uboData.name};
        offset += ${offsetToAdd};
        arrayOffset = offset;
        t = 0;
        for(var i=0; i < ${dataSize * rowSize}; i++){
            for(var j = 0; j < ${elementSize}; j++){
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }

  "use strict";
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }

  "use strict";
  class GlUboSystem extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsSTD40,
        generateUboSync: createUboSyncFunctionSTD40
      });
    }
  }
  /** @ignore */
  GlUboSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "ubo"
  };

  function initGlRenderTarget(glRenderTarget, colorTextures, i, renderer, textureSystem, gl) {
    const source = colorTextures[i];
    if (source.antialias) {
      if (renderer.context.supports.msaa) {
        glRenderTarget.msaa = true;
      } else {
        Logger.warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
      }
    }
    textureSystem.bindSource(source, 0);
    const glSource = textureSystem.getGlSource(source);
    const glTexture = glSource.texture;
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0 + i,
      3553,
      // texture.target,
      glTexture,
      0
    );
  }

  function initGlMsaaRenderTarget(glRenderTarget, i, gl) {
    const msaaRenderBuffer = gl.createRenderbuffer();
    glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;
  }

  function bindGlMsaaRenderTarget(glRenderTarget, colorTextures, i, textureSystem, gl) {
    const source2 = colorTextures[i];
    textureSystem.bindSource(source2);
    const glSource = textureSystem.getGlSource(source2);
    const glInternalFormat = glSource.internalFormat;
    const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];
    gl.bindRenderbuffer(
      gl.RENDERBUFFER,
      msaaRenderBuffer
    );
    gl.renderbufferStorageMultisample(
      gl.RENDERBUFFER,
      4,
      glInternalFormat,
      source2.pixelWidth,
      source2.pixelHeight
    );
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0 + i,
      gl.RENDERBUFFER,
      msaaRenderBuffer
    );
  }

  "use strict";
  class GlRenderTargetAdaptor {
    constructor() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle();
    }
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
      renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle();
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderTargetSystem = this._renderTargetSystem;
      const renderer = this._renderer;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
      const gl = renderer.gl;
      this.finishRenderPass(sourceRenderSurfaceTexture);
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
      renderer.texture.bind(destinationTexture, 0);
      gl.copyTexSubImage2D(
        gl.TEXTURE_2D,
        0,
        originDest.x,
        originDest.y,
        originSrc.x,
        originSrc.y,
        size.width,
        size.height
      );
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = "clear", clearColor, viewport) {
      const renderTargetSystem = this._renderTargetSystem;
      const source = renderTarget.colorTextures[0];
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      let viewPortY = viewport.y;
      if (renderTarget.isRoot) {
        viewPortY = source.pixelHeight - viewport.height;
      }
      const textureSystem = this._renderer.texture;
      const colorTextures = renderTarget.colorTextures;
      for (let i = 0; i < colorTextures.length; i++) {
        textureSystem.unbind(colorTextures[i]);
      }
      const gl = this._renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
      const viewPortCache = this._viewPortCache;
      if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
        viewPortCache.x = viewport.x;
        viewPortCache.y = viewPortY;
        viewPortCache.width = viewport.width;
        viewPortCache.height = viewport.height;
        gl.viewport(
          viewport.x,
          viewPortY,
          viewport.width,
          viewport.height
        );
      }
      if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
        this._initStencil(gpuRenderTarget);
      }
      this.clear(renderTarget, clear, clearColor);
    }
    finishRenderPass(renderTarget) {
      const renderTargetSystem = this._renderTargetSystem;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (!glRenderTarget.msaa) return;
      const gl = this._renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
      gl.blitFramebuffer(
        0,
        0,
        glRenderTarget.width,
        glRenderTarget.height,
        0,
        0,
        glRenderTarget.width,
        glRenderTarget.height,
        gl.COLOR_BUFFER_BIT,
        gl.NEAREST
      );
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
    }
    initGpuRenderTarget(renderTarget) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const glRenderTarget = new GlRenderTarget();
      const colorTexture = renderTarget.colorTextures[0];
      if (colorTexture.resource === renderer.canvas) {
        renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
        glRenderTarget.framebuffer = null;
        return glRenderTarget;
      }
      this._initColor(renderTarget, glRenderTarget);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return glRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      const gl = this._renderer.gl;
      if (gpuRenderTarget.framebuffer) {
        gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
        gpuRenderTarget.framebuffer = null;
      }
      if (gpuRenderTarget.resolveTargetFramebuffer) {
        gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
        gpuRenderTarget.resolveTargetFramebuffer = null;
      }
      if (gpuRenderTarget.depthStencilRenderBuffer) {
        gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
        gpuRenderTarget.depthStencilRenderBuffer = null;
      }
      const buffers = gpuRenderTarget.msaaRenderBuffer;
      for (let i = 0; i < buffers.length; i++) {
        gl.deleteRenderbuffer(buffers[i]);
      }
      buffers.length = 0;
      gpuRenderTarget.msaaRenderBuffer = null;
    }
    clear(_renderTarget, clear, clearColor) {
      if (clear === "load") return;
      const renderTargetSystem = this._renderTargetSystem;
      clear = clear === "clear" ? CLEAR.ALL : CLEAR.NONE;
      const gl = this._renderer.gl;
      if (clear & CLEAR.COLOR) {
        clearColor != null ? clearColor : clearColor = renderTargetSystem.defaultClearColor;
        const clearColorCache = this._clearColorCache;
        const clearColorArray = clearColor;
        if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
          clearColorCache[0] = clearColorArray[0];
          clearColorCache[1] = clearColorArray[1];
          clearColorCache[2] = clearColorArray[2];
          clearColorCache[3] = clearColorArray[3];
          gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
        }
      }
      gl.clear(clear);
    }
    resizeGpuRenderTarget(renderTarget) {
      if (renderTarget.isRoot)
        return;
      const renderTargetSystem = this._renderTargetSystem;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      this._resizeColor(renderTarget, glRenderTarget);
      if (renderTarget.stencil || renderTarget.depth) {
        this._resizeStencil(glRenderTarget);
      }
    }
    _initColor(renderTarget, glRenderTarget) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const resolveTargetFramebuffer = gl.createFramebuffer();
      glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
      const colorTexture = renderTarget.colorTextures[0];
      glRenderTarget.width = colorTexture.pixelWidth;
      glRenderTarget.height = colorTexture.pixelHeight;
      const colorTextures = renderTarget.colorTextures;
      const textureSystem = renderer.texture;
      const isSingle = renderTarget.isSingle;
      if (isSingle) {
        initGlRenderTarget(glRenderTarget, colorTextures, 0, renderer, textureSystem, gl);
      } else {
        for (let i = 0; i < colorTextures.length; i++) {
          initGlRenderTarget(glRenderTarget, colorTextures, i, renderer, textureSystem, gl);
        }
      }
      if (glRenderTarget.msaa) {
        const viewFramebuffer = gl.createFramebuffer();
        glRenderTarget.framebuffer = viewFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
        if (isSingle) {
          initGlMsaaRenderTarget(glRenderTarget, 0, gl);
        } else {
          for (let i = 0; i < colorTextures.length; i++) {
            initGlMsaaRenderTarget(glRenderTarget, i, gl);
          }
        }
      } else {
        glRenderTarget.framebuffer = resolveTargetFramebuffer;
      }
      this._resizeColor(renderTarget, glRenderTarget);
    }
    _resizeColor(renderTarget, glRenderTarget) {
      const source = renderTarget.colorTextures[0];
      glRenderTarget.width = source.pixelWidth;
      glRenderTarget.height = source.pixelHeight;
      const colorTextures = renderTarget.colorTextures;
      const sourceWidth = source.width;
      const sourceHeight = source.height;
      if (!renderTarget.isSingle) {
        for (let i = 1; i < colorTextures.length; i++) {
          colorTextures[i].resize(sourceWidth, sourceHeight);
        }
      }
      if (glRenderTarget.msaa) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const viewFramebuffer = glRenderTarget.framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
        const textureSystem = renderer.texture;
        const isSingle = renderTarget.isSingle;
        if (isSingle) {
          bindGlMsaaRenderTarget(glRenderTarget, colorTextures, 0, textureSystem, gl);
        } else {
          for (let i = 0; i < colorTextures.length; i++) {
            bindGlMsaaRenderTarget(glRenderTarget, colorTextures, i, textureSystem, gl);
          }
        }
      }
    }
    _initStencil(glRenderTarget) {
      if (glRenderTarget.framebuffer === null)
        return;
      const gl = this._renderer.gl;
      const depthStencilRenderBuffer = gl.createRenderbuffer();
      glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
      gl.bindRenderbuffer(
        gl.RENDERBUFFER,
        depthStencilRenderBuffer
      );
      gl.framebufferRenderbuffer(
        gl.FRAMEBUFFER,
        gl.DEPTH_STENCIL_ATTACHMENT,
        gl.RENDERBUFFER,
        depthStencilRenderBuffer
      );
      this._resizeStencil(glRenderTarget);
    }
    _resizeStencil(glRenderTarget) {
      const gl = this._renderer.gl;
      gl.bindRenderbuffer(
        gl.RENDERBUFFER,
        glRenderTarget.depthStencilRenderBuffer
      );
      if (glRenderTarget.msaa) {
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          4,
          gl.DEPTH24_STENCIL8,
          glRenderTarget.width,
          glRenderTarget.height
        );
      } else {
        gl.renderbufferStorage(
          gl.RENDERBUFFER,
          this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          glRenderTarget.width,
          glRenderTarget.height
        );
      }
    }
  }

  "use strict";
  function calculateProjection(pm, x, y, width, height, flipY) {
    const sign = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign * (1 / height * 2);
    pm.tx = -1 - x * pm.a;
    pm.ty = -sign - y * pm.d;
    return pm;
  }

  "use strict";
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTextures[0].resource;
    return resource.isCanvas && document.body.contains(resource);
  }

  "use strict";
  var __defProp$j = Object.defineProperty;
  var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
  var __hasOwnProp$j = Object.prototype.hasOwnProperty;
  var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$j = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    if (__getOwnPropSymbols$j)
      for (var prop of __getOwnPropSymbols$j(b)) {
        if (__propIsEnum$j.call(b, prop))
          __defNormalProp$j(a, prop, b[prop]);
      }
    return a;
  };
  class RenderTarget {
    /**
     * @param [descriptor] - Options for creating a render target.
     */
    constructor(descriptor = {}) {
      /** unique id for this render target */
      this.uid = uid$1("renderTarget");
      /**
       * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could
       * write to multiple if required! (eg deferred lighting)
       */
      const selfColorTextures = this.colorTextures = [];
      this.dirtyId = 0;
      this.isRoot = false;
      this.isSingle = false;
      this.isRenderTarget = true;
      this._size = new Float32Array(2);
      /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */
      this._managedColorTextures = false;
      descriptor = __spreadValues$j(__spreadValues$j({}, RenderTarget.defaultOptions), descriptor);
      this.stencil = descriptor.stencil;
      this.depth = descriptor.depth;
      this.isRoot = descriptor.isRoot;
      if (typeof descriptor.colorTextures === "number") {
        this._managedColorTextures = true;
        for (let i = 0; i < descriptor.colorTextures; i++) {
          const textureSource = selfColorTextures[i] = new TextureSource();
          textureSource.setupOptions({
            width: descriptor.width,
            height: descriptor.height,
            resolution: descriptor.resolution,
            antialias: descriptor.antialias
          });
        }
      } else {
        const colorTextures = descriptor.colorTextures;
        for (let i = 0; i < colorTextures.length; i++) {
          selfColorTextures[i] = colorTextures[i];
        }
        const colorSource = this.colorTextures[0];
        this.resize(colorSource.width, colorSource.height, colorSource._resolution);
      }
      this.colorTexture.on("resize", this.onSourceResize, this);
      if (descriptor.depthStencilTexture || this.stencil) {
        if (descriptor.depthStencilTexture.isTexture || descriptor.depthStencilTexture.isTextureSource) {
          this.depthStencilTexture = descriptor.depthStencilTexture//.source;
        } else {
          this.ensureDepthStencilTexture();
        }
      }
      this.isSingle = selfColorTextures.length === 1;
      this.frame = null;
      this.gpuRenderTarget = null;
    }
    destroyGpuRenderTarget() {
      if (this.gpuRenderTarget !== null) {
        Engine.renderer.renderTarget.adaptor.destroyGpuRenderTarget(this.gpuRenderTarget);
        this.gpuRenderTarget = null;
      }
    }
    initGpuRenderTarget(adaptor) {
      let renderTarget = this.gpuRenderTarget;
      if (renderTarget === null) {
        renderTarget = this.gpuRenderTarget = adaptor.initGpuRenderTarget(this);
      }
      return renderTarget;
    }
    get size() {
      const size = this._size;
      const colorTexture = this.colorTextures[0];
      size[0] = colorTexture.width;
      size[1] = colorTexture.height;
      return size;
    }
    get width() {
      return this.colorTextures[0].width;
    }
    get height() {
      return this.colorTextures[0].height;
    }
    get pixelWidth() {
      return this.colorTextures[0].pixelWidth;
    }
    get pixelHeight() {
      return this.colorTextures[0].pixelHeight;
    }
    get resolution() {
      return this.colorTextures[0]._resolution;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    onSourceResize(source) {
      if (this.isSingle) return;
      this.resize(source.width, source.height, source._resolution, true);
    }
    /**
     * This will ensure a depthStencil texture is created for this render target.
     * Most likely called by the mask system to make sure we have stencil buffer added.
     * @internal
     * @ignore
     */
    ensureDepthStencilTexture() {
      if (!this.depthStencilTexture) {
        this.depthStencilTexture = TextureSourcePool.get()
          .setupOptions({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: false,
            antialias: false,
            mipLevelCount: 1
          })
      }
    }
    resize(width, height, resolution = this.resolution) {
      this.dirtyId++;
      const colorTextures = this.colorTextures;
      const size = colorTextures.length;
      if (size === 1) return;
      for (let i = 1; i < size; i++) {
        colorTextures[i].resize(width, height, resolution);
      }
      if (this.depthStencilTexture) {
        this.depthStencilTexture.resize(width, height, resolution);
      }
    }
    destroy() {
      this.colorTextures[0].off("resize", this.onSourceResize, this);
      if (this._managedColorTextures) {
        const colorTextures = this.colorTextures;
        const colorTexturesSize = colorTextures.length;
        for (let i = 0; i < colorTexturesSize; i++) {
          colorTextures[i].destroy();
        }
      }
      if (this.depthStencilTexture) {
        this.depthStencilTexture.destroy();
        this.depthStencilTexture = null;
        delete this.depthStencilTexture;
      }
    }
  };
  /** The default options for a render target */
  RenderTarget.defaultOptions = {
    /** the width of the RenderTarget */
    width: 0,
    /** the height of the RenderTarget */
    height: 0,
    /** the resolution of the RenderTarget */
    resolution: 1,
    /** an array of textures, or a number indicating how many color textures there should be */
    colorTextures: 1,
    /** should this render target have a stencil buffer? */
    stencil: false,
    /** should this render target have a depth buffer? */
    depth: false,
    /** should this render target be antialiased? */
    antialias: false,
    // save on perf by default!
    /** is this a root element, true if this is gl context owners render target */
    isRoot: false
  };

  class RenderTargetStack {
    constructor() {
      this.index = 0;
      this.stack = [];
    }
    push(renderTarget, frame) {
      renderTarget.frame = frame;
      this.stack[this.index++] = renderTarget;
      return renderTarget;
    }
    pop() {
      return this.stack[--this.index];
    }
    reset() {
      this.index = 0;
    }
  }

  class RenderTargetSystem {
    constructor(renderer) {
      /** This is the root viewport for the render pass*/
      this.rootViewPort = new Rectangle();
      /** the current viewport that the gpu is using */
      this.viewport = new Rectangle();
      /**
       * a runner that lets systems know if the active render target has changed.
       * Eg the Stencil System needs to know so it can manage the stencil buffer
       */
      this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
      /** the projection matrix that is used by the shaders based on the active render target and the viewport */
      this.projectionMatrix = new Matrix();
      /** the default clear color for render targets */
      this.defaultClearColor = [0, 0, 0, 0];
      /**
       * A stack that stores the render target and frame that is currently being rendered to.
       * When push is called, the current render target is stored in this stack.
       * When pop is called, the previous render target is restored.
       */
      this._renderTargetStack = new RenderTargetStack();
      this._renderer = renderer;
    }
    /** called when dev wants to finish a render pass */
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    resetState() {
      this.renderTarget = null;
      this.renderSurface = null;
    }
    /**
     * called when the renderer starts to render a scene.
     * @param options
     * @param options.target - the render target to render to
     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
     * @param options.clearColor - the color to clear to
     * @param options.frame - the frame to render to
     */
    renderStart({
      target,
      clear,
      clearColor,
      frame
    }) {
      this._renderTargetStack.reset();
      this.push(target, clear, clearColor, frame);
      this.rootViewPort.copyFrom(this.viewport);
      this.rootRenderTarget = this.renderTarget;
      this.renderingToScreen = this.rootRenderTarget === this._renderer.view.renderTarget;
    }
    /**
     * Binding a render surface! This is the main function of the render target system.
     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
     * Once bound all draw calls will be rendered to the render surface.
     *
     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
     * @param renderSurface - the render surface to bind
     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
     * @param clearColor - the color to clear to
     * @param frame - the frame to render to
     * @returns the render target that was bound
     */
    bind(renderSurface, clear = "clear", clearColor, frame) {
      const renderTarget = this.getRenderTarget(renderSurface);
      const didChange = this.renderTarget !== renderTarget;
      this.renderTarget = renderTarget;
      this.renderSurface = renderSurface;
      const adaptor = this.adaptor;
      const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
      if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
        adaptor.resizeGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.pixelWidth;
        gpuRenderTarget.height = renderTarget.pixelHeight;
      }
      const source = renderTarget.colorTextures[0];
      const viewport = this.viewport;
      const pixelWidth = source.pixelWidth;
      const pixelHeight = source.pixelHeight;
      if (!frame && renderSurface.isTexture) {
        frame = renderSurface.frame;
      }
      let vx, vy, vw, vh;
      const resolution = source._resolution;
      if (frame) {
        vx = frame.x * resolution + 0.5 | 0;
        vy = frame.y * resolution + 0.5 | 0;
        vw = frame.width * resolution + 0.5 | 0;
        vh = frame.height * resolution + 0.5 | 0;
      } else {
        vx = 0;
        vy = 0;
        vw = pixelWidth;
        vh = pixelHeight;
      }
      viewport.set(vx, vy, vw, vh);
      calculateProjection(
        this.projectionMatrix,
        0,
        0,
        vw / resolution,
        vh / resolution,
        !renderTarget.isRoot
      );
      adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
      if (didChange) {
        this.onRenderTargetChange.emit(renderTarget);
      }
      return renderTarget;
    }
    clear(target, clear = "clear", clearColor) {
      if (!clear) return;
      if (target) {
        target = this.getRenderTarget(target);
      }
      this.adaptor.clear(
        target || this.renderTarget,
        clear,
        clearColor,
        this.viewport
      );
    }
    contextChange() {
     
    }
    /**
     * Push a render surface to the renderer. This will bind the render surface to the renderer,
     * @param renderSurface - the render surface to push
     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
     * @param clearColor - the color to clear to
     * @param frame - the frame to use when rendering to the render surface
     */
    push(renderSurface, clear = "clear", clearColor, frame) {
      const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
      this._renderTargetStack.push(renderTarget, frame);
      return renderTarget;
    }
    /** Pops the current render target from the renderer and restores the previous render target. */
    pop() {
      const currentRenderTargetData = this._renderTargetStack.pop();
      this.bind(currentRenderTargetData, false, null, currentRenderTargetData.frame);
    }
    /**
     * Gets the render target from the provide render surface. Eg if its a texture,
     * it will return the render target for the texture.
     * If its a render target, it will return the same render target.
     * @param renderSurface - the render surface to get the render target for
     * @returns the render target for the render surface
     */
    getRenderTarget(renderSurface) {
      if (renderSurface.isRenderTarget) return renderSurface;
      if (renderSurface.isTexture) renderSurface = renderSurface._source;
      let renderTarget = renderSurface.renderTarget;
      if (renderTarget !== null) return renderTarget;
      if (!renderSurface.isTextureSource) {
        Logger.error("source is not a TextureSource");
      }
      renderTarget = new RenderTarget({
        colorTextures: [renderSurface]
      });
      renderSurface.renderTarget = renderTarget;
      return renderTarget;
    }
    /**
     * Copies a render surface to another texture
     * @param sourceRenderSurfaceTexture - the render surface to copy from
     * @param destinationTexture - the texture to copy to
     * @param originSrc - the origin of the copy
     * @param originSrc.x - the x origin of the copy
     * @param originSrc.y - the y origin of the copy
     * @param size - the size of the copy
     * @param size.width - the width of the copy
     * @param size.height - the height of the copy
     * @param originDest - the destination origin (top left to paste from!)
     * @param originDest.x - the x origin of the paste
     * @param originDest.y - the y origin of the paste
     */
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const pw = sourceRenderSurfaceTexture.pixelWidth;
      const ph = sourceRenderSurfaceTexture.pixelHeight;
      if (originSrc.x < 0) {
        size.width += originSrc.x;
        originDest.x -= originSrc.x;
        originSrc.x = 0;
      }
      if (originSrc.y < 0) {
        size.height += originSrc.y;
        originDest.y -= originSrc.y;
        originSrc.y = 0;
      }
      size.width = Math.min(size.width, pw - originSrc.x);
      size.height = Math.min(size.height, ph - originSrc.y);
      return this.adaptor.copyToTexture(
        sourceRenderSurfaceTexture,
        destinationTexture,
        originSrc,
        size,
        originDest
      );
    }
    /**
     * ensures that we have a depth stencil buffer available to render to
     * This is used by the mask system to make sure we have a stencil buffer.
     */
    ensureDepthStencil() {
      if (!this.renderTarget.stencil) {
        this.renderTarget.stencil = true;
        this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
      }
    }
    /** nukes the render target system */
    destroy() {
      this._renderer = null;
    }
    getGpuRenderTarget(renderTarget) {
      return renderTarget.initGpuRenderTarget(this.adaptor);
    }
  }

  "use strict";
  class GlRenderTargetSystem extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GlRenderTargetAdaptor();
      this.adaptor.init(renderer, this);
    }
  }
  /** @ignore */
  GlRenderTargetSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "renderTarget"
  };

  "use strict";

  "use strict";
  class BufferResource extends EventEmitter {
    /**
     * Create a new Buffer Resource.
     * @param options - The options for the buffer resource
     * @param options.buffer - The underlying buffer that this resource is using
     * @param options.offset - The offset of the buffer this resource is using.
     * If not provided, then it will use the offset of the buffer.
     * @param options.size - The size of the buffer this resource is using.
     * If not provided, then it will use the size of the buffer.
     */
    constructor({ buffer, offset, size }) {
      super();
      /**
       * emits when the underlying buffer has changed shape (i.e. resized)
       * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
       * @event change
       */
      /** a unique id for this uniform group used through the renderer */
      this.uid = uid$1("buffer");
      /**
       * a resource type, used to identify how to handle it when its in a bind group / shader resource
       * @internal
       * @ignore
       */
      this._resourceType = "bufferResource";
      /**
       * used internally to know if a uniform group was used in the last render pass
       * @internal
       * @ignore
       */
      this._touched = 0;
      this.isBufferResource = true;
      /**
       * the resource id used internally by the renderer to build bind group keys
       * @internal
       * @ignore
       */
      this._resourceId = uid$1("resource");
      /**
       * A cheeky hint to the GL renderer to let it know this is a BufferResource
       * @internal
       * @ignore
       */
      this._bufferResource = true;
      /**
       * Has the Buffer resource been destroyed?
       * @readonly
       */
      this.destroyed = false;
      this.buffer = buffer;
      this.offset = offset | 0;
      this.size = size;
      this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      this._resourceId = uid$1("resource");
      this.emit("change", this);
    }
    /**
     * Destroys this resource. Make sure the underlying buffer is not used anywhere else
     * if you want to destroy it as well, or code will explode
     * @param destroyBuffer - Should the underlying buffer be destroyed as well?
     */
    destroy(destroyBuffer = false) {
      this.destroyed = true;
      if (destroyBuffer) {
        this.buffer.destroy();
      }
      this.emit("change", this);
      this.buffer = null;
    }
  }

  "use strict";
  function generateShaderSyncCode(shader, shaderSystem) {
    let funcFragments = "";
    let headerFragments = `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `;
    let addedTextreSystem = false;
    //let blockIndex = 0;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    const gl = shaderSystem._gl;
    const glProgram = shader.glProgram;
    const uniformBlockData = glProgram._uniformBlockData;
    const uniformBindMaps = shader._uniformBindMap;
    for (const i in shader.groups) {
      const uniformBindMap = uniformBindMaps[i] || Object.empty;
      const group = shader.groups[i];
      funcFragments += `
            resources = g[${i}].resources;
        `;
      for (const j in group.resources) {
        const resource = group.resources[j];
        const resName = uniformBindMap[Number(j)];
        const uniformBlock = uniformBlockData[resName];
        const dataIndex = uniformBlock !== void 0 ? uniformBlock.index : 0;
        if (resource.isUniformGroup) {
          if (resource.ubo) {
            funcFragments += `
                        sS.bindUniformBlock(
                            resources[${j}],
                            ${resName},
                            ${dataIndex}
                        );
                    `;
          } else {
            funcFragments += `
                        ugS.updateUniformGroup(resources[${j}], p, sD);
                    `;
          }
        } else if (resource.isBufferResource) {
          funcFragments += `
                    sS.bindUniformBlock(
                        resources[${j}],
                        ${resName},
                        ${dataIndex}
                    );
                `;
        } else if (resource.isTextureSource) {
          const uniformName = uniformBindMap[j];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments += `
                        var tS = r.texture;
                          `;
            }
            gl.uniform1i(uniformData.location, textureCount);
            funcFragments += `
                        tS.bind(resources[${j}], ${textureCount});
                    `;
            textureCount++;
          }
        }
      }
    }
    const functionSource = `${headerFragments}\n${funcFragments}`;
    return new Function("r", "s", "sD", functionSource);
  }

  "use strict";
  class GlProgramData {
    /**
     * Makes a new Pixi program.
     * @param program - webgl program
     * @param uniformData - uniforms
     */
    constructor(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBlockBindings = {};
    }
    /** Destroys this program. */
    destroy() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBlockBindings = null;
      this.program = null;
    }
  }

  "use strict";
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }

  "use strict";
  function booleanArray(size) {
    const array = new Array(size);
    for (let i = 0; i < array.length; i++) {
      array[i] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }

  "use strict";
  let GL_TABLE = null;
  const GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  const GLSL_TO_VERTEX_TYPES = {
    float: "float32",
    vec2: "float32x2",
    vec3: "float32x3",
    vec4: "float32x4",
    int: "sint32",
    ivec2: "sint32x2",
    ivec3: "sint32x3",
    ivec4: "sint32x4",
    uint: "uint32",
    uvec2: "uint32x2",
    uvec3: "uint32x3",
    uvec4: "uint32x4",
    bool: "uint32",
    bvec2: "uint32x2",
    bvec3: "uint32x3",
    bvec4: "uint32x4"
  };
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i = 0; i < typeNames.length; ++i) {
        const tn = typeNames[i];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }

  "use strict";
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < totalAttributes; i++) {
      const attribData = gl.getActiveAttrib(program, i);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        // set further down..
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a, b) => a > b ? 1 : -1);
      for (let i = 0; i < keys.length; i++) {
        attributes[keys[i]].location = i;
        gl.bindAttribLocation(program, i, keys[i]);
      }
      gl.linkProgram(program);
    } else {
      for (let i = 0; i < keys.length; i++) {
        attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);
      }
    }
    return attributes;
  }

  "use strict";
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i = 0; i < totalUniformsBlocks; i++) {
      const name = gl.getActiveUniformBlockName(program, i);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }

  "use strict";
  const UniformRegex = /\[.*?\]$/;
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < totalUniforms; i++) {
      const uniformData = gl.getActiveUniform(program, i);
      UniformRegex.lastIndex = 0;
      const name = uniformData.name.replace(UniformRegex, "");
      const isArray = uniformData.name.match(UniformRegex) !== null;
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }

  "use strict";
  const GlShaderLogRegex = /^ERROR: 0:(\d+):/gm;
  const GlShaderLineSet = new Set();
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split('\n');
    const shaderLog = gl.getShaderInfoLog(shader);
    // Set
    const lineNumbers = GlShaderLineSet;
    lineNumbers.clear();
    // 
    for (const match of shaderLog.matchAll(GlShaderLogRegex)) {
      lineNumbers.add(parseInt(match[1], 10));
    }
    // template literal
    let formattedOutput = "";
    for (const lineNum of lineNumbers) {
      formattedOutput += `${shaderSrc[lineNum - 1]}`;
    }
    Logger.error(shaderLog);
    Logger.group('click to view full shader code', true);
    Logger.warn(formattedOutput);
    Logger.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      Logger.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        Logger.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }

  "use strict";
  const Reg_Program = /^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m;
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        Logger.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !Reg_Program.test(program.vertex)
    );
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i in program._uniformData) {
      const data = program._uniformData[i];
      uniformData[i] = {
        location: gl.getUniformLocation(webGLProgram, i),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram = new GlProgramData(webGLProgram, uniformData);
    return glProgram;
  }

  "use strict";
  const defaultSyncData = {
    textureCount: 0,
    blockIndex: 0
  };
  class GlShaderSystem {
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange(gl) {
      this._gl = gl;
      this._programDataHash = /* @__PURE__ */ Object.create(null);
      this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
      this._activeProgram = null;
    }
    resetState() {
      this._activeProgram = null;
    }
    /**
     * Changes the current shader to the one given in parameter.
     * @param shader - the new shader
     * @param skipSync - false if the shader should automatically sync its uniforms.
     * @returns the glProgram that belongs to the shader.
     */
    bind(shader, skipSync = false) {
      const glProgram = shader.glProgram;
      this._setProgram(glProgram);
      if (skipSync) return;
      defaultSyncData.textureCount = 0;
      defaultSyncData.blockIndex = 0;
      const key = glProgram._key;
      let syncFunction = this._shaderSyncFunctions[key];
      if (!syncFunction) {
        syncFunction = this._shaderSyncFunctions[key] = this._generateShaderSync(shader, this);
      }
      this._renderer.buffer.nextBindBase(glProgram.transformFeedbackVaryings);
      syncFunction(this._renderer, shader, defaultSyncData);
    }
    /**
     * Updates the uniform group.
     * @param uniformGroup - the uniform group to update
     */
    updateUniformGroup(uniformGroup) {
      this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
    }
    /**
     * Binds a uniform block to the shader.
     * @param uniformGroup - the uniform group to bind
     * @param name - the name of the uniform block
     * @param index - the index of the uniform block
     */
    bindUniformBlock(uniformGroup, name, index = 0) {
      const bufferSystem = this._renderer.buffer;
      const programData = this._getProgramData(this._activeProgram);
      const isBufferResource = uniformGroup._bufferResource;
      if (!isBufferResource) {
        this._renderer.ubo.updateUniformGroup(uniformGroup);
      }
      const buffer = uniformGroup.buffer;
      const glBuffer = bufferSystem.updateBuffer(buffer);
      const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
      if (isBufferResource) {
        const offset = uniformGroup.offset;
        const size = uniformGroup.size;
        if (offset === 0 && size === buffer._data.byteLength) {
          bufferSystem.bindBufferBase(glBuffer, boundLocation);
        } else {
          bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
        }
      } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
        bufferSystem.bindBufferBase(glBuffer, boundLocation);
      }
      const gl = this._gl;
      const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
      if (programData.uniformBlockBindings[index] === boundLocation) return;
      programData.uniformBlockBindings[index] = boundLocation;
      gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
    }
    _setProgram(program) {
      if (this._activeProgram === program) return;
      this._activeProgram = program;
      const programData = this._getProgramData(program);
      this._gl.useProgram(programData.program);
    }
    /**
     * @param program - the program to get the data for
     * @internal
     * @private
     */
    _getProgramData(program) {
      return this._programDataHash[program._key] || this._createProgramData(program);
    }
    _createProgramData(program) {
      const key = program._key;
      this._programDataHash[key] = generateProgram(this._gl, program);
      return this._programDataHash[key];
    }
    destroy() {
      for (const key of Object.keys(this._programDataHash)) {
        const programData = this._programDataHash[key];
        programData.destroy();
        this._programDataHash[key] = null;
      }
      this._programDataHash = null;
      //this._boundUniformsIdsToIndexHash = null;
    }
    /**
     * Creates a function that can be executed that will sync the shader as efficiently as possible.
     * Overridden by the unsafe eval package if you don't want eval used in your project.
     * @param shader - the shader to generate the sync function for
     * @param shaderSystem - the shader system to use
     * @returns - the generated sync function
     * @ignore
     */
    _generateShaderSync(shader, shaderSystem) {
      return generateShaderSyncCode(shader, shaderSystem);
    }
  }
  /** @ignore */
  GlShaderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "shader"
  };

  "use strict";
  const UNIFORM_TO_SINGLE_SETTERS = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
  };
  const UNIFORM_TO_ARRAY_SETTERS = {
    f32: `gl.uniform1fv(location, v);`,
    "vec2<f32>": `gl.uniform2fv(location, v);`,
    "vec3<f32>": `gl.uniform3fv(location, v);`,
    "vec4<f32>": `gl.uniform4fv(location, v);`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
    i32: `gl.uniform1iv(location, v);`,
    "vec2<i32>": `gl.uniform2iv(location, v);`,
    "vec3<i32>": `gl.uniform3iv(location, v);`,
    "vec4<i32>": `gl.uniform4iv(location, v);`,
    u32: `gl.uniform1iv(location, v);`,
    "vec2<u32>": `gl.uniform2iv(location, v);`,
    "vec3<u32>": `gl.uniform3iv(location, v);`,
    "vec4<u32>": `gl.uniform4iv(location, v);`,
    bool: `gl.uniform1iv(location, v);`,
    "vec2<bool>": `gl.uniform2iv(location, v);`,
    "vec3<bool>": `gl.uniform3iv(location, v);`,
    "vec4<bool>": `gl.uniform4iv(location, v);`
  };

  "use strict";
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    const uniforms = group.uniforms;
    const structers = group.uniformStructures;
    for (const i in uniforms) {
      if (!uniformData[i]) {
        const uniformer = uniforms[i];
        if (uniformer.isUniformGroup) {
          if (uniformer.ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `);
          }
        } else if (uniformer.isBufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `);
        }
        continue;
      }
      const uniform = structers[i];
      let parsed = false;
      for (let j = 0; j < uniformParsers.length; j++) {
        const parser = uniformParsers[j];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i}";`, uniformParsers[j].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i}"].location`);
        funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }

  "use strict";
  class GlUniformGroupSystem {
    /** @param renderer - The renderer this System works for. */
    constructor(renderer) {
      /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */
      this._cache = {};
      this._uniformGroupSyncHash = {};
      this._renderer = renderer;
      this.gl = null;
      this._cache = {};
    }
    contextChange(gl) {
      this.gl = gl;
    }
    /**
     * Uploads the uniforms values to the currently bound shader.
     * @param group - the uniforms values that be applied to the current shader
     * @param program
     * @param syncData
     * @param syncData.textureCount
     */
    updateUniformGroup(group, program, syncData) {
      const programData = this._renderer.shader._getProgramData(program);
      const uniformDirtyGroups = programData.uniformDirtyGroups;
      const uid = group.uid;
      if (!group.isStatic || group._dirtyId !== uniformDirtyGroups[uid]) {
        uniformDirtyGroups[uid] = group._dirtyId;
        const syncFunc = this._getUniformSyncFunction(group, program);
        syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
      }
    }
    /**
     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
     * @param group
     * @param program
     */
    _getUniformSyncFunction(group, program) {
      var _a;
      return ((_a = this._uniformGroupSyncHash[group._signature]) == null ? void 0 : _a[program._key]) || this._createUniformSyncFunction(group, program);
    }
    _createUniformSyncFunction(group, program) {
      const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
      const id = this._getSignature(group, program._uniformData, "u");
      if (!this._cache[id]) {
        this._cache[id] = this._generateUniformsSync(group, program._uniformData);
      }
      uniformGroupSyncHash[program._key] = this._cache[id];
      return uniformGroupSyncHash[program._key];
    }
    _generateUniformsSync(group, uniformData) {
      return generateUniformsSync(group, uniformData);
    }
    /**
     * Takes a uniform group and data and generates a unique signature for them.
     * @param group - The uniform group to get signature of
     * @param group.uniforms
     * @param uniformData - Uniform information generated by the shader
     * @param preFix
     * @returns Unique signature of the uniform group
     */
    _getSignature(group, uniformData, preFix) {
      const uniforms = group.uniforms;
      let strings = `${preFix}-`;
      for (const i in uniforms) {
        strings += `${i}-`;
        if (uniformData[i]) {
          strings += `${uniformData[i].type}-`;
        }
      }
      return strings;
    }
    /** Destroys this System and removes all its textures. */
    destroy() {
      this._renderer = null;
      this._cache = null;
    }
  }
  /** @ignore */
  GlUniformGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "uniformGroup"
  };

  "use strict";
  const GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }

  "use strict";
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }

  "use strict";
  const BLEND = 0;
  const OFFSET = 1;
  const CULLING = 2;
  const DEPTH_TEST = 3;
  const WINDING = 4;
  const DEPTH_MASK = 5;
  class GlStateSystem {
    constructor(renderer) {
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = "none";
      this._blendEq = false;
      this.map = [];
      /**
     * Whether to invert the front face when rendering
     * This is used for render textures where the Y-coordinate is flipped
     * @default false
     */
      this._invertFrontFace = false;
      this._glFrontFace = false;
      this._cullFace = false;
      this._frontFaceDirty = false;
      this._frontFace = false;
      this.map[BLEND] = this.setBlend;
      this.map[OFFSET] = this.setOffset;
      this.map[CULLING] = this.setCullFace;
      this.map[DEPTH_TEST] = this.setDepthTest;
      this.map[WINDING] = this.setFrontFace;
      this.map[DEPTH_MASK] = this.setDepthMask;
      this.checks = [];
      this.defaultState = State.for2d();
      // listen for when the renderTarget changes
      // as rendering to textures means we need to invert the front face
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(gl) {
      this.gl = gl;
      this.blendModesMap = mapWebGLBlendModesToPixi(gl);
      this.resetState();
    }
    onRenderTargetChange(renderTarget) {
      this._invertFrontFace = !renderTarget.isRoot;
      // mini optimization to avoid setting the front face if culling is disabled
      if (this._cullFace) {
        // need to set the front face to the requested value as it matters because of the culling is active!
        this.setFrontFace(this._frontFace);
      } else {
        // if culling is disabled, we need to set the front face dirty
        this._frontFaceDirty = true;
      }
    }
    /**
     * Sets the current state
     * @param {State} state - The state to set.
     */
    set(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        let diff = this.stateId ^ state.data;
        let i = 0;
        const map = this.map;
        const data = state.data;
        while (diff) {
          if (diff & 1) {
            map[i](!!(data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = data;
      }
      const checks = this.checks;
      for (let i = 0; i < checks.length; i++) {
        checks[i](this, state);
      }
    }
    /**
     * Sets the state, when previous state is unknown.
     * @param {*} state - The state to set
     */
    forceState(state) {
      state = state || this.defaultState;
      const map = this.map;
      for (let i = 0; i < map.length; i++) {
        map[i].call(this, !!(state.data & 1 << i));
      }
      const checks = this.checks;
      for (let i = 0; i < checks.length; i++) {
        checks[i](this, state);
      }
      this.stateId = state.data;
    }
    /**
     * Sets whether to enable or disable blending.
     * @param value - Turn on or off WebGl blending.
     */
    setBlend(value) {
      this._updateCheck(GlStateSystem._checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    }
    /**
     * Sets whether to enable or disable polygon offset fill.
     * @param value - Turn on or off webgl polygon offset testing.
     */
    setOffset(value) {
      this._updateCheck(GlStateSystem._checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    /**
     * Sets whether to enable or disable depth test.
     * @param value - Turn on or off webgl depth testing.
     */
    setDepthTest(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    /**
     * Sets whether to enable or disable depth mask.
     * @param value - Turn on or off webgl depth mask.
     */
    setDepthMask(value) {
      this.gl.depthMask(value);
    }
    /**
     * Sets whether to enable or disable cull face.
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    setCullFace(value) {
      this._cullFace = value;
      this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
      if (this._cullFace && this._frontFaceDirty) {
        // need to set the front face to the requested value as it matters because of the culling is active!
        this.setFrontFace(this._frontFace);
      }
    }
    /**
     * Sets the gl front face.
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    setFrontFace(value) {
      this._frontFace = value;
      this._frontFaceDirty = false;
      // If invertFrontFace is true, we invert the face direction
      const faceMode = this._invertFrontFace ? !value : value;
      if (this._glFrontFace !== faceMode) {
        this._glFrontFace = faceMode;
        this.gl.frontFace(this.gl[faceMode ? 'CW' : 'CCW']);
      }
    }
    /**
     * Sets the blend mode.
     * @param {number} value - The blend mode to set to.
     */
    setBlendMode(value) {
      const map = this.blendModesMap;
      if (map[value] === void 0) value = "normal";
      if (value === this.blendMode) return;
      this.blendMode = value;
      const mode = map[value];
      const gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    }
    /**
     * Sets the polygon offset.
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    setPolygonOffset(value, scale) {
      this.gl.polygonOffset(value, scale);
    }
    // used
    /** Resets all the logic and disables the VAOs. */
    resetState() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this._glFrontFace = false;
      this._frontFace = false;
      this._cullFace = false;
      this._frontFaceDirty = false;
      this._invertFrontFace = false;
      this.gl.frontFace(this.gl.CCW);
      this.blendMode = "";
      this.setBlendMode("normal");
    }
    /**
     * Checks to see which updates should be checked based on which settings have been activated.
     *
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     * @param func - the checking function to add or remove
     * @param value - should the check function be added or removed.
     */
    _updateCheck(func, value) {
      if (value) this.checks.add(func);
      else this.checks.remove(func);
    }
    /**
     * A private little wrapper function that we call to check the blend mode.
     * @param system - the System to perform the state check on
     * @param state - the state that the blendMode will pulled from
     */
    static _checkBlendMode(system, state) {
      system.setBlendMode(state.blendMode);
    }
    /**
     * A private little wrapper function that we call to check the polygon offset.
     * @param system - the System to perform the state check on
     * @param state - the state that the blendMode will pulled from
     */
    static _checkPolygonOffset(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    }
    /**
     * @ignore
     */
    destroy() {
      this.gl = null;
      this.checks.length = 0;
    }
  };
  /** @ignore */
  GlStateSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "state"
  };

  "use strict";
  class GlTexture {
    constructor(texture) {
      this.target = GL_TARGETS.TEXTURE_2D;
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.type = GL_TYPES.UNSIGNED_BYTE;
      this.internalFormat = GL_FORMATS.RGBA;
      this.format = GL_FORMATS.RGBA;
      this.samplerType = 0;
    }
  }

  "use strict";
  const glUploadBufferImageResource = {
    id: "buffer",
    upload(source, glTexture, gl) {
      if (glTexture.width === source.width || glTexture.height === source.height) {
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          source.width,
          source.height,
          glTexture.format,
          glTexture.type,
          source.resource
        );
      } else {
        gl.texImage2D(
          glTexture.target,
          0,
          glTexture.internalFormat,
          source.width,
          source.height,
          0,
          glTexture.format,
          glTexture.type,
          source.resource
        );
      }
      glTexture.width = source.width;
      glTexture.height = source.height;
    }
  };

  const glUploadCompressedTextureResource = {
    id: "compressed",
    upload(source, _glTexture, gl) {
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
      let mipWidth = source.pixelWidth;
      let mipHeight = source.pixelHeight;
      const resource = source.resource;
      const ext = Engine.compressedTextureGLExtensionsMap[source.format];
      for (let i = 0; i < resource.length; i++) {
        const levelBuffer = resource[i];
        gl.compressedTexImage2D(
          gl.TEXTURE_2D,
          i,
          ext,
          mipWidth,
          mipHeight,
          0,
          levelBuffer
        );
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };

  "use strict";
  function webgl1Upload(source, glTexture, gl) {
    const glWidth = glTexture.width;
    const glHeight = glTexture.height;
    const textureWidth = source.pixelWidth;
    const textureHeight = source.pixelHeight;
    const resource = source.resource;
    if (glWidth !== textureWidth || glHeight !== textureHeight) {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        glTexture.format,
        glTexture.type,
        resource
      );
      glTexture.width = textureWidth;
      glTexture.height = textureHeight;
    } else {
      gl.texSubImage2D(
        gl.TEXTURE_2D,
        0,
        0,
        0,
        glTexture.format,
        glTexture.type,
        resource
      );
    }
  }
  function webgl2Upload(source, glTexture, gl) {
    const glWidth = glTexture.width;
    const glHeight = glTexture.height;
    const textureWidth = source.pixelWidth;
    const textureHeight = source.pixelHeight;
    const resource = source.resource;
    const resourceWidth = resource.width;
    const resourceHeight = resource.height;
    if (glWidth !== textureWidth || glHeight !== textureHeight) {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        textureWidth,
        textureHeight,
        0,
        glTexture.format,
        glTexture.type,
        resource
      );
      glTexture.width = textureWidth;
      glTexture.height = textureHeight;
    } else {
      gl.texSubImage2D(
        gl.TEXTURE_2D,
        0,
        0,
        0,
        resourceWidth,
        resourceHeight,
        glTexture.format,
        glTexture.type,
        resource
      );
    }
  }
  const glUploadImageResource = {
    id: "image",
    upload(source, glTexture, gl, webGLVersion) {
      if (webGLVersion === 2) webgl2Upload(source, glTexture, gl);
      else webgl1Upload(source, glTexture, gl);
    }
  };

  "use strict";
  const scaleModeToGlFilter = {
    linear: 9729,
    nearest: 9728
  };
  const mipmapScaleModeToGlFilter = {
    linear: {
      linear: 9987,
      nearest: 9985
    },
    nearest: {
      linear: 9986,
      nearest: 9984
    }
  };
  const wrapModeToGlAddress = {
    "clamp-to-edge": 33071,
    repeat: 10497,
    "mirror-repeat": 33648
  };
  const compareModeToGlCompare = {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  };

  "use strict";
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }

  "use strict";
  function mapFormatToGlFormat(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      // 16-bit formats
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      // 32-bit formats
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      // 64-bit formats
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      // 128-bit formats
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }

  "use strict";
  var __defProp$i = Object.defineProperty;
  var __defProps$8 = Object.defineProperties;
  var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
  var __hasOwnProp$i = Object.prototype.hasOwnProperty;
  var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$i = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    if (__getOwnPropSymbols$i)
      for (var prop of __getOwnPropSymbols$i(b)) {
        if (__propIsEnum$i.call(b, prop))
          __defNormalProp$i(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
  function mapFormatToGlInternalFormat(gl, extensions) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return __spreadValues$i(__spreadValues$i(__spreadValues$i(__spreadValues$i(__spreadValues$i(__spreadValues$i(__spreadProps$8(__spreadValues$i({
      // 8-bit formats
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      // 16-bit formats
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      // 32-bit formats
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA
    }, srgb), {
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      // 64-bit formats
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      // 128-bit formats
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8
    }), extensions.s3tc ? {
      "bc1-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {}), extensions.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {}), extensions.rgtc ? {
      "bc4-r-unorm": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {}), extensions.bptc ? {
      "bc6h-rgb-float": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {}), extensions.etc ? {
      "etc2-rgb8unorm": extensions.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {}), extensions.astc ? {
      "astc-4x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {});
  }

  "use strict";
  function mapFormatToGlType(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      // 16-bit formats
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      // 32-bit formats
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      // Packed 32-bit formats
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      // 64-bit formats
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      // 128-bit formats
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      // Depth/stencil formats
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }

  "use strict";
  function unpremultiplyAlpha$1(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5;
        pixels[i + 1] = pixels[i + 1] * a + 0.5;
        pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }

  class GlLimitsSystem {
    static extension = {
      type: [
        ExtensionType.WebGLSystem,
      ],
      name: 'limits',
    };
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange() {
      const gl = this._renderer.gl;
      const maxTextures = this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.maxBatchableTextures = checkMaxIfStatementsInShader(maxTextures, gl);
      this.maxUniformBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
      const defaultOptions = Batcher.defaultOptions;
      defaultOptions.maxTextures = maxTextures;
      this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      if (defaultOptions.shader === null) defaultOptions.shader = new DefaultShader(maxTextures);
    }
    destroy() {
      // boom!
    }
  }

  "use strict";
  const unknownUpload = {
    upload: Function.empty
  };
  const glUnknowUpload = {
    upload(source, _glTexture, gl) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
  }
  const BYTES_PER_PIXEL = 4;
  class GlTextureSystem {
    constructor(renderer) {
      this._glSamplers = /* @__PURE__ */ Object.create(null);
      this._boundTextures = [];
      this._activeTextureLocation = -1;
      this._boundSamplers = /* @__PURE__ */ Object.create(null);
      this._uploads = {
        image: glUploadImageResource,
        buffer: glUploadBufferImageResource,
        video: glUploadImageResource,
        compressed: glUploadCompressedTextureResource,
        unknown: glUnknowUpload
      };
      this._premultiplyAlpha = false;
      this._useSeparateSamplers = false;
      this._renderer = renderer;
    }
    contextChange(gl) {
      this._gl = gl;
      const renderer = this._renderer;
      if (!this._mapFormatToInternalFormat) {
        this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, renderer.context.extensions);
        this._mapFormatToType = mapFormatToGlType(gl);
        this._mapFormatToFormat = mapFormatToGlFormat(gl);
      }
      this._glSamplers = /* @__PURE__ */ Object.create(null);
      this._boundSamplers = /* @__PURE__ */ Object.create(null);
      const emptyTexture = Texture.EMPTY._source;
      const maxTextures = renderer.limits.maxTextures;
      for (let i = 0; i < maxTextures; i++) {
        this.bind(emptyTexture, i);
      }
    }
    resetState() {
      this._activeTextureLocation = -1;
      const source = Texture.EMPTY._source;
      const textures = this._boundTextures;
      for (let i = 0; i < textures.length; i++) {
        textures[i] = source;
      }
      const cache = this._boundSamplers;
      for (const key in cache) {
        cache[key] = null;
      }
    }
    initSource(source) {
      this.bind(source);
    }
    bind(texture = null, location = 0) {
      this.bindSource(texture, location);
    }
    bindSource(source, location = 0) {
      const gl = this._gl;
      source = source || Texture.EMPTY._source;
      const boundTextures = this._boundTextures;
      if (boundTextures[location] !== source) {
        boundTextures[location] = source;
        source.bindingLocation = location;
        this._activateLocation(location);
        const glTexture = this.getGlSource(source);
        gl.bindTexture(glTexture.target, glTexture.texture);
      }
    }
    _bindSampler(style, location = 0) {
      const gl = this._gl;
      if (!style) {
        this._boundSamplers[location] = null;
        gl.bindSampler(location, null);
        return;
      }
      const sampler = this._getGlSampler(style);
      if (this._boundSamplers[location] !== sampler) {
        this._boundSamplers[location] = sampler;
        gl.bindSampler(location, sampler);
      }
    }
    unbind(texture) {
      const boundTextures = this._boundTextures;
      const gl = this._gl;
      const bindingLocation = texture.bindingLocation;
      if (bindingLocation === void 0) return;
      this._activateLocation(bindingLocation);
      const glTexture = this.getGlSource(texture);
      gl.bindTexture(glTexture.target, null);
      boundTextures[bindingLocation] = null;
    }
    _activateLocation(location) {
      if (this._activeTextureLocation !== location) {
        this._activeTextureLocation = location;
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
    }
    _initSource(source) {
      const gl = this._gl;
      const glTexture = new GlTexture(gl.createTexture());
      const format = source.format;
      glTexture.type = this._mapFormatToType[format];
      glTexture.internalFormat = this._mapFormatToInternalFormat[format];
      glTexture.format = this._mapFormatToFormat[format];
      source.hasListeneredGpuTexture = true;
      source.on("update", this.onSourceUpdate, this);
      source.on("resize", this.onSourceUpdate, this);
      source.on("styleChange", this.onStyleChange, this);
      source.on("destroy", this.onSourceDestroy, this);
      source.on("unload", this.onSourceUnload, this);
      source.on("updateMipmaps", this.onUpdateMipmaps, this);
      source.gpuTexture = glTexture;
      source.hasGpuTexture = true;
      this.onSourceUpdate(source);
      this.updateStyle(source, false);
      return glTexture;
    }
    onStyleChange(source) {
      this.updateStyle(source, false);
    }
    updateStyle(source, firstCreation) {
      const gl = this._gl;
      const context = this._renderer.context;
      const glTexture = this.getGlSource(source);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source;
      applyStyleParams(
        source._style,
        gl,
        source.mipLevelCount > 1,
        context.extensions.anisotropicFiltering,
        "texParameteri",
        gl.TEXTURE_2D,
        // will force a clamp to edge if the texture is not a power of two
        !context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,
        firstCreation
      );
    }
    onSourceUnload(source) {
      const glTexture = source.gpuTexture;
      this.unbind(source);
      this._gl.deleteTexture(glTexture.texture);
      source.gpuTexture = null;
      source.hasGpuTexture = false;
    }
    onSourceUpdate(source) {
      const gl = this._gl;
      const glTexture = this.getGlSource(source);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source;
      const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';
      if (this._premultiplyAlpha !== premultipliedAlpha) {
        this._premultiplyAlpha = premultipliedAlpha;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
      }
      this._uploads[source.uploadMethodId].upload(source, glTexture, gl);
    }
    onUpdateMipmaps(source, bind = true) {
      if (source.uploadMethodId === "compressed") return;
      if (bind) this.bindSource(source, 0);
      const glTexture = this.getGlSource(source);
      this._gl.generateMipmap(glTexture.target);
    }
    onSourceDestroy(source) {
      source.off("destroy", this.onSourceDestroy, this);
      source.off("update", this.onSourceUpdate, this);
      source.off("resize", this.onSourceUpdate, this);
      source.off("unload", this.onSourceUnload, this);
      source.off("styleChange", this.onStyleChange, this);
      source.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.onSourceUnload(source);
    }
    _initSampler(style) {
      const gl = this._gl;
      const glSampler = this._gl.createSampler();
      this._glSamplers[style._resourceId] = glSampler;
      applyStyleParams(
        style,
        gl,
        this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
        this._renderer.context.extensions.anisotropicFiltering,
        "samplerParameteri",
        glSampler,
        false,
        true
      );
      return this._glSamplers[style._resourceId];
    }
    _getGlSampler(sampler) {
      return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
    }
    getGlSource(source) {
      return source.gpuTexture || this._initSource(source);
    }
    generateCanvas(texture) {
      const { pixels, width, height } = this.getPixels(texture);
      const canvas = DOMAdapter.get().createCanvas();
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        const imageData = ctx.createImageData(width, height);
        imageData.data.set(pixels);
        ctx.putImageData(imageData, 0, 0);
      }
      return canvas;
    }
    getPixels(texture) {
      const resolution = texture._source.resolution;
      const frame = texture.frame;
      const width = Math.max(Math.round(frame.width * resolution), 1);
      const height = Math.max(Math.round(frame.height * resolution), 1);
      const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const renderer = this._renderer;
      const renderTarget = renderer.renderTarget.getRenderTarget(texture);
      const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
      const gl = renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
      gl.readPixels(
        Math.round(frame.x * resolution),
        Math.round(frame.y * resolution),
        width,
        height,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        pixels
      );
      return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  GlTextureSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "texture"
  };

  "use strict";
  const GL_MESH_ADAPTOR_DRAW_OPTIONS = {
    geometry: null,
    shader: null,
    state: null
  }
  class GlMeshAdaptor {
    init() {
      const glProgram = compileHighShaderGlProgram(
        [
          localUniformBitGl,
          textureBitGl,
          roundPixelsBitGl
        ],
        "mesh"
      );
      const emptyTexture = Texture.EMPTY._source;
      this._shader = new Shader({
        glProgram,
        resources: {
          uTexture: emptyTexture,
          uSampler: emptyTexture._style,
          textureUniforms: {
            uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
          }
        }
      });
    }
    execute(meshPipe, mesh) {
      const renderer = meshPipe.renderer;
      let shader = mesh._shader;
      if (!shader) {
        shader = this._shader;
        const texture = mesh._texture;
        const source = texture._source;
        const group = shader.groups[99];
        group.setResource(source, 0);
        group.setResource(source._style, 1);
        const uniforms = group.getResource(2).uniforms;
        let textureMatrix = texture._textureMatrix;
        if (textureMatrix === null) {
          textureMatrix = new TextureMatrix(texture);
          texture._textureMatrix = textureMatrix;
        }
        uniforms.uTextureMatrix = textureMatrix.mapCoord;
      } else if (!shader.glProgram) {
        Logger.warn("Mesh shader has no glProgram", mesh.shader);
        return;
      }
      const groups = shader.groups;
      groups[100] = renderer.globalUniforms._currentGlobalUniformData.bindGroup;
      groups[101] = meshPipe.localUniformsBindGroup;
      GL_MESH_ADAPTOR_DRAW_OPTIONS.geometry = mesh._geometry;
      GL_MESH_ADAPTOR_DRAW_OPTIONS.shader = shader;
      GL_MESH_ADAPTOR_DRAW_OPTIONS.state = mesh.state;
      renderer.encoder.draw(GL_MESH_ADAPTOR_DRAW_OPTIONS);
    }
    destroy() {
      this._shader.destroy(true);
      this._shader = null;
    }
  }
  GlMeshAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "mesh"
  };

  "use strict";
  class CustomRenderPipe {
    constructor(renderer) {
      this._renderer = renderer;
    }
    updateRenderable() {
    }
    destroyRenderable() {
    }
    validateRenderable() {
      return false;
    }
    addRenderable(container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(container);
    }
    execute(container) {
      if (!container.isRenderable)
        return;
      container.render(this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  CustomRenderPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "customRender"
  };

  "use strict";
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i = 0; i < instructionSet.instructionSize; i++) {
      const instruction = instructions[i];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }

  "use strict";
  class RenderGroupPipe {
    constructor(renderer) {
      this._renderer = renderer;
      this.options = {
        worldTransformMatrix: null,
        worldColor: 0
      }
    }
    addRenderGroup(renderGroup, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(renderGroup);
    }
    execute(renderGroup) {
      if (!renderGroup.isRenderable()) return;
      const options = this.options;
      options.worldTransformMatrix = renderGroup.worldTransform;
      options.worldColor = renderGroup.worldColorAlpha;
      const renderer = this._renderer;
      const globalUniforms = renderer.globalUniforms;
      globalUniforms.push(options);
      executeInstructions(renderGroup, renderer.renderPipes);
      globalUniforms.pop();
    }
    destroy() {
      this._renderer = null;
    }
  }
  RenderGroupPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "renderGroup"
  };

  "use strict";
  function mixHexColors(color1, color2, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r = r1 + (r2 - r1) * ratio;
    const g = g1 + (g2 - g1) * ratio;
    const b = b1 + (b2 - b1) * ratio;
    return (r << 16) + (g << 8) + b;
  }

  "use strict";
  const WHITE_BGR = 16777215;
  function mixColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      return localBGRColor + parentBGRColor - WHITE_BGR;
    }
    return mixHexColors(localBGRColor, parentBGRColor, 0.5);
  }
  function mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {
    const parentAlpha = (parentColor >> 24 & 255) / 255;
    const globalAlpha = localAlpha * parentAlpha * 255;
    const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);
    const parentBGRColor = parentColor & 16777215;
    let sharedBGRColor;
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;
    } else {
      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
    }
    return sharedBGRColor + (globalAlpha << 24);
  }

  "use strict";
  const tempContainer = new Container();
  const UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
  /**
   * 
   * @param {RenderGroup} renderGroup 
   * @param {AbstractRenderer} renderer 
   */
  function buildInstructions(renderGroup, renderer) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderPipes = renderer.renderPipes;
    const batch = renderPipes.batch;
    const blendMode = renderPipes.blendMode;
    batch.buildStart(instructionSet);
    blendMode.buildStart();
    renderPipes.colorMask.buildStart();
    root.collectRenderablesWithEffects(instructionSet, renderer);
    batch.buildEnd(instructionSet);
    blendMode.buildEnd(instructionSet);
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    const alpha = ((worldAlpha * 255 | 0) << 24) >>> 0;
    renderGroup.worldColorAlpha = renderGroup.worldColor + alpha;
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick) return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    let parent = container.parent;
    if (parent !== null && parent.renderGroup === null) {
      updateFlags = updateFlags | container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent.relativeGroupTransform
      );
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      parent = tempContainer;
    }
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
    if (container.isRoot) return;
    if (container.allowChildren) {
      const children = container.children;
      const length = children.length;
      for (let i = 0; i < length; i++) {
        updateTransformAndChildren(children[i], updateTick, updateFlags);
      }
    }
    const renderGroup = container.parentRenderGroup;
    if (container.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(container);
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = multiplyColors(
        container.localColor,
        parent.groupColor
      );
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha.clamp(0, 1);
      container.groupAlpha = groupAlpha;
      const alpha = ((groupAlpha * 255 | 0) << 24) >>> 0;
      container.groupColorAlpha = container.groupColor + alpha;
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }

  "use strict";
  const RENDER_START_OPTIONS = {
    worldTransformMatrix: null,
    worldColor: 1
  }
  class RenderGroupSystem {
    constructor(renderer) {
      this._renderer = renderer;
      const isWebgl = renderer.type === RendererType.WEBGL;
      this._onUniformBatchRenderEnd = isWebgl ? Function.empty : this.onUniformBatchRenderEnd;
    }
    onUniformBatchRenderEnd(renderPipes) {
      renderPipes.uniformBatch.renderEnd();
    }
    /**
     * 
     * @param {Object} options
     * @param {Container}options.container
     */
    render(options) {
      const container = options.container;
      const parent = container.parent;
      container.parent = null;
      const renderer = this._renderer;
      const renderGroup = container.renderGroup;
      const containerGroup = container.renderGroup;
      const renderPipes = renderer.renderPipes;
      const batch = renderPipes.batch;
      renderGroup.instructionSet.renderPipes = renderPipes;
      if (!renderGroup.structureDidChange) renderGroup.validateGroupRenderables(renderPipes);
      renderGroup.updateGroupTransforms();
      if (renderGroup.structureDidChange) {
        renderGroup.structureDidChange = false;
        buildInstructions(renderGroup, renderer);
      } else {
        renderGroup.updateGroupRenderables();
      }
      renderGroup.onPostRenderer();
      batch.upload(renderGroup.instructionSet);
      RENDER_START_OPTIONS.worldTransformMatrix = containerGroup.worldTransform;
      RENDER_START_OPTIONS.worldColor = containerGroup.worldColorAlpha;
      renderer.globalUniforms.start(RENDER_START_OPTIONS);
      executeInstructions(containerGroup, renderPipes);
      this._onUniformBatchRenderEnd(renderPipes);
      container.parent = parent;
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  RenderGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "renderGroup"
  };
  "use strict";
  class SpritePipe {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderable(sprite, instructionSet) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
      this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
      gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
      const texture = sprite._texture;
      const gpuSprite = this._getGpuSprite(sprite);
      if (gpuSprite._batcher === null) return true;
      return !checkAndUpdateTexture(gpuSprite, texture);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
      batchableSprite.bounds = sprite._bounds;
      batchableSprite.texture = sprite._texture;
    }
    _getGpuSprite(sprite) {
      return sprite._gpuData || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
      const batchableSprite = Zaun.Core.PoolSystem.PoolCache["defaultBatchPool"].get();
      batchableSprite.renderable = sprite;
      batchableSprite.transform = sprite.groupTransform;
      batchableSprite.texture = sprite._texture;
      batchableSprite.bounds = sprite._bounds;
      batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
      sprite._gpuData = batchableSprite;
      return batchableSprite;
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  SpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "sprite"
  };

  "use strict";
  var __defProp$h = Object.defineProperty;
  var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
  var __hasOwnProp$h = Object.prototype.hasOwnProperty;
  var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$h = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    if (__getOwnPropSymbols$h)
      for (var prop of __getOwnPropSymbols$h(b)) {
        if (__propIsEnum$h.call(b, prop))
          __defNormalProp$h(a, prop, b[prop]);
      }
    return a;
  };
  class BackgroundSystem {
    constructor() {
      this.clearBeforeRender = true;
      this._backgroundColor = new Color(0);
      this.color = this._backgroundColor;
      this.alpha = 1;
    }
    /**
     * initiates the background system
     * @param options - the options for the background colors
     */
    init(options) {
      options = __spreadValues$h(__spreadValues$h({}, BackgroundSystem.defaultOptions), options);
      this.clearBeforeRender = options.clearBeforeRender;
      this.color = options.background || options.backgroundColor || this._backgroundColor;
      this.alpha = options.backgroundAlpha;
      this._backgroundColor.setAlpha(options.backgroundAlpha);
    }
    /** The background color to fill if not transparent */
    get color() {
      return this._backgroundColor;
    }
    set color(value) {
      this._backgroundColor.setValue(value);
    }
    /** The background color alpha. Setting this to 0 will make the canvas transparent. */
    get alpha() {
      return this._backgroundColor[3];
    }
    set alpha(value) {
      this._backgroundColor.setAlpha(value);
    }
    /** The background color as an [R, G, B, A] array. */
    get colorRgba() {
      return this._backgroundColor;
    }
    /**
     * destroys the background system
     * @internal
     * @ignore
     */
    destroy() {
    }
  };
  /** @ignore */
  BackgroundSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "background",
    priority: 0
  };
  /** default options used by the system */
  BackgroundSystem.defaultOptions = {
    /**
     * {@link WebGLOptions.backgroundAlpha}
     * @default 1
     */
    backgroundAlpha: 1,
    /**
     * {@link WebGLOptions.backgroundColor}
     * @default 0x000000
     */
    backgroundColor: 0,
    /**
     * {@link WebGLOptions.clearBeforeRender}
     * @default true
     */
    clearBeforeRender: true
  };
  "use strict";
  const BLEND_MODE_FILTERS = {};
  extensions.handle(ExtensionType.BlendMode, (value) => {
    if (!value.name) {
      throw new Error("BlendMode extension must have a name property");
    }
    BLEND_MODE_FILTERS[value.name] = value.ref;
  }, (value) => {
    delete BLEND_MODE_FILTERS[value.name];
  });
  const Blend_Instruction = {
    renderPipeId: "filter",
    action: "push",
    renderables: [],
    filterEffect: null,
    canBundle: false
  };
  const Blend_End = {
    renderPipeId: "filter",
    action: "pop",
    canBundle: false
  }
  class BlendModePipe {
    constructor(renderer) {
      this._isAdvanced = false;
      this._filterHash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
    }
    /**
     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
     * @param renderable - The renderable we are adding to the instruction set
     * @param blendMode - The blend mode of the renderable
     * @param instructionSet - The instruction set we are adding to
     */
    setBlendMode(renderable, blendMode, instructionSet) {
      if (this._activeBlendMode === blendMode) {
        if (this._isAdvanced)
          this._renderableList.push(renderable);
        return;
      }
      this._activeBlendMode = blendMode;
      if (this._isAdvanced) {
        this._endAdvancedBlendMode(instructionSet);
      }
      this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
      if (this._isAdvanced) {
        this._beginAdvancedBlendMode(instructionSet);
        this._renderableList.push(renderable);
      }
    }
    _beginAdvancedBlendMode(instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      const blendMode = this._activeBlendMode;
      if (!BLEND_MODE_FILTERS[blendMode]) {
        Logger.warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
        return;
      }
      let filterEffect = this._filterHash[blendMode];
      if (filterEffect === void 0) {
        filterEffect = this._filterHash[blendMode] = new FilterEffect();
        filterEffect.filters.add(new BLEND_MODE_FILTERS[blendMode]());
      }
      Blend_Instruction.canBundle = false;
      Blend_Instruction.renderables.clear();
      Blend_Instruction.filterEffect = filterEffect;
      this._renderableList = Blend_Instruction.renderables;
      instructionSet.add(Blend_Instruction);
    }
    _endAdvancedBlendMode(instructionSet) {
      this._renderableList = null;
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(Blend_End);
    }
    /**
     * called when the instruction build process is starting this will reset internally to the default blend mode
     * @internal
     * @ignore
     */
    buildStart() {
      this._isAdvanced = false;
    }
    /**
     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
     * active, we add the final render instructions added to the instruction set
     * @param instructionSet - The instruction set we are adding to
     * @internal
     * @ignore
     */
    buildEnd(instructionSet) {
      if (this._isAdvanced) {
        this._endAdvancedBlendMode(instructionSet);
      }
    }
    /**
     * @internal
     * @ignore
     */
    destroy() {
      this._renderer = null;
      this._renderableList = null;
      for (const i in this._filterHash) {
        this._filterHash[i].destroy();
      }
      this._filterHash = null;
    }
  }
  /** @ignore */
  BlendModePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "blendMode"
  };

  "use strict";
  class RenderTexture extends Texture {
    static create(options) {
      return new RenderTexture({
        source: (new TextureSource()).setupOptions(options)
      });
    }
    /**
     * Resizes the render texture.
     * @param width - The new width of the render texture.
     * @param height - The new height of the render texture.
     * @param resolution - The new resolution of the render texture.
     * @returns This texture.
     */
    resize(width, height, resolution) {
      this.source.resize(width, height, resolution);
      return this;
    }
  }

  class GlobalUniformData {
    constructor() {
      this.projectionData = null;
      this.projectionMatrix = null;
      this.resolution = null;
      this.worldTransformMatrix = new Matrix();
      this.worldColor = 4294967295;
      this.offset = new Point();
      this.bindGroup = null;
    }
  }
  class GlobalUniformDataPool {
    constructor() {
      this.pool = [];
      this.currentIndex = 0;
      this.count = 0;
      this.empty = new GlobalUniformData();
    }
    get(index) {
      if (index === -1) return this.empty;
      let data = this.pool[index];
      if (data === void 0) {
        data = this.pool[index] = new GlobalUniformData();
        this.count++;
      }
      return data;
    }
    onRenderStart() {
      this.currentIndex = 0;
    }
    previousData() {
      return this.get(this.currentIndex - 1);
    }
    push() {
      return this.get(this.currentIndex++);
    }
    pop() {
      return this.get(--this.currentIndex - 1);
    }
  }
  "use strict";
  class GlobalUniformSystem {
    constructor(renderer) {
      this._activeUniforms = [];
      this._activeBindGroups = [];
      this._globalUniformDataPool = new GlobalUniformDataPool();
      this._renderer = renderer;
      this._currentUniformIndex = 0;
      this._currentBindGroupIndex = 0;
      this._currentGlobalUniformData = null;
      const isWebgl = renderer.type === RendererType.WEBGL;
      this._getBindGroup = isWebgl ? this.getGlBindGroup : this.getGpuBindGroup;
      this._updateGpuResource = isWebgl ? this.updateGlResource : Function.empty;
    }
    updateGlResource() {
      this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
    reset() {
      this._currentGlobalUniformData = null;
      this._currentUniformIndex = 0;
      this._currentBindGroupIndex = 0;
      this._globalUniformDataPool.onRenderStart();
    }
    start(options) {
      this.reset();
      this.push(options);
    }
    bind({
      size,
      projectionMatrix,
      worldTransformMatrix,
      worldColor,
      offset
    }) {
      const activeUniforms = this._activeUniforms;
      const activeBindGroups = this._activeBindGroups;
      const renderer = this._renderer;
      const renderPipes = renderer.renderPipes;
      const renderTarget = renderer.renderTarget.renderTarget;
      const globalUniformDataPool = this._globalUniformDataPool;
      const currentGlobalUniformData = globalUniformDataPool.previousData();
      currentGlobalUniformData.projectionData = renderTarget;
      const globalUniformData = globalUniformDataPool.push();
      globalUniformData.projectionMatrix = projectionMatrix || renderer.renderTarget.projectionMatrix;
      globalUniformData.resolution = size || renderTarget.size;
      globalUniformData.worldTransformMatrix = worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix;
      globalUniformData.worldColor = worldColor || currentGlobalUniformData.worldColor;
      globalUniformData.offset = offset || currentGlobalUniformData.offset;
      globalUniformData.bindGroup = null;
      const uniformGroup = activeUniforms[this._currentUniformIndex] || this._createUniforms();
      activeUniforms[this._currentUniformIndex++] = uniformGroup;
      const uniforms = uniformGroup.uniforms;
      uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
      uniforms.uResolution = globalUniformData.resolution;
      const uWorldTransformMatrix = uniforms.uWorldTransformMatrix;
      uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
      uWorldTransformMatrix.tx -= globalUniformData.offset.x;
      uWorldTransformMatrix.ty -= globalUniformData.offset.y;
      color32BitToUniform(
        globalUniformData.worldColor,
        uniforms.uWorldColorAlpha,
        0
      );
      uniformGroup.update();
      const bindGroup = this._getBindGroup(uniformGroup, renderPipes, activeBindGroups);
      globalUniformData.bindGroup = bindGroup;
      this._currentGlobalUniformData = globalUniformData;
    }
    getGpuBindGroup(uniformGroup, renderPipes, _activeBindGroups) {
      return renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
    }
    getGlBindGroup(uniformGroup, _renderPipes, activeBindGroups) {
      const bindGroup = activeBindGroups[this._currentBindGroupIndex] || new BindGroup();
      activeBindGroups[this._currentBindGroupIndex++] = bindGroup;
      bindGroup.setResource(uniformGroup, 0);
      return bindGroup;
    }
    push(options) {
      this.bind(options);
    }
    pop() {
      this._currentGlobalUniformData = this._globalUniformDataPool.pop();
      this._updateGpuResource();
    }
    get bindGroup() {
      return this._currentGlobalUniformData.bindGroup;
    }
    get globalUniformData() {
      return this._currentGlobalUniformData;
    }
    get uniformGroup() {
      return this._currentGlobalUniformData.bindGroup.resources[0];
    }
    _createUniforms() {
      const globalUniforms = new UniformGroup({
        uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
        uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
        uResolution: { value: [0, 0], type: "vec2<f32>" }
      }, {
        isStatic: true
      });
      return globalUniforms;
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  GlobalUniformSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "globalUniforms"
  };
  "use strict";
  let saidHello = false;
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    Logger.log(`Using PixiJS Core v${VERSION} (${type}) http://www.pixijs.com/ \n `, null, "core", "value");
    saidHello = true;
  }

  "use strict";
  class HelloSystem {
    constructor(renderer) {
      this._renderer = renderer;
    }
    /**
     * It all starts here! This initiates every system, passing in the options for any system by name.
     * @param options - the config for the renderer and all its systems
     */
    init(options) {
      if (options.hello) {
        const renderer = this._renderer;
        let name = renderer.name;
        if (renderer.type === RendererType.WEBGL) {
          name += ` ${renderer.context.webGLVersion}`;
        }
        sayHello(name);
      }
    }
  }
  /** @ignore */
  HelloSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "hello",
    priority: -2
  };
  /** The default options for the system. */
  HelloSystem.defaultOptions = {
    /** {@link WebGLOptions.hello} */
    hello: false
  };

  "use strict";
  function cleanHash(hash) {
    let clean = false;
    for (const i in hash) {
      if (hash[i] == void 0) {
        clean = true;
        break;
      }
    }
    if (!clean)
      return hash;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for (const i in hash) {
      const value = hash[i];
      if (value) {
        cleanHash2[i] = value;
      }
    }
    return cleanHash2;
  }

  "use strict";
  var __defProp$c = Object.defineProperty;
  var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
  var __hasOwnProp$c = Object.prototype.hasOwnProperty;
  var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$c = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    if (__getOwnPropSymbols$c)
      for (var prop of __getOwnPropSymbols$c(b)) {
        if (__propIsEnum$c.call(b, prop))
          __defNormalProp$c(a, prop, b[prop]);
      }
    return a;
  };
  class ViewSystem {
    /**
     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
     * @member {boolean}
     */
    get autoDensity() {
      return this.texture._source.autoDensity;
    }
    set autoDensity(value) {
      this.texture._source.autoDensity = value;
    }
    /** The resolution / device pixel ratio of the renderer. */
    get resolution() {
      return this.texture.source._resolution;
    }
    set resolution(value) {
      const texture = this.texture;
      const source = texture._source;
      source.resize(
        source.width,
        source.height,
        value
      );
    }
    /**
     * initiates the view system
     * @param options - the options for the view
     */
    init(options) {
      options = __spreadValues$c(__spreadValues$c({}, ViewSystem.defaultOptions), options);
      this.screen = new Rectangle(0, 0, options.width, options.height);
      this.canvas = options.canvas;
      this.antialias = !!options.antialias;
      this.texture = options.texture;
      this.renderTarget = new RenderTarget({
        colorTextures: [this.texture._source],
        depth: !!options.depth,
        isRoot: true
      });
      this.texture._source.transparent = options.backgroundAlpha < 1;
      this.resolution = options.resolution;
    }
    /**
     * Resizes the screen and canvas to the specified dimensions.
     * @param desiredScreenWidth - The new width of the screen.
     * @param desiredScreenHeight - The new height of the screen.
     * @param resolution
     */
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      const texture = this.texture;
      const screen = this.screen;
      const frame = texture.frame;
      texture._source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      if (frame.width !== desiredScreenWidth || frame.height !== desiredScreenHeight) {
        frame.width = desiredScreenWidth;
        frame.height = desiredScreenHeight;
        texture.updateUvs();
      }
      screen.width = desiredScreenWidth
      screen.height = desiredScreenHeight;
    }
    /**
     * Destroys this System and optionally removes the canvas from the dom.
     * @param {options | false} options - The options for destroying the view, or "false".
     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
     */
    destroy(options = false) {
      const removeView = typeof options === "boolean" ? options : !!(options == null ? void 0 : options.removeView);
      if (removeView && this.canvas.parentNode) {
        this.canvas.parentNode.removeChild(this.canvas);
      }
    }
  };
  /** @ignore */
  ViewSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "view",
    priority: 0
  };
  /** The default options for the view system. */
  ViewSystem.defaultOptions = {
    /**
     * {@link WebGLOptions.width}
     * @default 800
     */
    width: 800,
    /**
     * {@link WebGLOptions.height}
     * @default 600
     */
    height: 600,
    /**
     * {@link WebGLOptions.autoDensity}
     * @default false
     */
    autoDensity: false,
    /**
     * {@link WebGLOptions.antialias}
     * @default false
     */
    antialias: false
  };

  "use strict";
  const SharedSystems = [
    BackgroundSystem,
    GlobalUniformSystem,
    HelloSystem,
    ViewSystem,
    RenderGroupSystem,
  ];
  const SharedRenderPipes = [
    BlendModePipe,
    BatcherPipe,
    SpritePipe,
    RenderGroupPipe,
    AlphaMaskPipe,
    StencilMaskPipe,
    ColorMaskPipe,
    CustomRenderPipe
  ];

  "use strict";
  const DefaultWebGLSystems = [
    ...SharedSystems,
    GlUboSystem,
    GlBackBufferSystem,
    GlContextSystem,
    GlLimitsSystem,
    GlBufferSystem,
    GlTextureSystem,
    GlRenderTargetSystem,
    GlGeometrySystem,
    GlUniformGroupSystem,
    GlShaderSystem,
    GlEncoderSystem,
    GlStateSystem,
    GlStencilSystem,
    GlColorMaskSystem
  ];
  const DefaultWebGLPipes = [...SharedRenderPipes];
  const DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
  const systems$1 = [];
  const renderPipes$1 = [];
  const renderPipeAdaptors$1 = [];
  extensions.handleByNamedList(ExtensionType.WebGLSystem, systems$1);
  extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes$1);
  extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors$1);
  extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
  class WebGLRenderer extends AbstractRenderer {
    constructor() {
      const systemConfig = {
        name: "webgl",
        type: RendererType.WEBGL,
        systems: systems$1,
        renderPipes: renderPipes$1,
        renderPipeAdaptors: renderPipeAdaptors$1
      };
      super(systemConfig);
    }
  }

  var WebGLRenderer$1 = {
    __proto__: null,
    WebGLRenderer: WebGLRenderer
  };

  "use strict";

  const GPU_GROUP = {
    entries: [],
    layout: null
  }

  class GpuResource {
    constructor() {
      this.reset();
    }
    reset() {
      this.buffer = null;
      this.offset = 0;
      this.size = 0;
    }
  }

  const GpuResourcePool = createPool("GpuResourcePool", GpuResource);

  class GpuEntries {
    constructor() {
      this.reset();
    }
    reset() {
      this.binding = null;
      if (this.resource && this.resource.reset) GpuResourcePool.return(this.resource);
      this.resource = null;
    }
    set(binding, resource) {
      this.binding = binding;
      this.resource = resource;
    }
  }

  const GpuEntriesPool = createPool("GpuEntriesPool", GpuEntries);

  const GpuBindGroupTypeHash = {
    uniformGroup: 0,
    buffer: 1,
    bufferResource: 2,
    textureSampler: 3,
    textureSource: 4,
    __proto__: null
  }

  class BindGroupSystem {
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    /**
     * @param {BindGroup} bindGroup 
     * @param {Object} program 
     * @param {number} groupIndex 
     * @returns  
     */
    getBindGroup(bindGroup, program, groupIndex) {
      bindGroup._update();
      let gpuBindGroup = bindGroup._gpuBindGroup;
      if (!gpuBindGroup) {
        gpuBindGroup = this._createBindGroup(bindGroup, program, groupIndex);
      }
      return gpuBindGroup;
    }
    _createBindGroup(group, program, groupIndex) {
      const device = this._gpu.device;
      const groupLayout = program.layout[groupIndex];
      const entries = GPU_GROUP.entries;
      for (let i = 0; i < entries.length; i++) {
        GpuEntriesPool.return(entries[i]);
      }
      entries.length = 0;
      let count = 0;
      const renderer = this._renderer;
      const resources = group.resources;
      for (let j = 0; j < groupLayout.length; j++) {
        const resource = resources[j];
        let gpuResource = null;
        const resourceType = GpuBindGroupTypeHash[resource._resourceType];
        select: switch (resourceType) {
          case 0: {
            const uniformGroup = resource;
            renderer.ubo.updateUniformGroup(uniformGroup);
            gpuResource = GpuResourcePool.get();
            const buffer = uniformGroup.buffer;
            gpuResource.buffer = renderer.buffer.getGPUBuffer(buffer);
            gpuResource.offset = 0;
            gpuResource.size = buffer.descriptor.size;
            break select;
          }
          case 1: {
            const buffer = resource;
            gpuResource = GpuResourcePool.get();
            gpuResource.buffer = renderer.buffer.getGPUBuffer(buffer);
            gpuResource.offset = 0;
            gpuResource.size = buffer.descriptor.size;
            break select;
          }
          case 2: {
            const bufferResource = resource;
            gpuResource = GpuResourcePool.get();
            gpuResource.buffer = renderer.buffer.getGPUBuffer(bufferResource.buffer);
            gpuResource.offset = bufferResource.offset;
            gpuResource.size = bufferResource.size;
            break select;
          }
          case 3: {
            gpuResource = resource.gpuSampler || resource.initGpuSampler();
            break select;
          }
          case 4: {
            let view = resource.gpuTextureView;
            if (view === null) {
              renderer.texture.getGpuSource(resource);
              view = resource.gpuTextureView;
            }
            gpuResource = view;
            break select;
          }
        }
        const entriy = GpuEntriesPool.get();
        entriy.set(groupLayout[j], gpuResource);
        entries[count++] = entriy;
      }
      const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
      GPU_GROUP.layout = layout;
      const gpuBindGroup = group._gpuBindGroup = device.createBindGroup(GPU_GROUP);
      return gpuBindGroup;
    }
    destroy() {
      this._renderer = null;
    }
  }
  /** @ignore */
  BindGroupSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "bindGroup"
  };

  "use strict";
  class GpuBufferSystem {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    getGPUBuffer(buffer) {
      return buffer._gpuBuffer || this.createGPUBuffer(buffer);
    }
    updateBuffer(buffer) {
      const gpuBuffer = this.getGPUBuffer(buffer);
      const data = buffer._data;
      if (buffer._updateID && data) {
        buffer._updateID = 0;
        this._gpu.device.queue.writeBuffer(
          gpuBuffer,
          0,
          data.buffer,
          0,
          // round to the nearest 4 bytes
          (buffer._updateSize || data.byteLength) + 3 & ~3
        );
      }
      return gpuBuffer;
    }
    createGPUBuffer(buffer) {
      if (!buffer.listenerThis) {
        buffer.on("update", this.updateBuffer, this);
        buffer.on("change", this.onBufferChange, this);
        buffer.on("destroy", this._destroyBuffer, this);
        buffer.listenerThis = true;
      }
      const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
      buffer._updateID = 0;
      if (buffer._data) {
        fastCopy(buffer._data.buffer, gpuBuffer.getMappedRange());
        gpuBuffer.unmap();
      }
      buffer._gpuBuffer = gpuBuffer;
      return gpuBuffer;
    }
    onBufferChange(buffer) {
      const gpuBuffer = buffer._gpuBuffer;
      if (gpuBuffer) gpuBuffer.destroy();
      this.createGPUBuffer(buffer);
    }
    destroy() {
      //nothing
    }
    _destroyBuffer(buffer) {
      const gpuBuffer = buffer._gpuBuffer;
      if (gpuBuffer) gpuBuffer.destroy();
      buffer.off("update", this.updateBuffer, this);
      buffer.off("change", this.onBufferChange, this);
      buffer.off("destroy", this.onBufferDestroy, this);
      buffer._gpuBuffer = null;
    }
  }
  /** @ignore */
  GpuBufferSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "buffer"
  };

  "use strict";
  async function GpuReadBuffer(buffer, renderer) {
    const bufferSize = buffer.descriptor.size;
    const device = renderer.gpu.device;
    const stagingBuffer = new Buffer({
      data: new Float32Array(24e5),
      usage: BufferUsage.MAP_READ | BufferUsage.COPY_DST
    });
    const stagingGPUBuffer = renderer.buffer.createGPUBuffer(stagingBuffer);
    const commandEncoder = device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(
      renderer.buffer.getGPUBuffer(buffer),
      0,
      // Source offset
      stagingGPUBuffer,
      0,
      // Destination offset
      bufferSize
    );
    GPU_TEXTUREOPTIONS.BUFFER[0] = commandEncoder.finish();
    device.queue.submit(GPU_TEXTUREOPTIONS.BUFFER);
    await stagingGPUBuffer.mapAsync(
      GPUMapMode.READ,
      0,
      // Offset
      bufferSize
      // Length
    )
    stagingGPUBuffer.getMappedRange(0, bufferSize);
    stagingGPUBuffer.unmap();
  }

  "use strict";
  class UboBatch {
    constructor({ minUniformOffsetAlignment }) {
      this._minUniformOffsetAlignment = 256;
      this.byteIndex = 0;
      this._minUniformOffsetAlignment = minUniformOffsetAlignment;
      this.data = new Float32Array(65535);
    }
    clear() {
      this.byteIndex = 0;
    }
    addEmptyGroup(size) {
      if (size > this._minUniformOffsetAlignment / 4) {
        throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
      }
      const start = this.byteIndex;
      let newSize = start + size * 4;
      newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
      if (newSize > this.data.length * 4) {
        throw new Error("UniformBufferBatch: ubo batch got too big");
      }
      this.byteIndex = newSize;
      return start;
    }
    addGroup(array) {
      const offset = this.addEmptyGroup(array.length);
      const data = this.data;
      for (let i = 0; i < array.length; i++) {
        data[offset / 4 + i] = array[i];
      }
      return offset;
    }
    destroy() {
      this._buffer.destroy();
      this._buffer = null;
      this.data = null;
    }
  }

  "use strict";
  class GpuColorMaskSystem {
    constructor(renderer) {
      this._colorMaskCache = 15;
      this._renderer = renderer;
    }
    setMask(colorMask) {
      if (this._colorMaskCache === colorMask)
        return;
      this._colorMaskCache = colorMask;
      this._renderer.pipeline.setColorMask(colorMask);
    }
    destroy() {
      this._renderer = null;
      this._colorMaskCache = null;
    }
  }
  /** @ignore */
  GpuColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "colorMask"
  };

  "use strict";
  class GpuDeviceSystem {
    /**
     * @param {WebGPURenderer} renderer - The renderer this System works for.
     */
    constructor(renderer) {
      this._renderer = renderer;
    }
    async init(options) {
      await this._createDeviceAndAdaptor(options);
    }
    /**
     * Handle the context change event
     * @param gpu
     */
    contextChange(gpu) {
      this._renderer.gpu = gpu;
    }
    /**
     * Helper class to create a WebGPU Context
     * @param {object} options - An options object that gets passed in to the canvas element containing the
     *    context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @returns {WebGPUContext} the WebGPU context
     */
    async _createDeviceAndAdaptor(options) {
      const adapter = await navigator.gpu.requestAdapter({
        powerPreference: options.powerPreference,
        forceFallbackAdapter: options.forceFallbackAdapter
      });
      const requiredFeatures = [
        "texture-compression-bc",
        "texture-compression-astc",
        "texture-compression-etc2"
      ].filter((feature) => adapter.features.has(feature));
      const device = await adapter.requestDevice({
        requiredFeatures
      });
      device.lost.then((info) => {
        Logger.error(`WebGPU device was lost: ${info.message}`);
        Engine.deactive();
        globalThis.alert("device lost,please check your browser and try again");
      });
      const gpu = { adapter, device };
      this._renderer.runners.contextChange.emit(gpu);
    }
    destroy() {
      this.gpu = null;
      this._renderer = null;
    }
  }
  /** @ignore */
  GpuDeviceSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "device"
  };
  /** The default options for the GpuDeviceSystem. */
  GpuDeviceSystem.defaultOptions = {
    /**
     * {@link WebGPUOptions.powerPreference}
     * @default default
     */
    powerPreference: void 0,
    /**
     * Force the use of the fallback adapter
     * @default false
     */
    forceFallbackAdapter: false
  };

  "use strict";
  function syncBindGroup(bindGroup, ubo) {
    const resources = bindGroup.resources;
    for (let j = 0; j < resources.length; j++) {
      const resource = resources[j];
      if (resource.isUniformGroup) {
        ubo.updateUniformGroup(resource);
      }
    }
  }
  class GpuEncoderSystem {
    constructor(renderer) {
      this._boundBindGroups = [];
      this._boundIndexBuffer = null;
      this._boundPipeline = null;
      this._encodeBuffer = [];
      this._boundVertexBuffers = [];
      this._renderer = renderer;
      this.renderPassEncoder = null;
    }
    onRenderStart(resolve) {
      this._resolveCommandFinished = resolve;
    }
    renderStart() {
      this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    }
    beginRenderPass(gpuRenderTarget, viewPort) {
      this.endRenderPass();
      this._clearCache();
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
      this.renderPassEncoder.setViewport(viewPort.x, viewPort.y, viewPort.width, viewPort.height, 0, 1);
    }
    endRenderPass() {
      if (this.renderPassEncoder !== null) {
        this.renderPassEncoder.end();
      }
      this.renderPassEncoder = null;
    }
    setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
      const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
      this.setPipeline(pipeline);
    }
    setPipeline(pipeline) {
      if (this._boundPipeline === pipeline) return;
      this._boundPipeline = pipeline;
      this.renderPassEncoder.setPipeline(pipeline);
    }
    _setVertexBuffer(index, buffer, renderPassEncoder, bufferSystem) {
      const boundVertexBuffers = this._boundVertexBuffers;
      if (boundVertexBuffers[index] === buffer) return;
      boundVertexBuffers[index] = buffer;
      renderPassEncoder.setVertexBuffer(index, bufferSystem.updateBuffer(buffer));
    }
    _setIndexBuffer(buffer, renderPassEncoder, bufferSystem) {
      if (this._boundIndexBuffer === buffer) return;
      this._boundIndexBuffer = buffer;
      const indexFormat = buffer._data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
      renderPassEncoder.setIndexBuffer(bufferSystem.updateBuffer(buffer), indexFormat);
    }
    setBindGroup(index, bindGroup, program, bindGroupSystem, maxBindGroups) {
      if (index > maxBindGroups) {
        Logger.error("GpuEncoderSystem: current limits of gpuBindGroups is ${maxBindGroups}, but index is ${index}");
        return;
      }
      const boundBindGroups = this._boundBindGroups;
      if (boundBindGroups[index] === bindGroup) return;
      boundBindGroups[index] = bindGroup;
      const gpuBindGroup = bindGroupSystem.getBindGroup(bindGroup, program, index);
      this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
    }
    setGeometry(geometry, program) {
      const renderer = this._renderer;
      const buffersToBind = renderer.pipeline.getBufferNamesToBind(geometry, program);
      const attributes = geometry.attributes;
      const renderPassEncoder = this.renderPassEncoder;
      const bufferSystem = renderer.buffer;
      const limits = renderer.limits;
      const maxVertexBuffers = limits.maxVertexBuffers;
      let toBindSize = buffersToBind.length;
      if (toBindSize > maxVertexBuffers) {
        Logger.error("GpuEncoderSystem: current limits of gpuBindGroups is ${maxBindGroups}, but toBindSize is ${toBindSize}");
        toBindSize = maxVertexBuffers;
      }
      for (let i = 0; i < toBindSize; i++) {
        const buffersBind = buffersToBind[i];
        this._setVertexBuffer(i, attributes[buffersBind].buffer, renderPassEncoder, bufferSystem);
      }
      if (geometry.indexBuffer) {
        this._setIndexBuffer(geometry.indexBuffer, renderPassEncoder, bufferSystem);
      }
    }
    _setShaderBindGroups(shader, skipSync = false) {
      const groups = shader.groups;
      const gpuProgram = shader.gpuProgram;
      let index = 0;
      const renderer = this._renderer;
      const ubo = renderer.ubo;
      const func = !skipSync ? syncBindGroup : Function.empty;
      const bindGroupSystem = renderer.bindGroup;
      const maxBindGroups = renderer.limits.maxBindGroups;
      for (index = 0; groups[index] !== void 0; index++) {
        const bindGroup = groups[index];
        func(bindGroup, ubo);
        this.setBindGroup(index, bindGroup, gpuProgram, bindGroupSystem, maxBindGroups);
      }
    }
    draw(options) {
      const geometry = options.geometry;
      const shader = options.shader;
      const state = options.state;
      const topology = options.topology;
      const size = options.size;
      const start = options.start;
      const instanceCount = options.instanceCount;
      const skipSync = options.skipSync;
      this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
      this.setGeometry(geometry, shader.gpuProgram);
      this._setShaderBindGroups(shader, skipSync);
      if (geometry.indexBuffer) {
        this.renderPassEncoder.drawIndexed(
          size || geometry.indexBuffer._data.length,
          instanceCount || geometry.instanceCount,
          start || 0
        );
      } else {
        this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);
      }
    }
    finishRenderPass() {
      if (this.renderPassEncoder) {
        this.renderPassEncoder.end();
        this.renderPassEncoder = null;
      }
    }
    postrender() {
      this.finishRenderPass();
      this._encodeBuffer[0] = this.commandEncoder.finish();
      this._gpu.device.queue.submit(this._encodeBuffer);
      this.commandEncoder = null;
    }
    _clearCache() {
      const limits = this._renderer.limits;
      const maxBindGroups = limits.maxBindGroups;
      const maxVertexBuffers = limits.maxVertexBuffers;
      const boundBindGroups = this._boundBindGroups;
      const boundVertexBuffers = this._boundVertexBuffers;
      for (let i = 0; i < maxBindGroups; i++) {
        boundBindGroups[i] = null;
      }
      for (let i = 0; i < maxVertexBuffers; i++) {
        boundVertexBuffers[i] = null;
      }
      this._boundIndexBuffer = null;
      this._boundPipeline = null;
    }
    destroy() {
      this._renderer = null;
      this._gpu = null;
      this._boundBindGroups = null;
      this._boundVertexBuffers = null;
      this._boundIndexBuffer = null;
      this._boundPipeline = null;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
  }
  /** @ignore */
  GpuEncoderSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "encoder",
    priority: 1
  };

  "use strict";
  class GpuStencilSystem {
    constructor(renderer) {
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(renderTarget) {
      const uid = renderTarget.uid;
      const renderTargetStencilState = this._renderTargetStencilState;
      let stencilState = renderTargetStencilState[uid];
      if (!stencilState) {
        stencilState = renderTargetStencilState[uid] = {
          stencilMode: STENCIL_MODES.DISABLED,
          stencilReference: 0
        };
      }
      this._activeRenderTarget = renderTarget;
      this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
    }
    setStencilMode(stencilMode, stencilReference) {
      const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
      stencilState.stencilMode = stencilMode;
      stencilState.stencilReference = stencilReference;
      const renderer = this._renderer;
      renderer.pipeline.setStencilMode(stencilMode);
      renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
    }
    destroy() {
      this._renderer.renderTarget.onRenderTargetChange.remove(this);
      this._renderer = null;
      this._activeRenderTarget = null;
      this._renderTargetStencilState = null;
    }
  }
  /** @ignore */
  GpuStencilSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "stencil"
  };

  "use strict";
  const WGSL_ALIGN_SIZE_DATA = {
    i32: { align: 4, size: 4 },
    u32: { align: 4, size: 4 },
    f32: { align: 4, size: 4 },
    f16: { align: 2, size: 2 },
    "vec2<i32>": { align: 8, size: 8 },
    "vec2<u32>": { align: 8, size: 8 },
    "vec2<f32>": { align: 8, size: 8 },
    "vec2<f16>": { align: 4, size: 4 },
    "vec3<i32>": { align: 16, size: 12 },
    "vec3<u32>": { align: 16, size: 12 },
    "vec3<f32>": { align: 16, size: 12 },
    "vec3<f16>": { align: 8, size: 6 },
    "vec4<i32>": { align: 16, size: 16 },
    "vec4<u32>": { align: 16, size: 16 },
    "vec4<f32>": { align: 16, size: 16 },
    "vec4<f16>": { align: 8, size: 8 },
    "mat2x2<f32>": { align: 8, size: 16 },
    "mat2x2<f16>": { align: 4, size: 8 },
    "mat3x2<f32>": { align: 8, size: 24 },
    "mat3x2<f16>": { align: 4, size: 12 },
    "mat4x2<f32>": { align: 8, size: 32 },
    "mat4x2<f16>": { align: 4, size: 16 },
    "mat2x3<f32>": { align: 16, size: 32 },
    "mat2x3<f16>": { align: 8, size: 16 },
    "mat3x3<f32>": { align: 16, size: 48 },
    "mat3x3<f16>": { align: 8, size: 24 },
    "mat4x3<f32>": { align: 16, size: 64 },
    "mat4x3<f16>": { align: 8, size: 32 },
    "mat2x4<f32>": { align: 16, size: 32 },
    "mat2x4<f16>": { align: 8, size: 16 },
    "mat3x4<f32>": { align: 16, size: 48 },
    "mat3x4<f16>": { align: 8, size: 24 },
    "mat4x4<f32>": { align: 16, size: 64 },
    "mat4x4<f16>": { align: 8, size: 32 }
  };
  function createUboElementsWGSL(uniformData) {
    const uboElements = [];
    for (let i = 0; i < uniformData.length; i++) {
      const data = uniformData[i];
      uboElements[i] = {
        data,
        offset: 0,
        size: 0
      };
    }
    let offset = 0;
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      const type = uboElement.data.type;
      const uboData = uboElement.data;
      const data = WGSL_ALIGN_SIZE_DATA[type];
      let size = data.size;
      const align = data.align;
      if (!data) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${type}`);
      }
      if (uboData.size > 1) {
        size = Math.max(size, align) * uboData.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }

  "use strict";
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }

  "use strict";
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }

  "use strict";
  class GpuUboSystem extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsWGSL,
        generateUboSync: createUboSyncFunctionWGSL
      });
    }
  }
  /** @ignore */
  GpuUboSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "ubo"
  };

  "use strict";
  const minUniformOffsetAlignment = 128;
  class GpuUniformBatchPipe {
    constructor(renderer) {
      this._bindGroupHash = new Set();
      // number of buffers..
      this._buffers = [];
      this._bindGroups = [];
      this._bufferResources = [];
      this._renderer = renderer;
      this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
      const totalBuffers = 256 / minUniformOffsetAlignment;
      const buffers = this._buffers;
      const batchBufferData = this._batchBuffer.data;
      for (let i = 0; i < totalBuffers; i++) {
        let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
        if (i === 0) usage |= BufferUsage.COPY_SRC;
        buffers[i] = new Buffer({
          data: batchBufferData,
          usage
        });
      }
    }
    renderEnd() {
      this._uploadBindGroups();
      this._resetBindGroups();
    }
    _resetBindGroups() {
      this._bindGroupHash.clear();
      this._batchBuffer.clear();
    }
    // just works for single bind groups for now
    getUniformBindGroup(group, duplicate) {
      if (!duplicate && this._bindGroupHash.has(group.uid)) {
        return group._bindGroup;
      }
      this._bindGroupHash.add(group.uid);
      const uboSystem = this._renderer.ubo;
      uboSystem.ensureUniformGroup(group);
      const data = group.buffer._data;
      const batchBuffer = this._batchBuffer;
      const offset = batchBuffer.addEmptyGroup(data.length);
      uboSystem.syncUniformGroup(group, batchBuffer.data, offset / 4);
      group._bindGroup = this._getBindGroup(offset / minUniformOffsetAlignment);
      return group._bindGroup;
    }
    getUboResource(group) {
      this._renderer.ubo.updateUniformGroup(group);
      const data = group.buffer._data;
      const offset = this._batchBuffer.addGroup(data);
      return this._getBufferResource(offset / minUniformOffsetAlignment);
    }
    getArrayBindGroup(data) {
      const offset = this._batchBuffer.addGroup(data);
      return this._getBindGroup(offset / minUniformOffsetAlignment);
    }
    getArrayBufferResource(data) {
      const offset = this._batchBuffer.addGroup(data);
      const index = offset / minUniformOffsetAlignment;
      return this._getBufferResource(index);
    }
    _getBufferResource(index) {
      const bufferResources = this._bufferResources;
      if (!bufferResources[index]) {
        const buffer = this._buffers[index % 2];
        bufferResources[index] = new BufferResource({
          buffer,
          offset: (index / 2 | 0) * 256,
          size: minUniformOffsetAlignment
        });
      }
      return bufferResources[index];
    }
    _getBindGroup(index) {
      const bindGroups = this._bindGroups;
      if (!bindGroups[index]) {
        const bindGroup = new BindGroup({
          0: this._getBufferResource(index)
        });
        bindGroups[index] = bindGroup;
      }
      return bindGroups[index];
    }
    _uploadBindGroups() {
      const renderer = this._renderer;
      const bufferSystem = renderer.buffer;
      const buffers = this._buffers;
      const firstBuffer = buffers[0];
      const batchBuffer = this._batchBuffer;
      const byteIndex = batchBuffer.byteIndex;
      firstBuffer.update(byteIndex);
      bufferSystem.updateBuffer(firstBuffer);
      const device = renderer.gpu.device;
      const commandEncoder = device.createCommandEncoder();
      for (let i = 1; i < buffers.length; i++) {
        const buffer = buffers[i];
        commandEncoder.copyBufferToBuffer(
          bufferSystem.getGPUBuffer(firstBuffer),
          minUniformOffsetAlignment,
          bufferSystem.getGPUBuffer(buffer),
          0,
          byteIndex
        );
      }
      GPU_TEXTUREOPTIONS.BUFFER[0] = commandEncoder.finish();
      device.queue.submit(GPU_TEXTUREOPTIONS.BUFFER);
    }
    destroy() {
      const bindGroups = this._bindGroups;
      for (let i = 0; i < bindGroups.length; i++) {
        bindGroups[i].destroy();
      }
      this._bindGroups = null;
      this._bindGroupHash = null;
      const buffers = this._buffers;
      for (let i = 0; i < buffers.length; i++) {
        buffers[i].destroy();
      }
      this._buffers = null;
      const bufferResources = this._bufferResources;
      for (let i = 0; i < bufferResources.length; i++) {
        bufferResources[i].destroy();
      }
      this._bufferResources = null;
      this._batchBuffer.destroy();
      this._renderer = null;
    }
  }
  /** @ignore */
  GpuUniformBatchPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "uniformBatch"
  };

  "use strict";
  var __defProp$a = Object.defineProperty;
  var __defProps$6 = Object.defineProperties;
  var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
  var __hasOwnProp$a = Object.prototype.hasOwnProperty;
  var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$a = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    if (__getOwnPropSymbols$a)
      for (var prop of __getOwnPropSymbols$a(b)) {
        if (__propIsEnum$a.call(b, prop))
          __defNormalProp$a(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
  const topologyStringToId = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
  };
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }

  class PipelineSystem {
    constructor(renderer) {
      this._moduleCache = /* @__PURE__ */ Object.create(null);
      this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
      this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
      this._pipeCache = /* @__PURE__ */ Object.create(null);
      this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
      this._colorMask = 15;
      this._multisampleCount = 1;
      this._renderer = renderer;
    }
    contextChange(gpu) {
      this._gpu = gpu;
      this.setStencilMode(STENCIL_MODES.DISABLED);
      this._updatePipeHash();
    }
    setMultisampleCount(multisampleCount) {
      if (this._multisampleCount === multisampleCount)
        return;
      this._multisampleCount = multisampleCount;
      this._updatePipeHash();
    }
    setRenderTarget(renderTarget) {
      this._multisampleCount = renderTarget.msaaSamples;
      this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
      this._updatePipeHash();
    }
    setColorMask(colorMask) {
      if (this._colorMask === colorMask)
        return;
      this._colorMask = colorMask;
      this._updatePipeHash();
    }
    setStencilMode(stencilMode) {
      if (this._stencilMode === stencilMode)
        return;
      this._stencilMode = stencilMode;
      this._stencilState = GpuStencilModesToPixi[stencilMode];
      this._updatePipeHash();
    }
    setPipeline(geometry, program, state, passEncoder) {
      const pipeline = this.getPipeline(geometry, program, state);
      passEncoder.setPipeline(pipeline);
    }
    getPipeline(geometry, program, state, topology) {
      if (!geometry._layoutKey) {
        ensureAttributes(geometry, program.attributeData);
        this._generateBufferKey(geometry);
      }
      topology = topology || geometry.topology;
      const key = getGraphicsStateKey(
        geometry._layoutKey,
        program._layoutKey,
        state.data,
        state._blendModeId,
        topologyStringToId[topology]
      );
      const pipeCache = this._pipeCache;
      if (pipeCache[key]) return pipeCache[key];
      pipeCache[key] = this._createPipeline(geometry, program, state, topology)
      return pipeCache[key];
    }
    _createPipeline(geometry, program, state, topology) {
      const device = this._gpu.device;
      const buffers = this._createVertexBufferLayouts(geometry, program);
      const renderer = this._renderer;
      const blendModes = renderer.state.getColorTargets(state);
      blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
      const layout = renderer.shader.getProgramData(program).pipeline;
      const descriptor = GPU_TEXTUREOPTIONS.PIPELINE;
      const vertex = descriptor.vertex;
      const fragment = descriptor.fragment;
      const primitive = descriptor.primitive;
      vertex.module = this._getModule(program.vertex.source);
      vertex.entryPoint = program.vertex.entryPoint;
      vertex.buffers = buffers;
      fragment.module = this._getModule(program.fragment.source);
      fragment.entryPoint = program.fragment.entryPoint;
      fragment.targets = blendModes;
      primitive.topology = topology;
      primitive.cullMode = state.cullMode;
      descriptor.layout = layout;
      descriptor.multisample.count = this._multisampleCount;
      if (this._depthStencilAttachment) {
        descriptor.depthStencil = __spreadProps$6(__spreadValues$a({}, this._stencilState), {
          format: "depth24plus-stencil8",
          depthWriteEnabled: state.depthTest,
          depthCompare: state.depthTest ? "less" : "always"
        });
      }
      //  
      return device.createRenderPipeline(descriptor);
    }
    _getModule(code) {
      return this._moduleCache[code] || this._createModule(code);
    }
    _createModule(code) {
      const device = this._gpu.device;
      this._moduleCache[code] = device.createShaderModule({
        code
      });
      return this._moduleCache[code];
    }
    _generateBufferKey(geometry) {
      const keyGen = [];
      let index = 0;
      const attributeKeys = Object.keys(geometry.attributes).sort();
      for (let i = 0; i < attributeKeys.length; i++) {
        const attribute = geometry.attributes[attributeKeys[i]];
        keyGen[index++] = attribute.offset;
        keyGen[index++] = attribute.format;
        keyGen[index++] = attribute.stride;
        keyGen[index++] = attribute.instance;
      }
      const stringKey = keyGen.join("|");
      geometry._layoutKey = createIdFromString(stringKey, "geometry");
      return geometry._layoutKey;
    }
    _generateAttributeLocationsKey(program) {
      let stringKey = "";
      const attributeData = program.attributeData;
      for (const key in attributeData) {
        const attribute = attributeData[key];
        stringKey += `${attribute.location}|${attribute.format}|${key}`;
      }
      program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
      return program._attributeLocationsKey;
    }
    /**
     * Returns a hash of buffer names mapped to bind locations.
     * This is used to bind the correct buffer to the correct location in the shader.
     * @param geometry - The geometry where to get the buffer names
     * @param program - The program where to get the buffer names
     * @returns An object of buffer names mapped to the bind location.
     */
    getBufferNamesToBind(geometry, program) {
      const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
      if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];
      const data = this._createVertexBufferLayouts(geometry, program);
      const bufferNamesToBind = [];//Object.create(null);
      const attributeData = program.attributeData;
      for (let i = 0; i < data.length; i++) {
        const attributes = data[i].attributes;
        attributeloop: for (const key in attributes) {
          const firstValue = attributes[key];
          const shaderLocation = firstValue.shaderLocation;
          attributeDataloop: for (const j in attributeData) {
            if (attributeData[j].location === shaderLocation) {
              bufferNamesToBind[i] = j;
              break attributeDataloop;
            }
          }
          break attributeloop;
        }
      }
      this._bindingNamesCache[key] = bufferNamesToBind;
      return bufferNamesToBind;
    }
    _createVertexBufferLayouts(geometry, program) {
      if (!program._attributeLocationsKey)
        this._generateAttributeLocationsKey(program);
      const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
      if (this._bufferLayoutsCache[key]) {
        return this._bufferLayoutsCache[key];
      }
      const buffers = geometry.buffers;
      const vertexBuffersLayout = [];
      for (let j = 0; j < buffers.length; j++) {
        const buffer = buffers[j];
        var _a;
        const bufferEntry = {
          arrayStride: 0,
          stepMode: "vertex",
          attributes: []
        };
        const bufferEntryAttributes = bufferEntry.attributes;
        let index = 0;
        for (const i in program.attributeData) {
          const attribute = geometry.attributes[i];
          if (((_a = attribute.divisor) != null ? _a : 1) !== 1) {
            Logger.warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
          }
          if (attribute.buffer === buffer) {
            bufferEntry.arrayStride = attribute.stride;
            bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
            bufferEntryAttributes[index++] = {
              shaderLocation: program.attributeData[i].location,
              offset: attribute.offset,
              format: attribute.format
            };
          }
        }
        if (bufferEntryAttributes.length) {
          vertexBuffersLayout[vertexBuffersLayout.length] = bufferEntry;
        }
      }
      this._bufferLayoutsCache[key] = vertexBuffersLayout;
      return vertexBuffersLayout;
    }
    _updatePipeHash() {
      const key = getGlobalStateKey(
        this._stencilMode,
        this._multisampleCount,
        this._colorMask,
        this._depthStencilAttachment
      );
      let pipeCache = this._pipeStateCaches[key];
      if (pipeCache === void 0) {
        pipeCache = this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
      }
      this._pipeCache = pipeCache;
    }
    destroy() {
      this._renderer = null;
      this._bufferLayoutsCache = null;
    }
  }
  /** @ignore */
  PipelineSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "pipeline"
  };

  "use strict";
  class GpuRenderTarget {
    constructor() {
      this.contexts = [];
      this.msaaTextures = [];
      this.msaaSamples = 1;
    }
  }

  "use strict";
  const GPU_TEXTUREOPTIONS = {
    SOURCE: {
      texture: null,
      origin: new Point()
    },
    TARGET: {
      texture: null,
      origin: new Point()
    },
    BUFFER: [],
    CANVAS: {
      device: null,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      format: "bgra8unorm",
      alphaMode: 0
    },
    VIEW: {
      mipLevelCount: 1
    },
    DESCRIPTOR: {
      colorAttachments: [],
    },
    DEPTH: {
      colorAttachments: [],
      depthStencilAttachment: {
        view: null,
        stencilStoreOp: "store",
        stencilLoadOp: "clear",
        depthClearValue: 1,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    },
    PIPELINE: {
      vertex: {
        module: null,
        entryPoint: "",
        buffers: null,
      },
      fragment: {
        module: null,
        entryPoint: "",
        targets: null
      },
      primitive: {
        topology: 0,
        cullMode: "none"
      },
      layout: null,
      multisample: {
        count: 1
      },
      label: "PIXI Pipeline"
    }
  }
  class GpuDescriptor {
    constructor() {
      this.reset();
    }
    reset() {
      this.view = null;
      this.resolveTarget = null;
      this.clearValue = null;
      this.storeOp = "store";
      this.loadOp = "clear";
    }
    set(view, resolveTarget, clearValue, storeOp, loadOp) {
      this.view = view;
      this.resolveTarget = resolveTarget;
      this.clearValue = clearValue;
      this.storeOp = storeOp;
      this.loadOp = loadOp;
    }
  }
  const GpuDescriptorPool = createPool("GpuDescriptorPool", GpuDescriptor, 100);
  function initGpuRenderView(device, contexts, colorTextures, msaaTextures, gpuRenderTarget, index) {
    const colorTexture = colorTextures[index];
    const resource = colorTexture.resource;
    if (!resource || !resource.isCanvas) return;
    const context = resource.getContext("webgpu");
    const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
    GPU_TEXTUREOPTIONS.CANVAS.device = device;
    GPU_TEXTUREOPTIONS.CANVAS.alphaMode = alphaMode;
    try {
      context.configure(GPU_TEXTUREOPTIONS.CANVAS);
    } catch (e) {
      Logger.error(e);
    }
    contexts[index] = context;
    gpuRenderTarget.msaa = colorTexture.antialias;
    if (colorTexture.antialias) {
      const msaaTexture = new TextureSource();
      msaaTexture.setupOptions({
        width: 0,
        height: 0,
        sampleCount: 4
      });
      msaaTextures[index] = msaaTexture;
    }
  }
  function getGpuDescriptor(colorTextures, contexts, msaaTextures, colorAttachments, i, clearValue, textureSystem, clear) {
    const texture = colorTextures[i];
    const context = contexts[i];
    let view;
    let resolveTarget;
    if (context) {
      const currentTexture = context.getCurrentTexture();
      const canvasTextureView = currentTexture.createView();
      view = canvasTextureView;
    } else {
      view = textureSystem.getGpuSource(texture).createView(GPU_TEXTUREOPTIONS.VIEW);
    }
    const msaaTexture = msaaTextures[i];
    if (msaaTexture) {
      resolveTarget = view;
      view = textureSystem.getTextureView(msaaTexture);
    }
    const options = colorAttachments[i] || GpuDescriptorPool.get();
    options.set(view, resolveTarget, clearValue, "store", clear);
    colorAttachments[i] = options;
  }
  class GpuRenderTargetAdaptor {
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderer = this._renderer;
      const baseGpuTexture = this._getGpuColorTexture(
        sourceRenderSurfaceTexture
      );
      const backGpuTexture = renderer.texture.getGpuSource(
        destinationTexture._source
      );
      GPU_TEXTUREOPTIONS.TARGET.texture = baseGpuTexture;
      GPU_TEXTUREOPTIONS.TARGET.origin.copyFrom(originSrc);
      GPU_TEXTUREOPTIONS.SOURCE.texture = backGpuTexture;
      GPU_TEXTUREOPTIONS.SOURCE.origin.copyFrom(originDest);
      renderer.encoder.commandEncoder.copyTextureToTexture(
        GPU_TEXTUREOPTIONS.TARGET, GPU_TEXTUREOPTIONS.SOURCE,
        size
      );
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = "clear", clearColor, viewport) {
      const renderTargetSystem = this._renderTargetSystem;
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
      gpuRenderTarget.descriptor = descriptor;
      const renderer = this._renderer;
      renderer.pipeline.setRenderTarget(gpuRenderTarget);
      renderer.encoder.beginRenderPass(gpuRenderTarget, viewport);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    /**
     * returns the gpu texture for the first color texture in the render target
     * mainly used by the filter manager to get copy the texture for blending
     * @param renderTarget
     * @returns a gpu texture
     */
    _getGpuColorTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (gpuRenderTarget.contexts[0]) {
        return gpuRenderTarget.contexts[0].getCurrentTexture();
      }
      return this._renderer.texture.getGpuSource(
        renderTarget.colorTextures[0]
      );
    }
    getDescriptor(renderTarget, clear, clearValue) {
      const renderTargetSystem = this._renderTargetSystem;
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      const colorTextures = renderTarget.colorTextures;
      const contexts = gpuRenderTarget.contexts;
      const msaaTextures = gpuRenderTarget.msaaTextures;
      const textureSystem = this._renderer.texture;
      //const isSingle = renderTarget.isSingle;
      let colorAttachments = null, descriptor = null;
      if (renderTarget.depthStencilTexture) {
        descriptor = GPU_TEXTUREOPTIONS.DEPTH;
        colorAttachments = descriptor.colorAttachments;
        const depthStencilAttachment = descriptor.depthStencilAttachment;
        depthStencilAttachment.view = textureSystem.getGpuSource(renderTarget.depthStencilTexture).createView();
        depthStencilAttachment.stencilStoreOp = "store";
        depthStencilAttachment.stencilLoadOp = clear;
        depthStencilAttachment.depthClearValue = 1;
        depthStencilAttachment.depthLoadOp = clear;
        depthStencilAttachment.depthStoreOp = "store";
      } else {
        descriptor = GPU_TEXTUREOPTIONS.DESCRIPTOR;
        colorAttachments = descriptor.colorAttachments;
      }
      //2d
      //if (isSingle) {
      //GpuDescriptorPool.return(colorAttachments[0]);
      getGpuDescriptor(colorTextures, contexts, msaaTextures, colorAttachments, 0, clearValue, textureSystem, clear);
      /*} else {
        for (let i = 0; i < colorAttachments.length; i++) {
          GpuDescriptorPool.return(colorAttachments[i]);
        }
        for (let i = 0; i < colorTextures.length; i++) {
          getGpuDescriptor(colorTextures, contexts, msaaTextures, colorAttachments, i, clearValue, textureSystem, clear);
        }
      }*/
      clearValue != null ? clearValue : clearValue = renderTargetSystem.defaultClearColor;
      if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
        renderTarget.ensureDepthStencilTexture();
        renderTarget.depthStencilTexture.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
      }
      return descriptor;
    }
    clear(renderTarget, clear = "clear", clearColor, viewport) {
      if (!clear) return;
      const renderer = this._renderer;
      const gpu = renderer.gpu;
      const encoder = renderer.encoder;
      const device = gpu.device;
      const standAlone = encoder.commandEncoder === null;
      if (standAlone) {
        const commandEncoder = device.createCommandEncoder();
        const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        passEncoder.end();
        const gpuCommands = commandEncoder.finish();
        GPU_TEXTUREOPTIONS.BUFFER[0] = gpuCommands;
        device.queue.submit(GPU_TEXTUREOPTIONS.BUFFER);
      } else {
        this.startRenderPass(renderTarget, clear, clearColor, viewport);
      }
    }
    initGpuRenderTarget(renderTarget) {
      renderTarget.isRoot = true;
      const gpuRenderTarget = new GpuRenderTarget();
      const colorTextures = renderTarget.colorTextures;
      const contexts = gpuRenderTarget.contexts;
      const msaaTextures = gpuRenderTarget.msaaTextures;
      const device = this._renderer.gpu.device;
      const size = colorTextures.length;
      const isSingle = renderTarget.isSingle;
      if (isSingle) {
        initGpuRenderView(device, contexts, colorTextures, msaaTextures, gpuRenderTarget, 0);
      } else {
        for (let i = 0; i < size; i++) {
          initGpuRenderView(device, contexts, colorTextures, msaaTextures, gpuRenderTarget, i);
        }
      }
      if (gpuRenderTarget.msaa) {
        gpuRenderTarget.msaaSamples = 4;
        if (renderTarget.depthStencilTexture) {
          renderTarget.depthStencilTexture.sampleCount = 4;
        }
      }
      return gpuRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      const contexts = gpuRenderTarget.contexts;
      const isSingle = contexts.length === 1;
      if (isSingle) {
        contexts[0].unconfigure();
      } else {
        for (let i = 0; i < contexts.length; i++) {
          contexts[i].unconfigure();
        }
      }
      const msaaTextures = gpuRenderTarget.msaaTextures;
      if (isSingle) {
        msaaTextures[0].destroy();
      } else {
        for (let i = 0; i < msaaTextures.length; i++) {
          msaaTextures[i].destroy();
        }
      }
      gpuRenderTarget.msaaTextures.length = 0;
      gpuRenderTarget.contexts.length = 0;
    }
    ensureDepthStencilTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
        renderTarget.depthStencilTexture.sampleCount = 4;
      }
    }
    resizeGpuRenderTarget(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.width;
      gpuRenderTarget.height = renderTarget.height;
      if (gpuRenderTarget.msaa) {
        const colorTextures = renderTarget.colorTextures;
        const msaaTextures = gpuRenderTarget.msaaTextures;
        for (let i = 0; i < colorTextures.length; i++) {
          const msaaTexture = msaaTextures[i];
          if (msaaTexture) {
            const colorTexture = colorTextures[i];
            msaaTexture.resize(colorTexture.width, colorTexture.height, colorTexture.resolution);
          }
        }
      }
    }
  }

  "use strict";
  class GpuRenderTargetSystem extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GpuRenderTargetAdaptor();
      this.adaptor.init(renderer, this);
    }
  }
  /** @ignore */
  GpuRenderTargetSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "renderTarget"
  };

  "use strict";

  "use strict";
  class GpuShaderSystem {
    constructor() {
      this._gpuEntries = { entries: null };
      this._gpuPipelineLayoutDesc = { bindGroupLayouts: null };
      this._gpuProgramData = Object.create(null);
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    getProgramData(program) {
      return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
    }
    _createGPUProgramData(program) {
      const device = this._gpu.device;
      const gpuLayout = program.gpuLayout;
      const bindGroups = [];
      const entries = this._gpuEntries;
      for (let i = 0; i < gpuLayout.length; i++) {
        let group = gpuLayout[i];
        entries.entries = group;
        group = device.createBindGroupLayout(entries);
        bindGroups[i] = group;
      }
      const gpuPipelineLayoutDesc = this._gpuPipelineLayoutDesc;
      gpuPipelineLayoutDesc.bindGroupLayouts = bindGroups;
      const layoutKey = program._layoutKey;
      const programData = this._gpuProgramData;
      const data = programData[layoutKey] = {
        bindGroups,
        pipeline: device.createPipelineLayout(gpuPipelineLayoutDesc)
      };
      program.gpuLayout = null;
      return data;
    }
    destroy() {
      this._gpu = null;
      this._gpuProgramData = null;
    }
  }
  /** @ignore */
  GpuShaderSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "shader"
  };

  "use strict";
  const GpuBlendModesToPixi = {};
  GpuBlendModesToPixi.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.add = {
    alpha: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.multiply = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "dst",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.screen = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.overlay = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.none = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "zero",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["normal-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["add-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["screen-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.erase = {
    alpha: {
      srcFactor: "zero",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.min = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    }
  };
  GpuBlendModesToPixi.max = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    }
  };

  "use strict";
  class GpuStateSystem {
    constructor() {
      this.defaultState = new State();
      this.defaultState.blend = true;
      this.colorTarget = [{
        format: "bgra8unorm",
        writeMask: 0,
        blend: null
      }]
    }
    contextChange(gpu) {
      this.gpu = gpu;
    }
    /**
     * Gets the blend mode data for the current state
     * @param state - The state to get the blend mode from
     */
    getColorTargets(state) {
      const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
      this.colorTarget[0].blend = blend;
      return this.colorTarget;
    }
    destroy() {
      this.gpu = null;
    }
  }
  /** @ignore */
  GpuStateSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "state"
  };

  "use strict";
  const GPU_BUFFER_TEXTURE_UPLOAD = {
    destination: {
      texture: null,
    },
    data: null,
    dataLayout: {
      offset: 0,
      rowsPerImage: 0,
      bytesPerRow: 0,
    },
    size: {
      width: 0,
      height: 0,
      depthOrArrayLayers: 0,
    }
  }
  const gpuUploadBufferImageResource = {
    type: "image",
    upload(source, gpuTexture, gpu) {
      const resource = source.resource;
      const pw = source.pixelWidth;
      const ph = source.pixelHeight;
      const total = (pw | 0) * (ph | 0);
      const bytesPerPixel = resource.byteLength / total;
      GPU_BUFFER_TEXTURE_UPLOAD.destination.texture = gpuTexture;
      GPU_BUFFER_TEXTURE_UPLOAD.data = resource;
      const dataLayout = GPU_BUFFER_TEXTURE_UPLOAD.dataLayout;
      dataLayout.offset = 0;
      dataLayout.rowsPerImage = ph;
      dataLayout.bytesPerRow = pw * bytesPerPixel;
      const size = GPU_BUFFER_TEXTURE_UPLOAD.size;
      size.width = pw;
      sign.height = ph;
      gpu.device.queue.writeTexture(GPU_BUFFER_TEXTURE_UPLOAD);
    }
  };

  "use strict";
  const blockDataMap = {
    // ===== BC (Block Compression) =====
    "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "bc1-rgba-unorm-srgb": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc2-rgba-unorm-srgb": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc3-rgba-unorm-srgb": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc4-r-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "bc4-r-snorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "bc5-rg-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc5-rg-snorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc6h-rgb-ufloat": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc6h-rgb-float": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc7-rgba-unorm-srgb": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },

    // ===== ETC1 / ETC2 / EAC =====
    "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "etc2-rgb8unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "etc2-rgb8unorm-srgb": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "etc2-rgba8unorm-srgb": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "etc2-rgba8unorm-srgb1": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, // RGBA1 variant
    "eac-r11unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "eac-r11snorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "eac-rg11unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "eac-rg11snorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },

    // ===== ASTC (Adaptive Scalable Texture Compression) =====
    //  block 
    "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "astc-4x4-unorm-srgb": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "astc-5x4-unorm": { blockBytes: 16, blockWidth: 5, blockHeight: 4 },
    "astc-5x4-unorm-srgb": { blockBytes: 16, blockWidth: 5, blockHeight: 4 },
    "astc-5x5-unorm": { blockBytes: 16, blockWidth: 5, blockHeight: 5 },
    "astc-5x5-unorm-srgb": { blockBytes: 16, blockWidth: 5, blockHeight: 5 },
    "astc-6x5-unorm": { blockBytes: 16, blockWidth: 6, blockHeight: 5 },
    "astc-6x5-unorm-srgb": { blockBytes: 16, blockWidth: 6, blockHeight: 5 },
    "astc-6x6-unorm": { blockBytes: 16, blockWidth: 6, blockHeight: 6 },
    "astc-6x6-unorm-srgb": { blockBytes: 16, blockWidth: 6, blockHeight: 6 },
    "astc-8x5-unorm": { blockBytes: 16, blockWidth: 8, blockHeight: 5 },
    "astc-8x5-unorm-srgb": { blockBytes: 16, blockWidth: 8, blockHeight: 5 },
    "astc-8x6-unorm": { blockBytes: 16, blockWidth: 8, blockHeight: 6 },
    "astc-8x6-unorm-srgb": { blockBytes: 16, blockWidth: 8, blockHeight: 6 },
    "astc-8x8-unorm": { blockBytes: 16, blockWidth: 8, blockHeight: 8 },
    "astc-8x8-unorm-srgb": { blockBytes: 16, blockWidth: 8, blockHeight: 8 },
    "astc-10x5-unorm": { blockBytes: 16, blockWidth: 10, blockHeight: 5 },
    "astc-10x5-unorm-srgb": { blockBytes: 16, blockWidth: 10, blockHeight: 5 },
    "astc-10x6-unorm": { blockBytes: 16, blockWidth: 10, blockHeight: 6 },
    "astc-10x6-unorm-srgb": { blockBytes: 16, blockWidth: 10, blockHeight: 6 },
    "astc-10x8-unorm": { blockBytes: 16, blockWidth: 10, blockHeight: 8 },
    "astc-10x8-unorm-srgb": { blockBytes: 16, blockWidth: 10, blockHeight: 8 },
    "astc-10x10-unorm": { blockBytes: 16, blockWidth: 10, blockHeight: 10 },
    "astc-10x10-unorm-srgb": { blockBytes: 16, blockWidth: 10, blockHeight: 10 },
    "astc-12x10-unorm": { blockBytes: 16, blockWidth: 12, blockHeight: 10 },
    "astc-12x10-unorm-srgb": { blockBytes: 16, blockWidth: 12, blockHeight: 10 },
    "astc-12x12-unorm": { blockBytes: 16, blockWidth: 12, blockHeight: 12 },
    "astc-12x12-unorm-srgb": { blockBytes: 16, blockWidth: 12, blockHeight: 12 },
  };

  const defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
  const GPU_COMPRESSED_TEXTURE = {
    SOURCE: {
      texture: null,
      mipLevel: 1,
    },
    levelBuffer: null,
    TARGET: {
      offset: 0,
      bytesPerRow: 1,
    },
    SIZE: {
      width: 1,
      height: 1,
      depthOrArrayLayers: 1,
    }
  }
  const gpuUploadCompressedTextureResource = {
    type: "compressed",
    upload(source, gpuTexture, gpu) {
      let mipWidth = source.pixelWidth;
      let mipHeight = source.pixelHeight;
      const queue = gpu.device.queue;
      const blockData = blockDataMap[source.format] || defaultBlockData;
      const resource = source.resource;
      const blockWidth = blockData.blockWidth;
      const blockHeight = blockData.blockHeight;
      const blockBytes = blockData.blockBytes;
      const GS = GPU_COMPRESSED_TEXTURE.SOURCE;
      const GT = GPU_COMPRESSED_TEXTURE.TARGET;
      const SIZE = GPU_COMPRESSED_TEXTURE.SIZE;
      for (let i = 0; i < resource.length; i++) {
        const levelBuffer = resource[i];
        const bytesPerRow = Math.ceil(mipWidth / blockWidth) * blockBytes;
        GS.texture = gpuTexture;
        GS.mipLevel = i;
        GPU_COMPRESSED_TEXTURE.levelBuffer = levelBuffer;
        GT.offset = 0;
        GT.bytesPerRow = bytesPerRow;
        SIZE.width = Math.ceil(mipWidth / blockWidth) * blockWidth;
        SIZE.height = Math.ceil(mipHeight / blockHeight) * blockHeight;
        SIZE.depthOrArrayLayers = 1;
        queue.writeTexture(GS, levelBuffer, GT, SIZE);
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };

  "use strict";
  const GPU_UPLOAD = {
    source: { source: null },
    texture: {
      texture: null,
      premultipliedAlpha: false
    },
    size: {
      width: 1,
      height: 1
    }
  }
  const gpuUploadImageResource = {
    type: "image",
    upload(source, gpuTexture, gpu) {
      const resource = source.resource;
      if (!resource)
        return;
      const width = source.width;
      const height = source.height;
      const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";
      GPU_UPLOAD.source.source = resource;
      GPU_UPLOAD.texture.texture = gpuTexture;
      GPU_UPLOAD.texture.premultipliedAlpha = premultipliedAlpha;
      GPU_UPLOAD.size.width = width;
      GPU_UPLOAD.size.height = height;
      gpu.device.queue.copyExternalImageToTexture(GPU_UPLOAD.source, GPU_UPLOAD.texture, GPU_UPLOAD.size);
    }
  };

  "use strict";
  const gpuUploadVideoResource = {
    type: "video",
    upload(source, gpuTexture, gpu) {
      gpuUploadImageResource.upload(source, gpuTexture, gpu);
    }
  };

  "use strict";
  const GPU_MIPMAP = {
    DESCRIPTOR: {
      size: {
        width: 0,
        height: 0,
        depthOrArrayLayers: 0
      },
      format: null,
      usage: 0,
      mipLevelCount: 0
    },
    VIEW: {
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: "2d",
      baseArrayLayer: 0,
      arrayLayerCount: 1
    },
    PASS: {
      colorAttachments: [{
        view: null,
        storeOp: "store",
        loadOp: "clear",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    },
    GROUP: {
      layout: "",
      entries: [{
        binding: 0,
        resource: null
      }, {
        binding: 1,
        resource: null
      }]
    },
    TEXTURE: {
      source: {
        texture: null,
        mipLevel: 0
      },
      target: {
        texture: null,
        mipLevel: 0
      },
      size: {
        width: 0,
        height: 0,
        depthOrArrayLayers: 0
      }
    },
    BUFFER: []
  }
  class GpuMipmapGenerator {
    constructor(device) {
      this.device = device;
      this.sampler = device.createSampler({ minFilter: "linear" });
      this.pipelines = {};
    }
    _getMipmapPipeline(format) {
      let pipeline = this.pipelines[format];
      if (!pipeline) {
        if (!this.mipmapShaderModule) {
          this.mipmapShaderModule = this.device.createShaderModule({
            code: (
              /* wgsl */
              `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
            )
          });
        }
        pipeline = this.device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: this.mipmapShaderModule,
            entryPoint: "vertexMain"
          },
          fragment: {
            module: this.mipmapShaderModule,
            entryPoint: "fragmentMain",
            targets: [{ format }]
          }
        });
        this.pipelines[format] = pipeline;
      }
      return pipeline;
    }
    /**
     * Generates mipmaps for the given GPUTexture from the data in level 0.
     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
     * @returns {module:External.GPUTexture} - The originally passed texture
     */
    generateMipmap(texture) {
      const pipeline = this._getMipmapPipeline(texture.format);
      if (texture.dimension === "3d" || texture.dimension === "1d") {
        throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
      }
      let mipTexture = texture;
      const arrayLayerCount = texture.depthOrArrayLayers || 1;
      const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      const device = this.device;
      if (!renderToSource) {
        GPU_MIPMAP.DESCRIPTOR.size.width = Math.ceil(texture.width / 2);
        GPU_MIPMAP.DESCRIPTOR.size.height = Math.ceil(texture.height / 2);
        GPU_MIPMAP.DESCRIPTOR.size.depthOrArrayLayers = arrayLayerCount;
        GPU_MIPMAP.DESCRIPTOR.format = texture.format;
        GPU_MIPMAP.DESCRIPTOR.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT;
        GPU_MIPMAP.DESCRIPTOR.mipLevelCount = texture.mipLevelCount - 1;
        mipTexture = device.createTexture(GPU_MIPMAP.DESCRIPTOR);
      }
      const commandEncoder = device.createCommandEncoder(Object.empty);
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const VIEW = GPU_MIPMAP.VIEW;
      const PASS = GPU_MIPMAP.PASS;
      const GROUP = GPU_MIPMAP.GROUP;
      GROUP.layout = bindGroupLayout;
      for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
        VIEW.baseMipLevel = 0;
        VIEW.baseArrayLayer = arrayLayer;
        VIEW.arrayLayerCount = 1;
        VIEW.baseMipLevel = 0;
        let srcView = texture.createView(VIEW);
        let dstMipLevel = renderToSource ? 1 : 0;
        for (let i = 1; i < texture.mipLevelCount; ++i) {
          VIEW.baseMipLevel = dstMipLevel++;
          VIEW.mipLevelCount = 1;
          VIEW.baseArrayLayer = arrayLayer;
          VIEW.arrayLayerCount = 1;
          const dstView = mipTexture.createView(VIEW);
          PASS.colorAttachments[0].view = dstView;
          const passEncoder = commandEncoder.beginRenderPass(PASS);
          GROUP.entries[0].resource = this.sampler;
          GROUP.entries[1].resource = srcView;
          const bindGroup = device.createBindGroup(GROUP);
          passEncoder.setPipeline(pipeline);
          passEncoder.setBindGroup(0, bindGroup);
          passEncoder.draw(3, 1, 0, 0);
          passEncoder.end();
          srcView = dstView;
        }
      }
      if (!renderToSource) {
        const TEXTURE = GPU_MIPMAP.TEXTURE;
        const mip_size = TEXTURE.size;
        mip_size.width = Math.ceil(texture.width / 2);
        mip_size.height = Math.ceil(texture.height / 2);
        mip_size.depthOrArrayLayers = arrayLayerCount;
        const mip_source = TEXTURE.source;
        const mip_target = TEXTURE.target;
        for (let i = 1; i < texture.mipLevelCount; ++i) {
          mip_target.texture = mipTexture;
          mip_target.mipLevel = i;
          mip_source.texture = texture;
          mip_source.mipLevel = i - 1;
          commandEncoder.copyTextureToTexture(mip_target, mip_source, mip_size);
          mip_size.width = Math.ceil(mip_size.width / 2);
          mip_size.height = Math.ceil(mip_size.height / 2);
        }
      }
      GPU_MIPMAP.BUFFER[0] = commandEncoder.finish();
      this.device.queue.submit(GPU_MIPMAP.BUFFER);
      if (!renderToSource) {
        mipTexture.destroy();
      }
      return texture;
    }
  }

  class GpuLimitsSystem {
    static extension = {
      type: [
        ExtensionType.WebGPUSystem,
      ],
      name: 'limits',
    };
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange(gpu) {
      const limits = gpu.device.limits;
      const maxTextures = this.maxTextures = limits.maxSampledTexturesPerShaderStage;
      this.maxBatchableTextures = maxTextures;
      const defaultOptions = Batcher.defaultOptions;
      defaultOptions.maxTextures = maxTextures;
      if (defaultOptions.shader === null) defaultOptions.shader = new DefaultShader(maxTextures);
      this.maxTextureSize = limits.maxTextureDimension2D;
      this.maxVertexBuffers = limits.maxVertexBuffers;
      this.maxBindGroups = limits.maxBindGroups;
    }
    destroy() {
      // boom!
    }
  }

  "use strict";
  const GPUTextureDescriptor = {
    label: "",
    size: {
      width: 1,
      height: 1
    },
    format: "",
    sampleCount: 4,
    mipLevelCount: 1,
    dimension: false,
    usage: 0
  };
  class GpuTextureSystem {
    constructor(renderer) {
      this._uploads = {
        image: gpuUploadImageResource,
        buffer: gpuUploadBufferImageResource,
        video: gpuUploadVideoResource,
        compressed: gpuUploadCompressedTextureResource,
        unknown: unknownUpload
      };
      this._renderer = renderer;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    initSource(source) {
      let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      if (source.uploadMethodId !== "compressed") {
        usage |= GPUTextureUsage.RENDER_ATTACHMENT;
        usage |= GPUTextureUsage.COPY_SRC;
      }
      const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
      const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
      GPUTextureDescriptor.format = source.format;
      GPUTextureDescriptor.label = source.label;
      GPUTextureDescriptor.size.width = width;
      GPUTextureDescriptor.size.height = height;
      GPUTextureDescriptor.sampleCount = source.sampleCount;
      GPUTextureDescriptor.mipLevelCount = source.mipLevelCount;
      GPUTextureDescriptor.dimension = source.dimension;
      GPUTextureDescriptor.usage = usage;
      const device = this._gpu.device;
      const gpuTexture = device.createTexture(GPUTextureDescriptor);
      source.gpuTextureView = gpuTexture.createView(Object.empty);
      if (!source.hasListeneredGpuTexture) {
        source.on("update", this.onSourceUpdate, this);
        source.on("resize", this.onSourceResize, this);
        source.on("destroy", this.onSourceDestroy, this);
        source.on("unload", this.onSourceUnload, this);
        source.on("updateMipmaps", this.onUpdateMipmaps, this);
        source.hasListeneredGpuTexture = true;
      }
      source.hasGpuTexture = true;
      source.gpuTexture = gpuTexture;
      this.onSourceUpdate(source);
      return gpuTexture;
    }
    onSourceUpdate(source) {
      const gpuTexture = this.getGpuSource(source);
      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);
      if (source.mipLevelCount > 1 && source.uploadMethodId !== "compressed") {
        this.onUpdateMipmaps(source);
      }
    }
    onSourceUnload(source) {
      const gpuTexture = source.gpuTexture;
      gpuTexture.destroy();
      source.hasGpuTexture = false;
      source.gpuTexture = null;
    }
    onUpdateMipmaps(source) {
      if (!this._mipmapGenerator) {
        this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
      }
      const gpuTexture = this.getGpuSource(source);
      this._mipmapGenerator.generateMipmap(gpuTexture);
    }
    onSourceDestroy(source) {
      source.off("update", this.onSourceUpdate, this);
      source.off("unload", this.onSourceUnload, this);
      source.off("destroy", this.onSourceDestroy, this);
      source.off("resize", this.onSourceResize, this);
      source.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.onSourceUnload(source);
    }
    onSourceResize(source) {
      const gpuTexture = source.gpuTexture;
      if (gpuTexture === null) {
        this.initSource(source);
      } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {
        source.gpuTextureView = null;
        this.onSourceUnload(source);
        this.initSource(source);
      }
    }
    _initSampler(sampler) {
      const gpuSampler = sampler.gpuSampler = this._gpu.device.createSampler(sampler);
      return gpuSampler;
    }
    getGpuSampler(sampler) {
      return sampler.gpuSampler || this._initSampler(sampler);
    }
    getGpuSource(source) {
      return source.gpuTexture || this.initSource(source);
    }
    /**
     * this returns s bind group for a specific texture, the bind group contains
     * - the texture source
     * - the texture style
     * - the texture matrix
     * This is cached so the bind group should only be created once per texture
     * @param texture - the texture you want the bindgroup for
     * @returns the bind group for the texture
     */
    getTextureBindGroup(texture, needTextureMatrix = true) {
      return texture._textureBindGroup || this._createTextureBindGroup(texture, needTextureMatrix);
    }
    /**
     * @param {Texture} texture 
     * @param {boolean} needTextureMatrix 
     * @returns {BindGroup}
     */
    _createTextureBindGroup(texture, needTextureMatrix) {
      const source = texture._source;
      if (needTextureMatrix) {
        let textureMatrix = texture._textureMatrix;
        if (textureMatrix === null) {
          textureMatrix = new TextureMatrix(texture);
          texture._textureMatrix = textureMatrix;
        }
      }
      const bindGroup = texture._textureBindGroup = new BindGroup({
        0: source,
        1: source._style,
      });
      if (needTextureMatrix) {
        bindGroup.setResource(new UniformGroup({
          uTextureMatrix: { type: "mat3x3<f32>", value: texture._textureMatrix.mapCoord }
        }), 2);
        bindGroup._update();
      }
      return bindGroup;
    }
    getTextureView(texture) {
      const source = texture._source;
      if (source.gpuTextureView === null) {
        const gpuTexture = this.getGpuSource(source);
        source.gpuTextureView = gpuTexture.createView();
      }
      return source.gpuTextureView;
    }
    destroy() {
      this._gpu = null;
      this._mipmapGenerator = null;
      this._gpuSamplers = null;
    }
  }
  /** @ignore */
  GpuTextureSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "texture"
  };

  "use strict";
  class GpuMeshAdapter {
    init() {
      const gpuProgram = compileHighShaderGpuProgram(
        [
          localUniformBit,
          textureBit,
          roundPixelsBit
        ],
        "mesh"
      );
      this._shader = new Shader({
        gpuProgram,
        resources: {
          uTexture: Texture.EMPTY._source,
          uSampler: Texture.EMPTY._source.style,
          textureUniforms: {
            uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
          }
        }
      });
    }
    execute(meshPipe, mesh) {
      const renderer = meshPipe.renderer;
      let shader = mesh._shader;
      if (!shader) {
        shader = this._shader;
        shader.groups[2] = renderer.texture.getTextureBindGroup(mesh._texture);
      } else if (!shader.gpuProgram) {
        Logger.warn("Mesh shader has no gpuProgram", mesh.shader);
        return;
      }
      const gpuProgram = shader.gpuProgram;
      if (gpuProgram.autoAssignGlobalUniforms) {
        shader.groups[0] = renderer.globalUniforms._currentGlobalUniformData.bindGroup;
      }
      if (gpuProgram.autoAssignLocalUniforms) {
        const localUniforms = meshPipe.localUniforms;
        shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
      }
      GL_MESH_ADAPTOR_DRAW_OPTIONS.geometry = mesh._geometry;
      GL_MESH_ADAPTOR_DRAW_OPTIONS.shader = shader;
      GL_MESH_ADAPTOR_DRAW_OPTIONS.state = mesh.state;
      renderer.encoder.draw(GL_MESH_ADAPTOR_DRAW_OPTIONS);
    }
    destroy() {
      this._shader.destroy(true);
      this._shader = null;
    }
  }
  /** @ignore */
  GpuMeshAdapter.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "mesh"
  };

  "use strict";
  const DefaultWebGPUSystems = [
    ...SharedSystems,
    GpuUboSystem,
    GpuEncoderSystem,
    GpuDeviceSystem,
    GpuBufferSystem,
    GpuTextureSystem,
    GpuLimitsSystem,
    GpuRenderTargetSystem,
    GpuShaderSystem,
    GpuStateSystem,
    PipelineSystem,
    GpuColorMaskSystem,
    GpuStencilSystem,
    BindGroupSystem
  ];
  const DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
  const DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
  const systems = [];
  const renderPipes = [];
  const renderPipeAdaptors = [];
  extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
  extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
  extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
  extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
  class WebGPURenderer extends AbstractRenderer {
    constructor() {
      const systemConfig = {
        name: "webgpu",
        type: RendererType.WEBGPU,
        systems,
        renderPipes,
        renderPipeAdaptors
      };
      super(systemConfig);
    }
  }

  var WebGPURenderer$1 = {
    __proto__: null,
    WebGPURenderer: WebGPURenderer
  };

  "use strict";
  const DEPRECATED_DRAW_MODES = {
    POINTS: "point-list",
    LINES: "line-list",
    LINE_STRIP: "line-strip",
    TRIANGLES: "triangle-list",
    TRIANGLE_STRIP: "triangle-strip"
  };
  const DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);
      return target[prop];
    }
  });

  "use strict";
  var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
    MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
    MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
    MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    return MSAA_QUALITY2;
  })(MSAA_QUALITY || {});
  var DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {
    DEPRECATED_WRAP_MODES2["CLAMP"] = "clamp-to-edge";
    DEPRECATED_WRAP_MODES2["REPEAT"] = "repeat";
    DEPRECATED_WRAP_MODES2["MIRRORED_REPEAT"] = "mirror-repeat";
    return DEPRECATED_WRAP_MODES2;
  })(DEPRECATED_WRAP_MODES || {});
  const WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);
      return target[prop];
    }
  });
  var DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {
    DEPRECATED_SCALE_MODES2["NEAREST"] = "nearest";
    DEPRECATED_SCALE_MODES2["LINEAR"] = "linear";
    return DEPRECATED_SCALE_MODES2;
  })(DEPRECATED_SCALE_MODES || {});
  const SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);
      return target[prop];
    }
  });
  "use strict";
  let uidCount = 0;
  function generateUID() {
    return uidCount++;
  }

  "use strict";
  function parseFunctionBody(fn) {
    const fnStr = fn.toString();
    const bodyStart = fnStr.indexOf("{");
    const bodyEnd = fnStr.lastIndexOf("}");
    if (bodyStart === -1 || bodyEnd === -1) {
      throw new Error("getFunctionBody: No body found in function definition");
    }
    return fnStr.slice(bodyStart + 1, bodyEnd).trim();
  }

  "use strict";

  "use strict";

  "use strict";

  "use strict";

  "use strict";
  var __defProp$9 = Object.defineProperty;
  var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
  var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
  var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$9 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    if (__getOwnPropSymbols$9)
      for (var prop of __getOwnPropSymbols$9(b)) {
        if (__propIsEnum$9.call(b, prop))
          __defNormalProp$9(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest$6 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$9)
      for (var prop of __getOwnPropSymbols$9(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class RenderContainer extends Container {
    /**
     * @param options - The options for the container.
     */
    constructor(options) {
      var _b, _c;
      if (typeof options === "function") {
        options = { render: options };
      }
      const _a = options, { render } = _a, rest = __objRest$6(_a, ["render"]);
      super(__spreadValues$9({
        label: "RenderContainer"
      }, rest));
      this.batched = false;
      this._lastUsed = 0;
      this._lastInstructionTick = -1;
      /**
       * The local bounds of the sprite.
       * @type {rendering.Bounds}
       */
      this.bounds = new Bounds();
      this.canBundle = false;
      this.renderPipeId = "customRender";
      if (render)
        this.render = render;
      this.containsPoint = (_b = options.containsPoint) != null ? _b : () => false;
      this.addBounds = (_c = options.addBounds) != null ? _c : () => false;
    }
    /**
     * An overridable function that can be used to render the object using the current renderer.
     * @param _renderer - The current renderer
     */
    render(_renderer) {
    }
  }

  "use strict";
  function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
    const buffer = geometry.buffers[0];
    const vertices = buffer._data;
    const { verticesX, verticesY } = geometry;
    const sizeX = width / (verticesX - 1);
    const sizeY = height / (verticesY - 1);
    let index = 0;
    const a00 = transformationMatrix[0];
    const a01 = transformationMatrix[1];
    const a02 = transformationMatrix[2];
    const a10 = transformationMatrix[3];
    const a11 = transformationMatrix[4];
    const a12 = transformationMatrix[5];
    const a20 = transformationMatrix[6];
    const a21 = transformationMatrix[7];
    const a22 = transformationMatrix[8];
    for (let i = 0; i < vertices.length; i += 2) {
      const x = index % verticesX * sizeX;
      const y = (index / verticesX | 0) * sizeY;
      const newX = a00 * x + a01 * y + a02;
      const newY = a10 * x + a11 * y + a12;
      const w = a20 * x + a21 * y + a22;
      vertices[i] = newX / w;
      vertices[i + 1] = newY / w;
      index++;
    }
    buffer.update();
  }

  "use strict";
  function computeAdjugate(out, matrix) {
    const a00 = matrix[0];
    const a01 = matrix[1];
    const a02 = matrix[2];
    const a10 = matrix[3];
    const a11 = matrix[4];
    const a12 = matrix[5];
    const a20 = matrix[6];
    const a21 = matrix[7];
    const a22 = matrix[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function multiplyMatrix3x3(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a10 = a[3];
    const a11 = a[4];
    const a12 = a[5];
    const a20 = a[6];
    const a21 = a[7];
    const a22 = a[8];
    const b00 = b[0];
    const b01 = b[1];
    const b02 = b[2];
    const b10 = b[3];
    const b11 = b[4];
    const b12 = b[5];
    const b20 = b[6];
    const b21 = b[7];
    const b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function multiplyMatrixAndVector(out, m, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = m[0] * x + m[1] * y + m[2] * z;
    out[1] = m[3] * x + m[4] * y + m[5] * z;
    out[2] = m[6] * x + m[7] * y + m[8] * z;
    return out;
  }
  const tempMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const tempVec = [0, 0, 0];
  const tempVec2 = [0, 0, 0];
  function generateBasisToPointsMatrix(out, x1, y1, x2, y2, x3, y3, x4, y4) {
    const m = tempMatrix;
    m[0] = x1;
    m[1] = x2;
    m[2] = x3;
    m[3] = y1;
    m[4] = y2;
    m[5] = y3;
    m[6] = 1;
    m[7] = 1;
    m[8] = 1;
    const adjugateM = computeAdjugate(
      out,
      // reusing out as adjugateM is only used once
      m
    );
    tempVec2[0] = x4;
    tempVec2[1] = y4;
    tempVec2[2] = 1;
    const v = multiplyMatrixAndVector(
      tempVec,
      adjugateM,
      tempVec2
    );
    const diagonalMatrix = out;
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = v[2];
    return multiplyMatrix3x3(out, diagonalMatrix, m);
  }
  const tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  function compute2DProjection(out, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    const sourceMatrix = generateBasisToPointsMatrix(
      tempSourceMatrix,
      x1s,
      y1s,
      x2s,
      y2s,
      x3s,
      y3s,
      x4s,
      y4s
    );
    const destinationMatrix = generateBasisToPointsMatrix(
      tempDestinationMatrix,
      x1d,
      y1d,
      x2d,
      y2d,
      x3d,
      y3d,
      x4d,
      y4d
    );
    return multiplyMatrix3x3(
      out,
      computeAdjugate(sourceMatrix, sourceMatrix),
      destinationMatrix
    );
  }

  "use strict";
  class PerspectivePlaneGeometry extends PlaneGeometry {
    /**
     * @param options - Options to be applied to MeshPlane
     * @param options.width - The width of the plane
     * @param options.height - The height of the plane
     * @param options.verticesX - The amount of vertices on the x axis
     * @param options.verticesY - The amount of vertices on the y axis
     */
    constructor(options) {
      super(options);
      this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      const { width, height } = options;
      this.corners = [0, 0, width, 0, width, height, 0, height];
    }
    /**
     * Will set the corners of the quad to the given coordinates
     * Calculating the perspective so it looks correct!
     * @param x0 - x coordinate of the first corner
     * @param y0 - y coordinate of the first corner
     * @param x1 - x coordinate of the second corner
     * @param y1 - y coordinate of the second corner
     * @param x2 - x coordinate of the third corner
     * @param y2 - y coordinate of the third corner
     * @param x3 - x coordinate of the fourth corner
     * @param y3 - y coordinate of the fourth corner
     */
    setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
      const corners = this.corners;
      corners[0] = x0;
      corners[1] = y0;
      corners[2] = x1;
      corners[3] = y1;
      corners[4] = x2;
      corners[5] = y2;
      corners[6] = x3;
      corners[7] = y3;
      this.updateProjection();
    }
    /** Update the projection matrix based on the corners */
    updateProjection() {
      const { width, height } = this;
      const corners = this.corners;
      const projectionMatrix = compute2DProjection(
        this._projectionMatrix,
        0,
        0,
        // top-left source
        corners[0],
        corners[1],
        // top-left dest
        width,
        0,
        // top-right source
        corners[2],
        corners[3],
        // top-right dest
        width,
        height,
        // bottom-right source
        corners[4],
        corners[5],
        // bottom-right dest
        0,
        height,
        // bottom-left source
        corners[6],
        corners[7]
        // bottom-left dest
      );
      applyProjectiveTransformationToPlane(
        width,
        height,
        this,
        projectionMatrix
      );
    }
  }

  "use strict";
  var __defProp$8 = Object.defineProperty;
  var __defProps$5 = Object.defineProperties;
  var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
  var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
  var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$8 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    if (__getOwnPropSymbols$8)
      for (var prop of __getOwnPropSymbols$8(b)) {
        if (__propIsEnum$8.call(b, prop))
          __defNormalProp$8(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
  var __objRest$5 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$8)
      for (var prop of __getOwnPropSymbols$8(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class PerspectiveMesh extends Mesh {
    /**
     * @param options - Options to be applied to PerspectiveMesh
     */
    constructor(options) {
      options = __spreadValues$8(__spreadValues$8({}, PerspectiveMesh.defaultOptions), options);
      const _a = options, { texture, verticesX, verticesY } = _a, rest = __objRest$5(_a, ["texture", "verticesX", "verticesY"]);
      const planeGeometry = new PerspectivePlaneGeometry(definedProps({
        width: texture.width,
        height: texture.height,
        verticesX,
        verticesY
      }));
      super(definedProps(__spreadProps$5(__spreadValues$8({}, rest), { geometry: planeGeometry })));
      this._texture = texture;
      this.geometry.setCorners(
        options.x0,
        options.y0,
        options.x1,
        options.y1,
        options.x2,
        options.y2,
        options.x3,
        options.y3
      );
    }
    /** Update the geometry when the texture is updated */
    textureUpdated() {
      const geometry = this.geometry;
      if (!geometry)
        return;
      const { width, height } = this.texture;
      if (geometry.width !== width || geometry.height !== height) {
        geometry.width = width;
        geometry.height = height;
        geometry.updateProjection();
      }
    }
    set texture(value) {
      if (this._texture === value)
        return;
      super.texture = value;
      this.textureUpdated();
    }
    /** The texture that the mesh uses */
    get texture() {
      return this._texture;
    }
    /**
     * Set the corners of the quad to the given coordinates
     * The mesh will then calculate the perspective so it looks correct!
     * @param x0 - x coordinate of the first corner
     * @param y0 - y coordinate of the first corner
     * @param x1 - x coordinate of the second corner
     * @param y1 - y coordinate of the second corner
     * @param x2 - x coordinate of the third corner
     * @param y2 - y coordinate of the third corner
     * @param x3 - x coordinate of the fourth corner
     * @param y3 - y coordinate of the fourth corner
     */
    setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
      this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
    }
  };
  /** default options for the mesh */
  PerspectiveMesh.defaultOptions = {
    texture: Texture.WHITE,
    verticesX: 10,
    verticesY: 10,
    x0: 0,
    y0: 0,
    x1: 100,
    y1: 0,
    x2: 100,
    y2: 100,
    x3: 0,
    y3: 100
  };

  "use strict";
  var __defProp$7 = Object.defineProperty;
  var __defProps$4 = Object.defineProperties;
  var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
  var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
  var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$7 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    if (__getOwnPropSymbols$7)
      for (var prop of __getOwnPropSymbols$7(b)) {
        if (__propIsEnum$7.call(b, prop))
          __defNormalProp$7(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
  var __objRest$4 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$7)
      for (var prop of __getOwnPropSymbols$7(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class MeshPlane extends Mesh {
    /**
     * @param options - Options to be applied to MeshPlane
     */
    constructor(options) {
      const _a = options, { texture, verticesX, verticesY } = _a, rest = __objRest$4(_a, ["texture", "verticesX", "verticesY"]);
      const planeGeometry = new PlaneGeometry(definedProps({
        width: texture.width,
        height: texture.height,
        verticesX,
        verticesY
      }));
      super(definedProps(__spreadProps$4(__spreadValues$7({}, rest), { geometry: planeGeometry, texture })));
      this.texture = texture;
      this.autoResize = true;
    }
    /**
     * Method used for overrides, to do something in case texture frame was changed.
     * Meshes based on plane can override it and change more details based on texture.
     */
    textureUpdated() {
      const geometry = this.geometry;
      const { width, height } = this._texture;
      if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
        geometry.width = width;
        geometry.height = height;
        geometry.build(Object.empty);
      }
    }
    set texture(value) {
      var _a;
      (_a = this._texture) == null ? void 0 : _a.off("update", this.textureUpdated, this);
      super.texture = value;
      value.on("update", this.textureUpdated, this);
      this.textureUpdated();
    }
    /** The texture of the MeshPlane */
    get texture() {
      return this._texture;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options) {
      this.texture.off("update", this.textureUpdated, this);
      super.destroy(options);
    }
  }

  "use strict";
  var __defProp$6 = Object.defineProperty;
  var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
  var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
  var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$6 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    if (__getOwnPropSymbols$6)
      for (var prop of __getOwnPropSymbols$6(b)) {
        if (__propIsEnum$6.call(b, prop))
          __defNormalProp$6(a, prop, b[prop]);
      }
    return a;
  };
  class RopeGeometry extends MeshGeometry {
    /**
     * @param options - Options to be applied to rope geometry
     */
    constructor(options) {
      const { width, points, textureScale } = __spreadValues$6(__spreadValues$6({}, RopeGeometry.defaultOptions), options);
      super({
        positions: new Float32Array(points.length * 4),
        uvs: new Float32Array(points.length * 4),
        indices: new Uint32Array((points.length - 1) * 6)
      });
      this.points = points;
      this._width = width;
      this.textureScale = textureScale;
      this._build();
    }
    /**
     * The width (i.e., thickness) of the rope.
     * @readonly
     */
    get width() {
      return this._width;
    }
    /** Refreshes Rope indices and uvs */
    _build() {
      const points = this.points;
      if (!points)
        return;
      const vertexBuffer = this.getBuffer("aPosition");
      const uvBuffer = this.getBuffer("aUV");
      const indexBuffer = this.getIndex();
      if (points.length < 1) {
        return;
      }
      if (vertexBuffer._data.length / 4 !== points.length) {
        const length = points.length * 4;
        vertexBuffer.setDataWithSize(new Float32Array(length), length, true);
        uvBuffer.setDataWithSize(new Float32Array(length), length, true);
        indexBuffer.setDataWithSize(new Uint16Array((points.length - 1) * 6), (points.length - 1) * 6, true);
      }
      const uvs = uvBuffer._data;
      const indices = indexBuffer._data;
      uvs[0] = 0;
      uvs[1] = 0;
      uvs[2] = 0;
      uvs[3] = 1;
      let amount = 0;
      let prev = points[0];
      const textureWidth = this._width * this.textureScale;
      const total = points.length;
      for (let i = 0; i < total; i++) {
        const index = i * 4;
        if (this.textureScale > 0) {
          const dx = prev.x - points[i].x;
          const dy = prev.y - points[i].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          prev = points[i];
          amount += distance / textureWidth;
        } else {
          amount = i / (total - 1);
        }
        uvs[index] = amount;
        uvs[index + 1] = 0;
        uvs[index + 2] = amount;
        uvs[index + 3] = 1;
      }
      let indexCount = 0;
      for (let i = 0; i < total - 1; i++) {
        const index = i * 2;
        indices[indexCount++] = index;
        indices[indexCount++] = index + 1;
        indices[indexCount++] = index + 2;
        indices[indexCount++] = index + 2;
        indices[indexCount++] = index + 1;
        indices[indexCount++] = index + 3;
      }
      uvBuffer.update();
      indexBuffer.update();
      this.updateVertices();
    }
    /** refreshes vertices of Rope mesh */
    updateVertices() {
      const points = this.points;
      if (points.length < 1) {
        return;
      }
      let lastPoint = points[0];
      let nextPoint;
      let perpX = 0;
      let perpY = 0;
      const vertices = this.buffers[0]._data;
      const total = points.length;
      const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      for (let i = 0; i < total; i++) {
        const point = points[i];
        const index = i * 4;
        if (i < points.length - 1) {
          nextPoint = points[i + 1];
        } else {
          nextPoint = point;
        }
        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;
        let ratio = (1 - i / (total - 1)) * 10;
        if (ratio > 1) {
          ratio = 1;
        }
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        if (perpLength < 1e-6) {
          perpX = 0;
          perpY = 0;
        } else {
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= halfWidth;
          perpY *= halfWidth;
        }
        vertices[index] = point.x + perpX;
        vertices[index + 1] = point.y + perpY;
        vertices[index + 2] = point.x - perpX;
        vertices[index + 3] = point.y - perpY;
        lastPoint = point;
      }
      this.buffers[0].update();
    }
    /** Refreshes Rope indices and uvs */
    update() {
      if (this.textureScale > 0) {
        this._build();
      } else {
        this.updateVertices();
      }
    }
  };
  /** Default options for RopeGeometry constructor. */
  RopeGeometry.defaultOptions = {
    /** The width (i.e., thickness) of the rope. */
    width: 200,
    /** An array of points that determine the rope. */
    points: [],
    /** Rope texture scale, if zero then the rope texture is stretched. */
    textureScale: 0
  };
  "use strict";
  var __defProp$5 = Object.defineProperty;
  var __defProps$3 = Object.defineProperties;
  var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
  var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
  var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$5 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    if (__getOwnPropSymbols$5)
      for (var prop of __getOwnPropSymbols$5(b)) {
        if (__propIsEnum$5.call(b, prop))
          __defNormalProp$5(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
  var __objRest$3 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$5)
      for (var prop of __getOwnPropSymbols$5(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class MeshRope extends Mesh {
    /**
     * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
     * @param options
     * @param options.texture - The texture to use on the rope.
     * @param options.points - An array of {@link math.Point} objects to construct this rope.
     * @param {number} options.textureScale - Optional. Positive values scale rope texture
     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
     * and downsampling here. If set to zero, texture will be stretched instead.
     */
    constructor(options) {
      const _a = __spreadValues$5(__spreadValues$5({}, MeshRope.defaultOptions), options), { texture, points, textureScale } = _a, rest = __objRest$3(_a, ["texture", "points", "textureScale"]);
      const ropeGeometry = new RopeGeometry(definedProps({ width: texture.height, points, textureScale }));
      if (textureScale > 0) {
        texture._source._style.addressMode = "repeat";
      }
      super(definedProps(__spreadProps$3(__spreadValues$5({}, rest), {
        texture,
        geometry: ropeGeometry
      })));
      this.autoUpdate = true;
    }
    update() {
      const geometry = this.geometry;
      if (this.autoUpdate || geometry._width !== this.texture.height) {
        geometry._width = this.texture.height;
        geometry.update();
      }
    }
  };
  MeshRope.defaultOptions = {
    textureScale: 0
  };

  "use strict";
  var __defProp$4 = Object.defineProperty;
  var __defProps$2 = Object.defineProperties;
  var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
  var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
  var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$4 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    if (__getOwnPropSymbols$4)
      for (var prop of __getOwnPropSymbols$4(b)) {
        if (__propIsEnum$4.call(b, prop))
          __defNormalProp$4(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
  var __objRest$2 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$4)
      for (var prop of __getOwnPropSymbols$4(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class MeshSimple extends Mesh {
    /**
     * @param options - Options to be used for construction
     */
    constructor(options) {
      const _a = options, { texture, vertices, uvs, indices, topology } = _a, rest = __objRest$2(_a, ["texture", "vertices", "uvs", "indices", "topology"]);
      const geometry = new MeshGeometry(definedProps({
        positions: vertices,
        uvs,
        indices,
        topology
      }));
      super(definedProps(__spreadProps$2(__spreadValues$4({}, rest), {
        texture,
        geometry
      })));
      this.autoUpdate = true;
    }
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get vertices() {
      return this.geometry.getBuffer("aPosition")._data;
    }
    set vertices(value) {
      this.geometry.getBuffer("aPosition").setDataWithSize(value, value.length, true);
    }
    update() {
      if (this.autoUpdate) {
        this.geometry.getBuffer("aPosition").update();
      }
    }
  }

  "use strict";
  class Particle {
    constructor() {
      this.x = 0;
      this.y = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.anchorX = 0;
      this.anchorY = 0;
      this.rotation = 0;
      this._alpha = 0;
      this._tint = 16777215;
      this.color = 0;
      this.sharedTexture = null;
      this.uvs = new TextureUvs();
      this.fx = 0;
      this.fy = 0;
      this.width = 0;
      this.height = 0;
      this.alpha = 255;
    }
    setScale(x, y) {
      this.scaleX = x;
      this.scaleY = y;
    }
    setAnchor(x, y) {
      this.anchorX = x;
      this.anchorY = y;
    }
    setRotation(rotation) {
      this.rotation = rotation;
    }
    setPosition(x, y) {
      this.x = x;
      this.y = y;
    }
    copyFrameUvs(uvs) {
      this.uvs.copyFrom(uvs);
    }
    setFrame(x, y, width, height) {
      const source = this.sharedTexture._source;
      this.fx = x;
      this.fy = y;
      this.width = width;
      this.height = height;
      this.uvs.set(x, y, width, height, source);
    }
    /** Gets or sets the alpha value of the particle. */
    get alpha() {
      return this._alpha;
    }
    set alpha(value) {
      value = value.clamp(0, 255) | 0;
      if (value === this._alpha) return;
      this._alpha = value;
      this._updateColor();
    }
    /** Gets or sets the tint color of the particle. */
    get tint() {
      return bgr2rgb(this._tint);
    }
    set tint(value) {
      this._tint = Color.shared.setValue(value).toBgrNumber();
      this._updateColor();
    }
    _updateColor() {
      this.color = this._tint + ((this._alpha << 24) >>> 0);
    }
    update() {
      //to do
    }
  };

  "use strict";
  const particleData = {
    vertex: {
      attributeName: "aVertex",
      format: "float32x2",
      code: `
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const width = p.width;
            const height = p.height;
            const w1 = -ax * (width);
            const w0 = w1 + width;
            const h1 = -ay * (height);
            const h0 = h1 + height;
            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;
            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;
            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;
            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
      dynamic: false
    },
    // positionData
    position: {
      attributeName: "aPosition",
      format: "float32x2",
      code: `
            const x = p.x;
            const y = p.y;
            f32v[offset] = x;
            f32v[offset + 1] = y;
            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;
            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;
            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
      dynamic: true
    },
    // rotationData
    rotation: {
      attributeName: "aRotation",
      format: "float32",
      code: `
            var rotation = p.rotation;
            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
      dynamic: false
    },
    // uvsData
    uvs: {
      attributeName: "aUV",
      format: "float32x2",
      code: `
            var uvs = p.uvs;
            f32v[offset] = uvs[0];
            f32v[offset + 1] = uvs[1];
            f32v[offset + stride] = uvs[2];
            f32v[offset + stride + 1] = uvs[3];
            f32v[offset + (stride * 2)] = uvs[4];
            f32v[offset + (stride * 2) + 1] = uvs[5];
            f32v[offset + (stride * 3)] = uvs[6];
            f32v[offset + (stride * 3) + 1] = uvs[7];
        `,
      dynamic: false
    },
    // tintData
    color: {
      attributeName: "aColor",
      format: "unorm8x4",
      code: `
            const c = p.color;
            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
      dynamic: false
    }
  };

  "use strict";
  const emptyBounds = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };
  class ParticleContainer extends ViewContainer {
    /**
     * @param options - The options for creating the sprite.
     */
    constructor(options = ParticleContainer.defaultOptions) {
      if (!options.dynamicProperties) options.dynamicProperties = ParticleContainer.defaultOptions.dynamicProperties;
      super();
      /** The unique identifier for the render pipe of this ParticleContainer. */
      this.renderPipeId = "particle";
      this.batched = false;
      /** Indicates if the children of this ParticleContainer have changed and need to be updated. */
      this._childrenDirty = false;
      this.texture = options.texture || Texture.EMPTY;
      this.shader = options.shader;
      this._properties = {};
      const dynamicProperties = options.dynamicProperties;
      const roundPixels = options.roundPixels;
      const properties = this._properties;
      for (const key in particleData) {
        const property = particleData[key];
        const dynamic = dynamicProperties[key];
        const newProperty = Object.assign({}, property);
        newProperty.dynamic = dynamic;
        properties[key] = newProperty;
      }
      this.roundPixels = roundPixels != null ? roundPixels : false;
      this.particleChildren = [];
      this.checkWorldTransform();
    }
    /**
     * Adds one or more particles to the container.
     *
     * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`
     * @param {...IParticle} children - The Particle(s) to add to the container
     * @returns {IParticle} - The first child that was added.
     */
    addParticle(...children) {
      const particleChildren = this.particleChildren;
      for (let i = 0; i < children.length; i++) {
        particleChildren[particleChildren.length] = children[i];
      }
      this.onViewUpdate();
      return children[0];
    }
    /**
     * Removes one or more particles from the container.
     * @param {...IParticle} children - The Particle(s) to remove
     * @returns {IParticle} The first child that was removed.
     */
    removeParticle(...children) {
      let didRemove = false;
      const particleChildren = this.particleChildren;
      for (let i = 0; i < children.length; i++) {
        if (particleChildren.remove(children[i])) {
          didRemove = true;
        }
      }
      if (didRemove) this.onViewUpdate();
      return children[0];
    }
    onViewUpdate() {
      this._childrenDirty = true;
      super.onViewUpdate();
    }
    /** The local bounds of the view. */
    get bounds() {
      Logger.warn(
        // eslint-disable-next-line max-len
        "ParticleContainer does not calculated bounds as it would slow things down, its up to you to set this via the boundsArea property"
      );
      return emptyBounds;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param _bounds - The output bounds object.
     */
    addBounds(_bounds) {
      Logger.warn(
        // eslint-disable-next-line max-len
        "ParticleContainer does not calculated bounds as it would slow things down, its up to you to set this via the boundsArea property"
      );
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options = false) {
      var _a, _b, _c;
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        const texture = (_b = this.texture) != null ? _b : (_a = this.particleChildren[0]) == null ? void 0 : _a.texture;
        if (texture) {
          texture.destroy(destroyTextureSource);
        }
      }
      this.texture = null;
      (_c = this.shader) == null ? void 0 : _c.destroy();
    }
    /**
     * Removes all particles from this container that are within the begin and end indexes.
     * @param beginIndex - The beginning position.
     * @param endIndex - The ending position. Default value is size of the container.
     * @returns - List of removed particles
     */
    removeParticles(beginIndex, endIndex) {
      const children = this.particleChildren.splice(beginIndex, endIndex);
      this.onViewUpdate();
      return children;
    }
    /**
     * Removes a particle from the specified index position.
     * @param index - The index to get the particle from
     * @returns The particle that was removed.
     */
    removeParticleAt(index) {
      const child = this.particleChildren.splice(index, 1);
      this.onViewUpdate();
      return child[0];
    }
    /**
     * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
     * If the particle is already in this container, it will be moved to the specified index.
     * @param {Container} child - The particle to add.
     * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
     * @returns {Container} The particle that was added.
     */
    addParticleAt(child, index) {
      this.particleChildren.splice(index, 0, child);
      this.onViewUpdate();
      return child;
    }
  };
  /**
   * Defines the default options for creating a ParticleContainer.
   * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.
   * @property {boolean} roundPixels - Indicates if pixels should be  rounded.
   */
  ParticleContainer.defaultOptions = {
    dynamicProperties: {
      vertex: false,
      // Indicates if vertex positions are dynamic.
      position: true,
      // Indicates if particle positions are dynamic.
      rotation: false,
      // Indicates if particle rotations are dynamic.
      uvs: false,
      // Indicates if UV coordinates are dynamic.
      color: false
      // Indicates if particle colors are dynamic.
    },
    roundPixels: false
    // Indicates if pixels should be rounded for rendering.
  };

  "use strict";
  var __defProp$1 = Object.defineProperty;
  var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
  var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
  var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$1 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(b)) {
        if (__propIsEnum$1.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      }
    return a;
  };
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  class NineSliceSprite extends ViewContainer {
    /**
     * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use
     * @param options.texture - The texture to use on the NineSliceSprite.
     * @param options.leftWidth - Width of the left vertical bar (A)
     * @param options.topHeight - Height of the top horizontal bar (C)
     * @param options.rightWidth - Width of the right vertical bar (B)
     * @param options.bottomHeight - Height of the bottom horizontal bar (D)
     * @param options.width - Width of the NineSliceSprite,
     * setting this will actually modify the vertices and not the UV's of this plane.
     * @param options.height - Height of the NineSliceSprite,
     * setting this will actually modify the vertices and not UV's of this plane.
     */
    constructor(options) {
      var _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (options instanceof Texture) {
        options = { texture: options };
      }
      const _a = options, {
        width,
        height,
        leftWidth,
        rightWidth,
        topHeight,
        bottomHeight,
        texture,
        roundPixels
      } = _a, rest = __objRest(_a, [
        "width",
        "height",
        "leftWidth",
        "rightWidth",
        "topHeight",
        "bottomHeight",
        "texture",
        "roundPixels"
      ]);
      super(__spreadValues$1({
        label: "NineSliceSprite"
      }, rest));
      this.renderPipeId = "nineSliceSprite";
      this.batched = true;
      this._leftWidth = (_c = leftWidth != null ? leftWidth : (_b = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _b.left) != null ? _c : NineSliceGeometry.defaultOptions.leftWidth;
      this._topHeight = (_e = topHeight != null ? topHeight : (_d = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _d.top) != null ? _e : NineSliceGeometry.defaultOptions.topHeight;
      this._rightWidth = (_g = rightWidth != null ? rightWidth : (_f = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _f.right) != null ? _g : NineSliceGeometry.defaultOptions.rightWidth;
      this._bottomHeight = (_i = bottomHeight != null ? bottomHeight : (_h = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _h.bottom) != null ? _i : NineSliceGeometry.defaultOptions.bottomHeight;
      this.bounds.maxX = this._width = (_j = width != null ? width : texture.width) != null ? _j : NineSliceGeometry.defaultOptions.width;
      this.bounds.maxY = this._height = (_k = height != null ? height : texture.height) != null ? _k : NineSliceGeometry.defaultOptions.height;
      this.allowChildren = false;
      this.texture = texture != null ? texture : NineSliceSprite.defaultOptions.texture;
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    /** The local bounds of the view. */
    get bounds() {
      return this._bounds;
    }
    /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
    get width() {
      return this._width;
    }
    set width(value) {
      this.bounds.maxX = this._width = value;
      this.onViewUpdate();
    }
    /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
    get height() {
      return this._height;
    }
    set height(value) {
      this.bounds.maxY = this._height = value;
      this.onViewUpdate();
    }
    /**
     * Sets the size of the NiceSliceSprite to the specified width and height.
     * setting this will actually modify the vertices and UV's of this plane
     * This is faster than setting the width and height separately.
     * @param value - This can be either a number or a [Size]{@link Size} object.
     * @param height - The height to set. Defaults to the value of `width` if not provided.
     */
    setSize(value, height) {
      var _a;
      if (typeof value === "object") {
        height = (_a = value.height) != null ? _a : value.width;
        value = value.width;
      }
      this.bounds.maxX = this._width = value;
      this.bounds.maxY = this._height = height != null ? height : value;
      this.onViewUpdate();
    }
    /**
     * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
     * This is faster than get the width and height separately.
     * @param out - Optional object to store the size in.
     * @returns - The size of the NineSliceSprite.
     */
    getSize(out) {
      out || (out = {});
      out.width = this._width;
      out.height = this._height;
      return out;
    }
    /** The width of the left column (a) of the NineSliceSprite. */
    get leftWidth() {
      return this._leftWidth;
    }
    set leftWidth(value) {
      this._leftWidth = value;
      this.onViewUpdate();
    }
    /** The width of the right column (b) of the NineSliceSprite. */
    get topHeight() {
      return this._topHeight;
    }
    set topHeight(value) {
      this._topHeight = value;
      this.onViewUpdate();
    }
    /** The width of the right column (b) of the NineSliceSprite. */
    get rightWidth() {
      return this._rightWidth;
    }
    set rightWidth(value) {
      this._rightWidth = value;
      this.onViewUpdate();
    }
    /** The width of the right column (b) of the NineSliceSprite. */
    get bottomHeight() {
      return this._bottomHeight;
    }
    set bottomHeight(value) {
      this._bottomHeight = value;
      this.onViewUpdate();
    }
    /** The texture that the NineSliceSprite is using. */
    get texture() {
      return this._texture;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value) return;
      this._texture = value;
    }
    /** The original width of the texture */
    get originalWidth() {
      return this._texture.width;
    }
    /** The original height of the texture */
    get originalHeight() {
      return this._texture.height;
    }
    /**
     * Adds the bounds of this object to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      const _bounds = this.bounds;
      bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
    }
  };
  /** The default options, used to override the initial values of any options passed in the constructor. */
  NineSliceSprite.defaultOptions = {
    /** @default Texture.EMPTY */
    texture: Texture.EMPTY
  };

  globalThis.Rectangle = Rectangle;
  globalThis.Point = Point;
  exports.ShaderBitsCache = {
    cacheMap,
    bitCacheMap,
    CACHE_UID
  }
  exports.AbstractRenderer = AbstractRenderer;
  exports.BatcherCache = BatcherCache;
  exports.AlphaFilter = AlphaFilter;
  exports.AlphaMask = AlphaMask;
  exports.AlphaMaskPipe = AlphaMaskPipe;
  exports.BLEND_TO_NPM = BLEND_TO_NPM;
  exports.BUFFER_TYPE = BUFFER_TYPE;
  exports.BackgroundSystem = BackgroundSystem;
  exports.Batch = Batch;
  exports.BatchGeometry = BatchGeometry;
  exports.BatchTextureArray = BatchTextureArray;
  exports.BatchableMesh = BatchableMesh;
  exports.BatchableSprite = BatchableSprite;
  exports.Batcher = Batcher;
  exports.BatcherPipe = BatcherPipe;
  exports.BindGroup = BindGroup;
  exports.BindGroupSystem = BindGroupSystem;
  exports.BlendModeFilter = BlendModeFilter;
  exports.BlendModePipe = BlendModePipe;
  exports.BlurFilter = BlurFilter;
  exports.BlurFilterPass = BlurFilterPass;
  exports.Bounds = Bounds;
  exports.BrowserAdapter = BrowserAdapter;
  exports.Buffer = Buffer;
  exports.BufferImageSource = BufferImageSource;
  exports.BufferResource = BufferResource;
  exports.BufferUsage = BufferUsage;
  exports.CLEAR = CLEAR;
  exports.Circle = Circle;
  exports.Color = Color;
  exports.ColorMask = ColorMask;
  exports.ColorMaskPipe = ColorMaskPipe;
  exports.ColorMatrixFilter = ColorMatrixFilter;
  exports.Container = Container;
  exports.checkAndUpdateTexture = checkAndUpdateTexture;
  exports.CustomRenderPipe = CustomRenderPipe;
  exports.DEG_TO_RAD = DEG_TO_RAD;
  exports.DEPRECATED_SCALE_MODES = DEPRECATED_SCALE_MODES;
  exports.DEPRECATED_WRAP_MODES = DEPRECATED_WRAP_MODES;
  exports.DOMAdapter = DOMAdapter;
  exports.DRAW_MODES = DRAW_MODES;
  exports.DefaultBatcher = DefaultBatcher;
  exports.DefaultShader = DefaultShader;
  exports.DisplacementFilter = DisplacementFilter;
  exports.Ellipse = Ellipse;
  exports.EventEmitter = EventEmitter;
  exports.ExtensionType = ExtensionType;
  exports.Filter = Filter;
  exports.FilterEffect = FilterEffect;
  exports.FilterPipe = FilterPipe;
  exports.FilterSystem = FilterSystem;
  exports.GAUSSIAN_VALUES = GAUSSIAN_VALUES;
  exports.GL_FORMATS = GL_FORMATS;
  exports.GL_TARGETS = GL_TARGETS;
  exports.GL_TYPES = GL_TYPES;
  exports.GL_WRAP_MODES = GL_WRAP_MODES;
  exports.Geometry = Geometry;
  exports.GlBackBufferSystem = GlBackBufferSystem;
  exports.GlBatchAdaptor = GlBatchAdaptor;
  exports.GlBuffer = GlBuffer;
  exports.GlBufferSystem = GlBufferSystem;
  exports.GlColorMaskSystem = GlColorMaskSystem;
  exports.GlContextSystem = GlContextSystem;
  exports.GlEncoderSystem = GlEncoderSystem;
  exports.GlGeometrySystem = GlGeometrySystem;
  exports.GlMeshAdaptor = GlMeshAdaptor;
  exports.GlParticleContainerAdaptor = GlParticleContainerAdaptor;
  exports.GlParticleContainerPipe = GlParticleContainerPipe;
  exports.GlProgram = GlProgram;
  exports.GlProgramData = GlProgramData;
  exports.GlRenderTarget = GlRenderTarget;
  exports.GlRenderTargetAdaptor = GlRenderTargetAdaptor;
  exports.GlRenderTargetSystem = GlRenderTargetSystem;
  exports.GlShaderSystem = GlShaderSystem;
  exports.GlStateSystem = GlStateSystem;
  exports.GlStencilSystem = GlStencilSystem;
  exports.GlTexture = GlTexture;
  exports.GlTextureSystem = GlTextureSystem;
  exports.GlUboSystem = GlUboSystem;
  exports.GlUniformGroupSystem = GlUniformGroupSystem;
  exports.GlobalUniformSystem = GlobalUniformSystem;
  exports.GpuBatchAdaptor = GpuBatchAdaptor;
  exports.GpuBlendModesToPixi = GpuBlendModesToPixi;
  exports.GpuBufferSystem = GpuBufferSystem;
  exports.GpuColorMaskSystem = GpuColorMaskSystem;
  exports.GpuDeviceSystem = GpuDeviceSystem;
  exports.GpuEncoderSystem = GpuEncoderSystem;
  exports.GpuMeshAdapter = GpuMeshAdapter;
  exports.GpuMipmapGenerator = GpuMipmapGenerator;
  exports.GpuParticleContainerAdaptor = GpuParticleContainerAdaptor;
  exports.GpuParticleContainerPipe = GpuParticleContainerPipe;
  exports.GpuProgram = GpuProgram;
  exports.GpuReadBuffer = GpuReadBuffer;
  exports.GpuRenderTarget = GpuRenderTarget;
  exports.GpuRenderTargetAdaptor = GpuRenderTargetAdaptor;
  exports.GpuRenderTargetSystem = GpuRenderTargetSystem;
  exports.GpuShaderSystem = GpuShaderSystem;
  exports.GpuStateSystem = GpuStateSystem;
  exports.GpuStencilModesToPixi = GpuStencilModesToPixi;
  exports.GpuStencilSystem = GpuStencilSystem;
  exports.GpuTextureSystem = GpuTextureSystem;
  exports.GpuUboSystem = GpuUboSystem;
  exports.GpuUniformBatchPipe = GpuUniformBatchPipe;
  exports.GpuGraphicsAdaptor = GpuGraphicsAdaptor;
  exports.GlGraphicsAdaptor = GlGraphicsAdaptor;
  exports.Graphics = Graphics;
  exports.GraphicsContext = GraphicsContext;
  exports.GraphicsPath = GraphicsPath;
  exports.GraphicsPipe = GraphicsPipe;
  exports.GraphicsContextRenderData = GraphicsContextRenderData;
  exports.GraphicsContextSystem = GraphicsContextSystem;
  exports.HelloSystem = HelloSystem;
  exports.InstructionSet = InstructionSet;
  exports.MSAA_QUALITY = MSAA_QUALITY;
  exports.MaskEffectManager = MaskEffectManager;
  exports.MaskEffectManagerClass = MaskEffectManagerClass;
  exports.MaskFilter = MaskFilter;
  exports.Matrix = Matrix;
  exports.Mesh = Mesh;
  exports.MeshGeometry = MeshGeometry;
  exports.MeshPipe = MeshPipe;
  exports.MeshPlane = MeshPlane;
  exports.MeshRope = MeshRope;
  exports.MeshSimple = MeshSimple;
  exports.NineSliceGeometry = NineSliceGeometry;
  exports.NineSliceSprite = NineSliceSprite;
  exports.NineSliceSpritePipe = NineSliceSpritePipe;
  exports.NoiseFilter = NoiseFilter;
  exports.ObservablePoint = ObservablePoint;
  exports.PI_2 = PI_2;
  exports.Particle = Particle;
  exports.ParticleBuffer = ParticleBuffer;
  exports.ParticleContainer = ParticleContainer;
  exports.ParticleContainerPipe = ParticleContainerPipe;
  exports.ParticleShader = ParticleShader;
  exports.PerspectiveMesh = PerspectiveMesh;
  exports.PerspectivePlaneGeometry = PerspectivePlaneGeometry;
  exports.PipelineSystem = PipelineSystem;
  exports.PlaneGeometry = PlaneGeometry;
  exports.Point = Point;
  exports.Polygon = Polygon;
  exports.QuadGeometry = QuadGeometry;
  exports.RAD_TO_DEG = RAD_TO_DEG;
  exports.Rectangle = Rectangle;
  exports.RenderContainer = RenderContainer;
  exports.RenderGroup = RenderGroup;
  exports.RenderGroupPipe = RenderGroupPipe;
  exports.RenderGroupSystem = RenderGroupSystem;
  exports.RenderTarget = RenderTarget;
  exports.RenderTargetSystem = RenderTargetSystem;
  exports.RenderTexture = RenderTexture;
  exports.RendererType = RendererType;
  exports.RopeGeometry = RopeGeometry;
  exports.RoundedRectangle = RoundedRectangle;
  exports.SCALE_MODES = SCALE_MODES;
  exports.STENCIL_MODES = STENCIL_MODES;
  exports.ScissorMask = ScissorMask;
  exports.Shader = Shader;
  exports.ShaderStage = ShaderStage;
  exports.SharedRenderPipes = SharedRenderPipes;
  exports.SharedSystems = SharedSystems;
  exports.Sprite = Sprite;
  exports.SpritePipe = SpritePipe;
  exports.State = State;
  exports.StencilMask = StencilMask;
  exports.StencilMaskPipe = StencilMaskPipe;
  exports.SystemRunner = SystemRunner;
  exports.ShapePath = ShapePath;
  exports.Texture = Texture;
  exports.TextureMatrix = TextureMatrix;
  exports.TexturePool = TexturePool;
  exports.TexturePoolClass = TexturePoolClass;
  exports.TextureSource = TextureSource;
  exports.TextureStyle = TextureStyle;
  exports.TextureUvs = TextureUvs;
  exports.TilingSprite = TilingSprite;
  exports.TilingSpritePipe = TilingSpritePipe;
  exports.TilingSpriteShader = TilingSpriteShader;
  exports.Transform = Transform;
  exports.Triangle = Triangle;
  exports.UNIFORM_TO_ARRAY_SETTERS = UNIFORM_TO_ARRAY_SETTERS;
  exports.UNIFORM_TO_SINGLE_SETTERS = UNIFORM_TO_SINGLE_SETTERS;
  exports.UNIFORM_TYPES_MAP = UNIFORM_TYPES_MAP;
  exports.UNIFORM_TYPES_VALUES = UNIFORM_TYPES_VALUES;
  exports.UPDATE_BLEND = UPDATE_BLEND;
  exports.UPDATE_COLOR = UPDATE_COLOR;
  exports.UPDATE_TRANSFORM = UPDATE_TRANSFORM;
  exports.UPDATE_VISIBLE = UPDATE_VISIBLE;
  exports.UboBatch = UboBatch;
  exports.UboSystem = UboSystem;
  exports.UniformGroup = UniformGroup;
  exports.VERSION = VERSION;
  exports.ViewContainer = ViewContainer;
  exports.ViewSystem = ViewSystem;
  exports.ViewableBuffer = ViewableBuffer;
  exports.WGSL_ALIGN_SIZE_DATA = WGSL_ALIGN_SIZE_DATA;
  exports.WGSL_TO_STD40_SIZE = WGSL_TO_STD40_SIZE;
  exports.WRAP_MODES = WRAP_MODES;
  exports.WebGLRenderer = WebGLRenderer;
  exports.WebGPURenderer = WebGPURenderer;
  exports._getGlobalBounds = _getGlobalBounds;
  exports.addBits = addBits;
  exports.addMaskBounds = addMaskBounds;
  exports.addMaskLocalBounds = addMaskLocalBounds;
  exports.addProgramDefines = addProgramDefines;
  exports.alphaFrag = fragment$4;
  exports.alphaWgsl = source$5;
  exports.applyMatrix = applyMatrix;
  exports.applyProjectiveTransformationToPlane = applyProjectiveTransformationToPlane;
  exports.applyStyleParams = applyStyleParams;
  exports.assignWithIgnore = assignWithIgnore;
  exports.autoDetectRenderer = autoDetectRenderer;
  exports.blendTemplateFrag = blendTemplateFrag;
  exports.blendTemplateVert = blendTemplateVert;
  exports.blendTemplateWgsl = blendTemplate;
  exports.blockDataMap = blockDataMap;
  exports.blurTemplateWgsl = source$4;
  exports.boundsPool = boundsPool;
  exports.calculateProjection = calculateProjection;
  exports.checkChildrenDidChange = checkChildrenDidChange;
  exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;
  exports.childrenHelperMixin = childrenHelperMixin;
  exports.closePointEps = closePointEps;
  exports.color32BitToUniform = color32BitToUniform;
  exports.colorBit = colorBit;
  exports.colorBitGl = colorBitGl;
  exports.colorMatrixFilterFrag = fragment$3;
  exports.colorMatrixFilterWgsl = source$3;
  exports.colorToUniform = colorToUniform;
  exports.compareModeToGlCompare = compareModeToGlCompare;
  exports.compileHighShader = compileHighShader;
  exports.compileHighShaderGl = compileHighShaderGl;
  exports.compileHighShaderGlProgram = compileHighShaderGlProgram;
  exports.compileHighShaderGpuProgram = compileHighShaderGpuProgram;
  exports.compileHooks = compileHooks;
  exports.compileInputs = compileInputs;
  exports.compileOutputs = compileOutputs;
  exports.compileShader = compileShader;
  exports.compute2DProjection = compute2DProjection;
  exports.convertToList = convertToList;
  exports.copySearchParams = copySearchParams;
  exports.createIdFromString = createIdFromString;
  exports.createIndicesForQuads = createIndicesForQuads;
  exports.createUboElementsSTD40 = createUboElementsSTD40;
  exports.createUboElementsWGSL = createUboElementsWGSL;
  exports.createUboSyncFunction = createUboSyncFunction;
  exports.createUboSyncFunctionSTD40 = createUboSyncFunctionSTD40;
  exports.createUboSyncFunctionWGSL = createUboSyncFunctionWGSL;
  exports.crossOrigin = crossOrigin;
  exports.curveEps = curveEps;
  exports.defaultFilterVert = vertex$2;
  exports.defaultValue = defaultValue;
  exports.definedProps = definedProps;
  exports.deprecation = deprecation;
  exports.determineCrossOrigin = determineCrossOrigin;
  exports.displacementFrag = fragment$2;
  exports.displacementVert = vertex$1;
  exports.displacementWgsl = source$2;
  exports.effectsMixin = effectsMixin;
  exports.ensureAttributes = ensureAttributes;
  exports.ensureIsBuffer = ensureIsBuffer;
  exports.ensurePrecision = ensurePrecision;
  exports.executeInstructions = executeInstructions;
  exports.extensions = extensions;
  exports.extractAttributesFromGlProgram = extractAttributesFromGlProgram;
  exports.extractAttributesFromGpuProgram = extractAttributesFromGpuProgram;
  exports.extractStructAndGroups = extractStructAndGroups;
  exports.fastCopy = fastCopy;
  exports.findHooksRx = findHooksRx;
  exports.formatShader = formatShader;
  exports.fragmentGPUTemplate = fragmentGPUTemplate;
  exports.fragmentGlTemplate = fragmentGlTemplate;
  exports.generateArraySyncSTD40 = generateArraySyncSTD40;
  exports.generateArraySyncWGSL = generateArraySyncWGSL;
  exports.generateBlurFragSource = generateBlurFragSource;
  exports.generateBlurGlProgram = generateBlurGlProgram;
  exports.generateBlurProgram = generateBlurProgram;
  exports.generateBlurVertSource = generateBlurVertSource;
  exports.generateGPULayout = generateGPULayout;
  exports.generateGpuLayoutGroups = generateGpuLayoutGroups;
  exports.generateLayout = generateLayout;
  exports.generateLayoutHash = generateLayoutHash;
  exports.generateParticleUpdateFunction = generateParticleUpdateFunction;
  exports.generateProgram = generateProgram;
  exports.generateShaderSyncCode = generateShaderSyncCode;
  exports.generateTextureBatchBit = generateTextureBatchBit;
  exports.generateTextureBatchBitGl = generateTextureBatchBitGl;
  exports.generateUID = generateUID;
  exports.generateUniformsSync = generateUniformsSync;
  exports.getAdjustedBlendModeBlend = getAdjustedBlendModeBlend;
  exports.getAttributeInfoFromFormat = getAttributeInfoFromFormat;
  exports.getBatchSamplersUniformGroup = getBatchSamplersUniformGroup;
  exports.getDefaultUniformValue = getDefaultUniformValue;
  exports.getGeometryBounds = getGeometryBounds;
  exports.getGlTypeFromFormat = getGlTypeFromFormat;
  exports.getGlobalBounds = getGlobalBounds;
  exports.getGlobalRenderableBounds = getGlobalRenderableBounds;
  exports.getLocalBounds = getLocalBounds;
  exports.getMatrixRelativeToParent = getMatrixRelativeToParent;
  exports.getMaxFragmentPrecision = getMaxFragmentPrecision;
  exports.getOrientationOfPoints = getOrientationOfPoints;
  exports.getTextureBatchBindGroup = getTextureBatchBindGroup;
  exports.getUboData = getUboData;
  exports.getUniformData = getUniformData;
  exports.glUploadBufferImageResource = glUploadBufferImageResource;
  exports.glUploadCompressedTextureResource = glUploadCompressedTextureResource;
  exports.glUploadImageResource = glUploadImageResource;
  exports.globalUniformsBit = globalUniformsBit;
  exports.globalUniformsBitGl = globalUniformsBitGl;
  exports.globalUniformsUBOBitGl = globalUniformsUBOBitGl;
  exports.gpuUploadBufferImageResource = gpuUploadBufferImageResource;
  exports.gpuUploadCompressedTextureResource = gpuUploadCompressedTextureResource;
  exports.gpuUploadImageResource = gpuUploadImageResource;
  exports.gpuUploadVideoResource = gpuUploadVideoResource;
  exports.groupD8 = groupD8;
  exports.hslWgsl = hsl;
  exports.hslgl = hslgl;
  exports.hslgpu = hslgpu;
  exports.injectBits = injectBits;
  exports.insertVersion = insertVersion;
  exports.isMobile = isMobile;
  exports.isPow2 = isPow2;
  exports.isRenderingToScreen = isRenderingToScreen;
  exports.isSafari = isSafari;
  exports.isWebGLSupported = isWebGLSupported;
  exports.isWebGPUSupported = isWebGPUSupported;
  exports.localUniformBit = localUniformBit;
  exports.localUniformBitGl = localUniformBitGl;
  exports.localUniformBitGroup2 = localUniformBitGroup2;
  exports.log2 = log2;
  exports.logProgramError = logProgramError;
  exports.mapFormatToGlFormat = mapFormatToGlFormat;
  exports.mapFormatToGlInternalFormat = mapFormatToGlInternalFormat;
  exports.mapFormatToGlType = mapFormatToGlType;
  exports.mapGlToVertexFormat = mapGlToVertexFormat;
  exports.mapSize = mapSize;
  exports.mapType = mapType;
  exports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;
  exports.maskFrag = fragment;
  exports.maskVert = vertex;
  exports.maskWgsl = source;
  exports.matrixPool = matrixPool;
  exports.measureMixin = measureMixin;
  exports.mipmapScaleModeToGlFilter = mipmapScaleModeToGlFilter;
  exports.mixColors = mixColors;
  exports.mixHexColors = mixHexColors;
  exports.mixStandardAnd32BitColors = mixStandardAnd32BitColors;
  exports.multiplyHexColors = multiplyHexColors;
  exports.nextPow2 = nextPow2;
  exports.noiseFrag = fragment$1;
  exports.noiseWgsl = source$1;
  exports.normalizeExtensionPriority = normalizeExtensionPriority;
  exports.parseFunctionBody = parseFunctionBody;
  exports.particleData = particleData;
  exports.particlesFrag = fragment$5;
  exports.particlesVert = vertex$3;
  exports.particlesWgsl = wgsl;
  exports.path = path;
  exports.pointInTriangle = pointInTriangle;
  exports.removeItems = removeItems;
  exports.removeStructAndGroupDuplicates = removeStructAndGroupDuplicates;
  exports.resetUids = resetUids;
  exports.roundPixelsBit = roundPixelsBit;
  exports.roundPixelsBitGl = roundPixelsBitGl;
  exports.sayHello = sayHello;
  exports.scaleModeToGlFilter = scaleModeToGlFilter;
  exports.setPositions = setPositions;
  exports.setProgramName = setProgramName;
  exports.setUvs = setUvs;
  exports.squaredDistanceToLineSegment = squaredDistanceToLineSegment;
  exports.stripVersion = stripVersion;
  exports.textureBit = textureBit;
  exports.textureBitGl = textureBitGl;
  exports.tilingBit = tilingBit;
  exports.tilingBitGl = tilingBitGl;
  exports.toLocalGlobalMixin = toLocalGlobalMixin;
  exports.transformVertices = transformVertices;
  exports.uboSyncFunctionsSTD40 = uboSyncFunctionsSTD40;
  exports.uboSyncFunctionsWGSL = uboSyncFunctionsWGSL;
  exports.uid = uid$1;
  exports.uidCache = uidCache;
  exports.uniformParsers = uniformParsers;
  exports.unpremultiplyAlpha = unpremultiplyAlpha$1;
  exports.updateQuadBounds = updateQuadBounds;
  exports.updateRenderGroupTransform = updateRenderGroupTransform;
  exports.updateTransformAndChildren = updateTransformAndChildren;
  exports.updateTransformBackwards = updateTransformBackwards;
  exports.vertexGPUTemplate = vertexGPUTemplate;
  exports.vertexGlTemplate = vertexGlTemplate;
  exports.warn = warn;
  exports.wrapModeToGlAddress = wrapModeToGlAddress;
  exports.FilterSetPool = FilterSetPool;
  exports.FilterEffectPool = FilterEffectPool;
  return exports;
})({});